"{ Package: 'stx:goodies/refactoryBrowser/parser' }""{ NameSpace: Smalltalk }"RBProgramNode subclass:#RBPragmaNode	instanceVariableNames:'selector selectorParts arguments left right'	classVariableNames:''	poolDictionaries:''	category:'Refactory-AST-Nodes'!RBPragmaNode comment:'RBPragmaNode is an AST node that represents a method pragma.Instance Variables:	arguments <SequenceableCollection of: RBLiteralNode> our argument nodes	left <Integer | nil> position of <	right <Integer | nil> position of >	selector <Symbol | nil>	the selector we''re sending (cached)	selectorParts <SequenceableCollection of: RBValueToken> the tokens for each keyword'!!RBPragmaNode class methodsFor:'instance creation'!selectorParts: keywordTokens arguments: valueNodes 	^ self new selectorParts: keywordTokens arguments: valueNodes ! !!RBPragmaNode methodsFor:'accessing'!argumentAt: keywordSelector	^ self 		argumentAt: keywordSelector		ifAbsent: [ KeyNotFound signalFor: keywordSelector ]!argumentAt: keywordSelector ifAbsent: absentBlock	self selectorParts with: self arguments do: [ :selectorPart :argument |		selectorPart value = keywordSelector			ifTrue: [ ^ argument ]].	^ absentBlock value!argumentCount    ^ self selector argumentCount!arguments        arguments isNil ifTrue: [^ #()].        ^ arguments!arguments: aLiteralCollection 	arguments := aLiteralCollection.	arguments do: [ :each | each parent: self ]!children	^ self arguments!numArgs	^ self selector numArgs!selector	^ selector ifNil: [ selector := self buildSelector ]!selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: 'Attempting to assign selector with wrong number of arguments.'].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last = $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector asSymbol!sentMessages	^ super sentMessages		add: self selector;		yourself!start	^ left!stop	^ right! !!RBPragmaNode methodsFor:'accessing-token'!left	^ left!left: anInteger	left := anInteger!right	^ right!right: anInteger	right := anInteger! !!RBPragmaNode methodsFor:'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self selector = anObject selector ifFalse: [^false].	1 to: self arguments size		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].	^true!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [ ^ false ].	self selector = anObject selector ifFalse: [ ^ false ].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary) 			ifFalse: [ ^ false ] ].	^ true!hash	^ self selector hash bitXor: (self hashForCollection: self arguments)!semanticallyEqualTo: anObject withMapping: aDictionary         self class = anObject class ifFalse: [ ^ false ].        self selector = anObject selector ifFalse: [ ^ false ].        self arguments with: anObject arguments do: [ :first :second |                (first semanticallyEqualTo: second withMapping: aDictionary)                         ifFalse: [ ^ false ] ].        ^ true! !!RBPragmaNode methodsFor:'copying'!postCopy	super postCopy.	self arguments: (self arguments collect: [ :each | each copy ])! !!RBPragmaNode methodsFor:'initialization'!selectorParts: keywordTokens arguments: valueNodes 	self selectorParts: keywordTokens.	self arguments: valueNodes! !!RBPragmaNode methodsFor:'matching'!copyInContext: aDictionary 	^ self class new		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);		yourself!match: aNode inContext: aDictionary 	aNode class = self class		ifFalse: [ ^ false ].	self selector = aNode selector		ifFalse: [ ^ false ].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [ ^ false ] ].	^ true! !!RBPragmaNode methodsFor:'private'!buildSelector	^(String streamContents: [ :selectorStream | 		selectorParts do: [ :each | selectorStream nextPutAll: each value ]]) asSymbol!selectorParts	^ selectorParts!selectorParts: tokenCollection 	selectorParts := tokenCollection! !!RBPragmaNode methodsFor:'replacing'!replaceNode: aNode withNode: anotherNode 	self arguments: (arguments collect: [ :each | 		each == aNode 			ifTrue: [ anotherNode ]			ifFalse: [ each ] ])! !!RBPragmaNode methodsFor:'testing'!isBinary	^ (self isUnary or: [self isKeyword]) not!isFaulty	^self arguments anySatisfy: #isFaulty.!isKeyword	^ selectorParts first value last = $:!isPragma	^ true!isPrimitive	^ #(primitive: primitive:error: primitive:error:module: primitive:module: primitive:module:error:) includes: self selector!isUnary	^ arguments isEmpty! !!RBPragmaNode methodsFor:'visiting'!acceptVisitor: aProgramNodeVisitor         ^ aProgramNodeVisitor acceptPragmaNode: self    "Modified: / 07-10-2014 / 23:41:32 / Jan Vrany <jan.vrany@fit.cvut.cz>"! !!RBPragmaNode class methodsFor:'documentation'!version    ^ '$Header$'!version_CVS    ^ '$Header$'!version_HG    ^ '$Changeset: <not expanded> $'! !