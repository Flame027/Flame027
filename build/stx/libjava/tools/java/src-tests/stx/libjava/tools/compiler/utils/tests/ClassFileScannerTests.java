/*
 * COPYRIGHT (c) 2010-2015 by Jan Vrany, Jan Kurs and Marcel Hlopko
 * COPYRIGHT (c) 2014-2015 by Tomas Heger
 *                            SWING Research Group, Czech Technical University in Prague
 *
 * This software is furnished under a license and may be used
 * only in accordance with the terms of that license and with the
 * inclusion of the above copyright notice. This software may not
 * be provided or otherwise made available to, or used by, any
 * other person. No title to or ownership of the software is
 * hereby transferred.
 */
package stx.libjava.tools.compiler.utils.tests;

import static org.junit.Assert.*;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;

import org.junit.Test;

import stx.libjava.tools.compiler.utils.ClassFileScanner;

@stx.libjava.annotation.Package("stx:libjava/tools")
public class ClassFileScannerTests {

	/**
	 * Simple class name retrieval test
	 */
	@Test
	public void test_01() { 
		ClassFileScanner scanner = new ClassFileScanner();
		String className = scanner.getClassName(new DataInputStream(
			ClassLoader.getSystemResourceAsStream("java/lang/Object.class")));
		
		assertEquals("java/lang/Object", className);
	}

	/**
	 * Retrieval of a class name with non-ASCII characters in it
	 */
	@Test
	public void test_02() { 
		ClassFileScanner scanner = new ClassFileScanner();
		
		// this is bytecode of the following class (compiled by javac):
		// public class ZlutouckyKun { 
		// }
		// (with czech diacritics, see below why...)
		final byte[] classFile = new byte[] {
			(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE, 0x00, 0x00, 
			0x00, 0x33, 0x00, 0x0D, 0x0A, 0x00, 0x03, 0x00, 0x0A, 0x07, 0x00, 
			0x0B, 0x07, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x3C, 0x69, 0x6E, 0x69, 
			0x74, 0x3E, 0x01, 0x00, 0x03, 0x28, 0x29, 0x56, 0x01, 0x00, 0x04, 
			0x43, 0x6F, 0x64, 0x65, 0x01, 0x00, 0x0F, 0x4C, 0x69, 0x6E, 0x65, 
			0x4E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x54, 0x61, 0x62, 0x6C, 0x65, 
			0x01, 0x00, 0x0A, 0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x46, 0x69, 
			0x6C, 0x65, 0x01, 0x00, 0x17, (byte) 0xC5, (byte) 0xBD, 0x6C, 0x75, 
			(byte) 0xC5, (byte) 0xA5, 0x6F, 0x75, (byte) 0xC4, (byte) 0x8D, 
			0x6B, (byte) 0xC3, (byte) 0xBD, 0x4B, (byte) 0xC5, (byte) 0xAF, 
			(byte) 0xC5, (byte) 0x88, 0x2E, 0x6A, 0x61, 0x76, 0x61, 0x0C, 0x00, 
			0x04, 0x00, 0x05, 0x01, 0x00, 0x12, (byte) 0xC5, (byte) 0xBD, 0x6C, 
			0x75, (byte) 0xC5, (byte) 0xA5, 0x6F, 0x75, (byte) 0xC4, 
			(byte) 0x8D, 0x6B, (byte) 0xC3, (byte) 0xBD, 0x4B, (byte) 0xC5, 
			(byte) 0xAF, (byte) 0xC5, (byte) 0x88, 0x01, 0x00, 0x10, 0x6A, 0x61, 
			0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67, 0x2F, 0x4F, 0x62, 0x6A, 
			0x65, 0x63, 0x74, 0x00, 0x21, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x04, 0x00, 0x05, 0x00, 
			0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1D, 0x00, 0x01, 0x00, 0x01, 
			0x00, 0x00, 0x00, 0x05, 0x2A, (byte) 0xB7, 0x00, 0x01, (byte) 0xB1, 
			0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 
			0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 
			0x00, 0x02, 0x00, 0x09
		};
		
		String className = scanner.getClassName(new DataInputStream(
			new ByteArrayInputStream(classFile)));
		/* Argh...the expected string below used to be directly in UTF8, but 
		 * javac on Windows but default expects files to be in CP1252! One may
		 * tell javac which encoding to use, but then the whole setup is quite
		 * fragile. So use \\uXXXX escaping, sigh.  
		 * 
		 * See SO: http://stackoverflow.com/questions/464874/unmappable-character-for-encoding-warning-in-java
		 * See     http://itpro.cz/juniconv/
		 */
		assertEquals("\u017Dlu\u0165ou\u010Dk\u00FDK\u016F\u0148", className);
	}
	
	/**
	 * Magic corrupted
	 */
	@Test
	public void test_03() { 
		ClassFileScanner scanner = new ClassFileScanner();
		
		// this is bytecode of the following class (compiled by javac) but with 
		// the magic number corrupted (0xAAFEBABE instead of 0xCAFEBABE):
        // public class ZlutouckyKun { 
        // }
        // (with czech diacritics, see below why...)
		final byte[] classFile = new byte[] {
			(byte) 0xAA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE, 0x00, 0x00, 
			0x00, 0x33, 0x00, 0x0D, 0x0A, 0x00, 0x03, 0x00, 0x0A, 0x07, 0x00, 
			0x0B, 0x07, 0x00, 0x0C, 0x01, 0x00, 0x06, 0x3C, 0x69, 0x6E, 0x69, 
			0x74, 0x3E, 0x01, 0x00, 0x03, 0x28, 0x29, 0x56, 0x01, 0x00, 0x04, 
			0x43, 0x6F, 0x64, 0x65, 0x01, 0x00, 0x0F, 0x4C, 0x69, 0x6E, 0x65, 
			0x4E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x54, 0x61, 0x62, 0x6C, 0x65, 
			0x01, 0x00, 0x0A, 0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x46, 0x69, 
			0x6C, 0x65, 0x01, 0x00, 0x17, (byte) 0xC5, (byte) 0xBD, 0x6C, 0x75, 
			(byte) 0xC5, (byte) 0xA5, 0x6F, 0x75, (byte) 0xC4, (byte) 0x8D, 
			0x6B, (byte) 0xC3, (byte) 0xBD, 0x4B, (byte) 0xC5, (byte) 0xAF, 
			(byte) 0xC5, (byte) 0x88, 0x2E, 0x6A, 0x61, 0x76, 0x61, 0x0C, 0x00, 
			0x04, 0x00, 0x05, 0x01, 0x00, 0x12, (byte) 0xC5, (byte) 0xBD, 0x6C, 
			0x75, (byte) 0xC5, (byte) 0xA5, 0x6F, 0x75, (byte) 0xC4, 
			(byte) 0x8D, 0x6B, (byte) 0xC3, (byte) 0xBD, 0x4B, (byte) 0xC5, 
			(byte) 0xAF, (byte) 0xC5, (byte) 0x88, 0x01, 0x00, 0x10, 0x6A, 0x61, 
			0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67, 0x2F, 0x4F, 0x62, 0x6A, 
			0x65, 0x63, 0x74, 0x00, 0x21, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x04, 0x00, 0x05, 0x00, 
			0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1D, 0x00, 0x01, 0x00, 0x01, 
			0x00, 0x00, 0x00, 0x05, 0x2A, (byte) 0xB7, 0x00, 0x01, (byte) 0xB1, 
			0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 
			0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 
			0x00, 0x02, 0x00, 0x09
		};
		
		String className = scanner.getClassName(new DataInputStream(
			new ByteArrayInputStream(classFile)));
		
		assertEquals(null, className);
	}

}

