"*
 * Encoding: iso8859-1
 *
 * $Header$
 *
 * MIMEType: application/x-smalltalk-source
 *
 * sample keyboardMacros.rc - file
 *
 * this file defines some keyboard macros
 * Feel free to add your own.
 * Here, only the macro-codes are defined;
 * the actual binding of macro to a particular key is done in keyboard.rc.
 *
 * these are my personal preferrences which may not be
 * correct for your environment.
 *
 * WARNING:
 *   please keep the expressions below free from manipulating
 *   global state.
 *   Reason: in multihead applications, this will be consulted for each
 *   new display screen.
 *"
!
|macros|

macros := UserPreferences current functionKeySequences.

"/
"/ macro to replace a text selection by unix commands output
"/
macros at:#ReplaceSelectionByUnixCommandsOutput put:'
	"replace selection by corresponding
	 unix commands output"

	|sel|

	sel := self selection.
	sel notNil ifTrue:[
	    self replace:
		(PipeStream readingFrom:(sel asString))
		    contents asString
	]
'.

"/
"/ macro to paste the text generated by a block
"/
"/macros at:#PasteBlockEvaluationsOutput put:'
"/        "replace selection by blocks output"
"/
"/        |sel s block|
"/
"/        sel := self selectionAsString.
"/        sel notNil ifTrue:[
"/            block := Compiler evaluate:sel asString string.
"/            s := '''' writeStream.
"/            block value:s.
"/            self paste:s contents asString
"/        ]
"/'.

"/
"/ macro to toggle tabs
"/
"/ no longer needed - there is a function for that, which we can call...
macros at:#ToggleTabs put:'self toggleTabSetting'.
"/macros at:#ToggleTabs put:'
"/        "toggle between 4-col
"/         and 8-col tabs"
"/
"/        (tabPositions == self class tab4Positions)
"/             ifTrue:[self setTab8]
"/             ifFalse:[self setTab4]
"/'.

"/
"/ macro to indent by 4
"/

"/ no longer needed - there is a function for that, which we can call...
macros at:#IndentBy4 put:'self indentBy:4'.
"/macros at:#IndentBy4 put:'
"/        "indent selected line-range
"/         by 4 spaces (i.e. to the right)"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1+1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            self withExecuteCursorDo:[
"/                line1 to:line2-1 do:[:lineNr |
"/                    |line|
"/
"/                    line := self listAt:lineNr.
"/                    line notNil ifTrue:[
"/                        line notEmpty ifTrue:[
"/                            line := ''    '' , line.
"/                            self withoutRedrawAt:lineNr put:line.
"/                            line1 = (line2-1) ifTrue:[
"/                                self cursorRight:4
"/                            ].
"/                        ]
"/                    ]
"/                ].
"/                self textChanged.
"/                line1 to:line2-1 do:[:lineNr |
"/                    self invalidateLine:lineNr.
"/                ].
"/            ].
"/        ]
"/'.

"/
"/ macro to undent by 4
"/
"/ no longer needed - there is a function for that, which we can call...
macros at:#UndentBy4 put:'self undentBy:4'.
"/macros at:#UndentBy4 put:'
"/        "undent selected line-range
"/         by 4 spaces (i.e. to the left)"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1+1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            self withExecuteCursorDo:[
"/                line1 to:line2-1 do:[:lineNr |
"/                    |line|
"/
"/                    line := self listAt:lineNr.
"/                    line notNil ifTrue:[
"/                        line notEmpty ifTrue:[
"/                            (line startsWith:''    '') ifTrue:[
"/                                line := line copyFrom:5.
"/                                self withoutRedrawAt:lineNr put:line.
"/                                line1 = (line2-1) ifTrue:[
"/                                    cursorCol > 4 ifTrue:[ self cursorLeft:4 ]
"/                                ].
"/                            ]
"/                        ]
"/                    ]
"/                ].
"/                self textChanged.
"/                line1 to:line2-1 do:[:lineNr |
"/                    self invalidateLine:lineNr.
"/                ].
"/            ].
"/        ]
"/'.

"/
"/ macro to indent by 1
"/
"/ no longer needed - there is a function for that, which we can call...
macros at:#IndentBy1 put:'self indentBy:1'.
"/macros at:#IndentBy1 put:'
"/        "indent selected line-range
"/         by 1 space (i.e. to the right)"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1+1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            self withExecuteCursorDo:[
"/                line1 to:line2-1 do:[:lineNr |
"/                    |line|
"/
"/                    line := self listAt:lineNr.
"/                    line notNil ifTrue:[
"/                        line notEmpty ifTrue:[
"/                            line := '' '' , line.
"/                            self withoutRedrawAt:lineNr put:line.
"/                            line1 = (line2-1) ifTrue:[
"/                                self cursorRight:1
"/                            ].
"/                        ]
"/                    ]
"/                ].
"/                self textChanged.
"/                line1 to:line2-1 do:[:lineNr |
"/                    self invalidateLine:lineNr.
"/                ].
"/            ]
"/        ]
"/'.

"/
"/ macro to undent by 1
"/
"/ no longer needed - there is a function for that, which we can call...
macros at:#UndentBy1 put:'self undentBy:1'.
"/macros at:#UndentBy1 put:'
"/        "undent selected line-range
"/         by 1 space (i.e. to the left)"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1+1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            self withExecuteCursorDo:[
"/                line1 to:line2-1 do:[:lineNr |
"/                    |line|
"/
"/                    line := self listAt:lineNr.
"/                    line notNil ifTrue:[
"/                        line notEmpty ifTrue:[
"/                            (line startsWith:'' '') ifTrue:[
"/                                line := line copyFrom:2.
"/                                self withoutRedrawAt:lineNr put:line.
"/                                line1 = (line2-1) ifTrue:[
"/                                    cursorCol > 1 ifTrue:[ self cursorLeft:1 ]
"/                                ].
"/                            ]
"/                        ]
"/                    ]
"/                ].
"/                self textChanged.
"/                line1 to:line2-1 do:[:lineNr |
"/                    self invalidateLine:lineNr.
"/                ].
"/            ].
"/        ]
"/'.

"/
"/ macro to convert selection to lowercase
"/
"/ no longer needed - there is a function for that, which we can call...
macros at:#ConvertSelectionToLowercase put:'self convertSelectionToLowercase'.
"/macros at:#ConvertSelectionToLowercase put:'
"/        "to-lower selected text"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            line1 to:line2 do:[:lineNr |
"/                |line col1 col2|
"/
"/                line := (self listAt:lineNr) copy.
"/                line size > 0 ifTrue:[
"/                    lineNr == line1 ifTrue:[
"/                        col1 := selectionStartCol.
"/                    ] ifFalse:[
"/                        col1 := 1.
"/                    ].
"/                    lineNr == line2 ifTrue:[
"/                        col2 := selectionEndCol.
"/                    ] ifFalse:[
"/                        col2 := (self listAt:lineNr) size.
"/                    ].
"/
"/                    col1 to:col2 do:[:col |
"/                        |ch|
"/
"/                        ch := line at:col.
"/                        line at:col put:ch asLowercase.
"/                    ].
"/                    self withoutRedrawAt:lineNr put:line.
"/                    self invalidateLine:lineNr.
"/                ].
"/            ].
"/        ]
"/'.

"/
"/ macro to convert selection to uppercaseFirst words
"/
"/ no longer needed - there is a function for that, which we can call...
macros at:#ConvertSelectionToUppercaseFirst put:'self convertSelectionToUppercaseFirst'.
"/macros at:#ConvertSelectionToUppercaseFirst put:'
"/        "to-upperFirst selected text"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            line1 to:line2 do:[:lineNr |
"/                |line col1 col2 state|
"/
"/                line := (self listAt:lineNr) copy.
"/                line size > 0 ifTrue:[
"/                    lineNr == line1 ifTrue:[
"/                        col1 := selectionStartCol.
"/                    ] ifFalse:[
"/                        col1 := 1.
"/                    ].
"/                    lineNr == line2 ifTrue:[
"/                        col2 := selectionEndCol.
"/                    ] ifFalse:[
"/                        col2 := (self listAt:lineNr) size.
"/                    ].
"/
"/                    state := #first.
"/                    col1 to:col2 do:[:col |
"/                        |ch|
"/
"/                        ch := line at:col.
"/                        ch isSeparator ifFalse:[
"/                            state == #first ifTrue:[
"/                                line at:col put:ch asUppercase.
"/                                state := #skipRest
"/                            ]
"/                        ] ifTrue:[
"/                            state := #first
"/                        ]
"/                    ].
"/                    self withoutRedrawAt:lineNr put:line.
"/                    self invalidateLine:lineNr.
"/                ].
"/            ].
"/        ]
"/'.

"/ no longer needed - there is a function for that, which we can call...
macros at:#ConvertSelectionToUppercase put:'self convertSelectionToUppercase'.
"/macros at:#ConvertSelectionToUppercase put:'
"/        "to-upper selected text"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            line1 to:line2 do:[:lineNr |
"/                |line col1 col2|
"/
"/                line := (self listAt:lineNr) copy.
"/                line size > 0 ifTrue:[
"/                    lineNr == line1 ifTrue:[
"/                        col1 := selectionStartCol.
"/                    ] ifFalse:[
"/                        col1 := 1.
"/                    ].
"/                    lineNr == line2 ifTrue:[
"/                        col2 := selectionEndCol.
"/                    ] ifFalse:[
"/                        col2 := (self listAt:lineNr) size.
"/                    ].
"/
"/                    col1 to:col2 do:[:col |
"/                        |ch|
"/
"/                        ch := line at:col.
"/                        line at:col put:ch asUppercase.
"/                    ].
"/                    self withoutRedrawAt:lineNr put:line.
"/                    self invalidateLine:lineNr.
"/                ].
"/            ].
"/        ]
"/'.

macros at:#ConvertSelectionToLowercaseOrUppercaseOrUppercaseFirst put:'self convertSelectionToLowercaseOrUppercaseOrUppercaseFirst'.
"/macros at:#ConvertSelectionToLowercaseOrUppercaseOrUppercaseFirst put:'
"/        "toLower/toUppercaseFirst/toUpper selected text"
"/
"/        |line1 line2|
"/
"/        line1 := self selectionStartLine.
"/        line2 := self selectionEndLine.
"/        line1 isNil ifTrue:[
"/            line1 := self perform:#cursorLine ifNotUnderstood:nil.
"/            line1 notNil ifTrue:[
"/                line2 := line1
"/            ]
"/        ].
"/        line1 notNil ifTrue:[
"/            line1 to:line2 do:[:lineNr |
"/                |line col1 col2 isAllLower isLowerFirst isAllUpper isUpperFirst
"/                 makeLowercase makeUppercase makeUppercaseFirst makeLowercaseFirst|
"/
"/                line := (self listAt:lineNr) copy.
"/                line size > 0 ifTrue:[
"/                    lineNr == line1 ifTrue:[
"/                        col1 := selectionStartCol.
"/                    ] ifFalse:[
"/                        col1 := 1.
"/                    ].
"/                    lineNr == line2 ifTrue:[
"/                        col2 := selectionEndCol.
"/                    ] ifFalse:[
"/                        col2 := (self listAt:lineNr) size.
"/                    ].
"/                    isAllLower := isAllUpper := isUpperFirst := isLowerFirst := true.
"/                    col1 to:col2 do:[:col |
"/                        |ch|
"/
"/                        ch := line at:col.
"/                        ch isUppercase ifTrue:[
"/                            isAllLower := false.
"/                            col == col1 ifTrue:[
"/                                isLowerFirst := false.
"/                            ].
"/                        ] ifFalse:[
"/                            ch isLowercase ifTrue:[
"/                                isAllUpper := false.
"/                                col == col1 ifTrue:[
"/                                    isUpperFirst := false.
"/                                ].
"/                            ]
"/                        ].
"/                    ].
"/
"/                    makeLowercase := makeUppercase := makeUppercaseFirst := makeLowercaseFirst := false.
"/                    isLowerFirst ifTrue:[
"/                        makeUppercaseFirst := true.
"/                    ] ifFalse:[
"/                        "/ must remember where we come from - otherwise, we end up
"/                        "/ in upperFirst - lowerFirst cycle.
"/                        "/ think about a good place to store this state
"/                        false "(isUpperFirst and:[isAllUpper not])" ifTrue:[
"/                            makeLowercaseFirst := true.
"/                         ] ifFalse:[
"/                            isAllUpper ifTrue:[
"/                                makeLowercase := true.
"/                            ] ifFalse:[
"/                                makeUppercase := true.
"/                            ]
"/                        ]
"/                    ].
"/                    makeUppercaseFirst ifTrue:[
"/                        line at:col1 put:(line at:col1) asUppercase.
"/                    ] ifFalse:[
"/                        makeLowercaseFirst ifTrue:[
"/                            line at:col1 put:(line at:col1) asLowercase.
"/                        ] ifFalse:[
"/                            col1 to:col2 do:[:col |
"/                                |ch|
"/
"/                                ch := line at:col.
"/                                ch := makeLowercase
"/                                        ifTrue:[ ch asLowercase ]
"/                                        ifFalse:[
"/                                            makeUppercase
"/                                                ifTrue:[ ch asUppercase ]
"/                                                ifFalse:[
"/                                                    col == col1
"/                                                        ifTrue:[ ch asUppercase ]
"/                                                        ifFalse:[ ch asLowercase ]
"/                                                ]
"/                                        ].
"/                                line at:col put:ch.
"/                            ].
"/                        ].
"/                    ].
"/                    self withoutRedrawAt:lineNr put:line.
"/                    self invalidateLine:lineNr.
"/                ].
"/            ].
"/        ]
"/'.

macros at:#ParenthizeSelection put:'self parenthizeSelection'.
"/macros at:#ParenthizeSelection put:'
"/        "place parenthesis around the selected text"
"/
"/        |line1 col1 line2 col2|
"/
"/        line1 := self selectionStartLine.
"/        col1 := self selectionStartCol.
"/        line2 := self selectionEndLine.
"/        col2 := self selectionEndCol.
"/        (line1 notNil
"/            and:[ col1 notNil
"/            and:[ line2 notNil
"/            and:[ col2 notNil ]]])
"/        ifTrue:[
"/            self insertString:'')'' atLine:line2 col:col2+1.
"/            self insertString:''('' atLine:line1 col:col1.
"/            self selectFromLine:line1 col:col1 toLine:line2 col:col2+2.
"/        ] ifFalse:[
"/            self beep.
"/        ]
"/'.

macros at:#UnparenthizeSelection put:'
	"remove parenthesis in the selected text"

	|line1 col1 line2 col2|

	line1 := self selectionStartLine.
	col1 := self selectionStartCol.
	line2 := self selectionEndLine.
	col2 := self selectionEndCol.
	(line1 notNil
	    and:[ col1 notNil
	    and:[ line2 notNil
	    and:[ col2 notNil
	    and:[ (''({[<'' includes:(self characterAtLine:line1 col:col1))
	    and:[ (''>]})'' includes:(self characterAtLine:line2 col:col2))  ]]]]])
	ifTrue:[
	    self deleteCharAtLine:line2 col:col2.
	    self deleteCharAtLine:line1 col:col1.
	    self selectFromLine:line1 col:col1 toLine:line2 col:col2-2.
	] ifFalse:[
	    self beep.
	]
'.

macros at:#SingleQuoteSelection put:'
	"place single quotes around the selected text"

	|line1 col1 line2 col2|

	line1 := self selectionStartLine.
	col1 := self selectionStartCol.
	line2 := self selectionEndLine.
	col2 := self selectionEndCol.
	(line1 notNil
	    and:[ col1 notNil
	    and:[ line2 notNil
	    and:[ col2 notNil ]]])
	ifTrue:[
	    self insertString:Character quote asString atLine:line2 col:col2+1.
	    self insertString:Character quote asString atLine:line1 col:col1.
	    self selectFromLine:line1 col:col1 toLine:line2 col:col2+2.
	] ifFalse:[
	    self beep.
	]
'.

"/macros keys do:[:k |
"/    Transcript showCR:k.
"/].
!
