<HTML>
<HEAD>
<TITLE>Tutorial - Creating a Web Application</TITLE>
</HEAD>

<BODY>

<A NOPRINT HREF="tut_3.html"> <IMG SRC="../../icons/DocsLeftArrow.gif" ALT="[prev]"></A>
<A NOPRINT HREF="tutorial.html">   <IMG SRC="../../icons/DocsUpArrow.gif" ALT="[up]"></A>
<A NOPRINT HREF="tut_4.html"> <IMG SRC="../../icons/DocsRightArrow.gif" ALT="[next]"></A>

<H1><A NAME="CREATING_A_WEB_APPLICATION">Creating a Web Application</A></H1>

Smalltalk/X already contains a complete web application framework.
This consists of a webServer, HTML-generation tool classes and a WebService class framework.
<P>
In this section, you will learn how to create simple programmed webServices.
<BR>
In a programmed service, web pages are generated by a program,
as opposed to static pages or pages with embedded code.

Services with embedded Smalltalk code are described elsewhere -
take a look at the
<A HREF="../programming/goody_webServ.html">STT overview</A>,
<A HREF="localhost:8080/stt">examples</A> and
<A HREF="misc/onlyInSTX2.html" ACTION="html:HTMLDocGenerator htmlDocOf:Comanche::STTModule">
browse the STT classes</A>.
For a demonstration, start a webServer in the launcher's settings dialog,
and enable the STT service there.
<P>

Here, you will learn how pure programmed services are created and coded.
In these, Smalltalk code is fully responsible both for the generation of html pages
and to handle submitted forms.
<P>

<H2><A NAME="STARTING_SERVER">Setting up a WebServer</A></H2>

In order for the following to work, we first have to
start the <CITE>ST/X</CITE> webserver.
In the launcher's settings-dialog, go to the "<VAR>Communication</VAR>"-"<VAR>HTTPServer</VAR>" section,
<BR>
<IMG SRC="../../pictures/SettingDialog_Web1.gif" ALT="[fig: webServer settings1]">
<P>
and press the <VAR>"Create new HTTP Server"</VAR> button.
<P>
This will instantiate a new instance of the <CODE>HTTPServer</CODE> class
(but not yet start it, so HTTP requests are not yet served by this).

If the default Smalltalk server port (8080) is used,
a number of default demo services will also be automatically added initially
(see below on how these can be removed or others be added).

<H3><A NAME="STARTING_FCGI">Creating an FCGI Server</A></H2>

In the above setup, the Smalltalk webServer had complete control over
the responses to incoming requests on its own port.

An alternative is to start the Smalltalk webServer as an FCGI ("fast-CGI") client
under another webServer, such as Apache.
For this, press the <VAR>"Create new FastCGI Server"</VAR> button.
<P>
[...more info on how to configure FCGI to be added here...]

<H3><A NAME="STARTING_SERVICE">Starting the Server</A></H2>

At this point, your server is fully instantiated, but not yet answering request on its port.
<BR>
To actually start the server,
find its item in the settings tree on the left, select it,
and press the <VAR>"start"</VAR> button (near the bottom of the dialog).
<P>
You may want to turn on the debug and trace check-boxes,
to get some feedback on the servers actions on the transcript.
Especially while developing a service, the debug option is very useful:
if it is on, and an error occurs during request processing,
a debugger will be entered. This allows for bugs to be fixed
right from within the event-processing operation.
If the flag is off, errors are cought by the servver, and a walkback information is
sent back to the browser. If course, in a machine running unobserved on a server,
you would not want debugviews to open up. So this flag should be off when going into
production (look at www.exept.de, to see a concrete example of such a server in operation).
<P>

To test-talk to your server, open Firefox, IE or Opera, and enter "localhost:8080/" (or whatever port you used) as the URL.
You should (at least) get an informal error response from it.


<H3><A NAME="STARTING_SERVICES">Starting Services</A></H2>

Next, to add or remove services, find the services section of the new webServer in the tree,
<IMG SRC="../../pictures/SettingDialog_Web2.gif" ALT="[fig: webServer settings2]">
<P>
Pick some service, and add it by pressing the <VAR>"Add Selected Service"</VAR> button.
(For the 8080 port, which is <CITE>ST/X's</CITE> standard port,
you will notice that some services have already been added automatically by the settings application
for you).
<P>
Notice, that every service is registered under a so-called "<VAR>linkName</VAR>".
This is the first component of the URL-path.
For example, if a service has been registered under a linkName of "foo",
the URL to get to this service in the webBrowser will be: <CODE>"http://&lt;yourHostName&gt;:8080/foo"</CODE>.
<P>
You may want to play with the webServer for a few minutes,
to see what is already provided and how the settings affect the service behavior.

As a recommendation, make sure that at least the
following services are up and running:
<TABLE>
<TR><TD>WebHomePageForSTX</TD>
<TD>will respond under the "/" (i.e. root) linkname with an introduction and
links to other running services.</TD>
</TR>
<TR><TD>HelloWorldService</TD>
<TD>will respond under the "/Hello" linkname with an obvious response.</TD>
</TR>
<TR><TD>WebDemoApp1</TD>
<TD>a demo service showing some simple examples.
This service is also able to present its own source code.</TD>
</TR>
<TR><TD>CommancheSTTService</TD>
<TD>a service which demonstrates embedded Smalltalk code (very similar to PHP)</TD>
</TR>
</TABLE>
Notice that you can add/remove services at *any* time,
and that there is no need to shutdown/restart the webServer for this.
<P>
Also, play with the security and authentication settings.
<P>
Finally, change the replyRepresenter settings. A replyPresenter is a wrapper,
which is able to wrap another services output and add a common decoration to it.
This allows you to easily change the look of a services pages (i.e. background, colors, font and icons etc.),
without even touching the service itself.
For now, only an exept-presenter and a null-presenter are provided.
To write your own, take any of them as a starting base.
<P>

Now, we are ready for the next step.
Let us create our own web application...


<H2><A NAME="CREATING_WEB_CLASS">Creating a New WebApplication Class</A></H2>
<P>
In <CITE>ST/X</CITE>, web services are created as subclasses of <CODE>HTTPService</CODE>.
<BR>
To make your life easier, the browser provides an extra menu item,
for the creation and initial definition of a web service class.
<P>
In the browser, select the <I>'New Web Application'</I> item from the
class-list-menu,
and accept the resulting class definition template:

<A TYPE="copyexample"><CODE><PRE>
    HTTPService subclass:#NewService
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebApplications'
</PRE></CODE></A>

After the accept, you will be asked if some application code skeletton shall be generated
for you.
Answer 'yes' here.
After that, go back to the webServer settings dialog, reselect the services page,
and ensure that your new service is now found in to the services list.


<P>
The required protocol for a webService (which has been already
generated for you as templates by the browser) is:
<P>
<TABLE>
<TR>
<TD><CODE><B>linkName</B></CODE></TD>
<TD>(class protocol)</TD>
<TD>specifies the default linkName. That name is used as default for the
registration towards the webServer.
The browser-generated code will return the classes name. </TD>
</TR>

<TR>
<TD><CODE><B>process:</B></CODE><VAR>aRequest</VAR></TD>
<TD>(instance protocol)</TD>
<TD>the method invoked to process HTTP-requests.
The browser-generated code will
generate simple HTML for a "Hello World" message.</TD>
</TR>
</TABLE>

Of course, we will have to change the browser-generated <CODE>"process:"</CODE> method later,
to fit our needs.
<P>
When you send it a request from a web browser,
you should get the following response:
<BR>
<IMG SRC="../../pictures/WebServerHello.gif" ALT="[fig: webServer response]">
<P>

The argument to the <CODE>"process:"</CODE> message is a request object,
which contains all relevant information of the http-request.
For example, the requesting host,
the URL, any authentication information etc. are found there.
<P>
To get familiar with it, place a <CODE>"self halt"</CODE>
into the <CODE>"process:"</CODE> method (or put a breakpoint on it),
and invoke it by sending a request from your web browser.

From within the debugger, inspect the request object and/or browse its class.
<P>
One special item of the request object is the <VAR>response-object</VAR>.
This is an object, which collects the generated HTML for the response.
It understands the write-stream protocol, so you can generate HTML as simply
as if you would write it to a file.
<BR>
Initially, at the entry of your <CODE>"process:"</CODE>-method, the response object
is empty (so, if you never write anything to it, the web browser will get an empty response).
<P>

<H2><A NAME="CHANGING_THE_RESPONSE">Changing the Response</A></H2>

Let us change the <CODE>"process:"</CODE>-method,
to return some more information about the request (the text below can be copied with a right-click):
<A TYPE="copyexample"><CODE><PRE>
process:aRequest
    "This is the web applications main processing method.
     It will be invoked for every incoming webBrowser-request.
     The argument, aRequest contains the parameters (url, fields, parameters etc.)."

    |response|

    response := aRequest response.
    response nextPutLine:'&lt;HTML&gt;'.
    response nextPutLine:'  &lt;HEAD&gt;'.
    response nextPutLine:'  &lt;TITLE&gt;Hello&lt;/TITLE&gt;'.
    response nextPutLine:'  &lt;/HEAD&gt;'.
    response nextPutLine:'  &lt;BODY&gt;'.
    response nextPutLine:'    &lt;H1&gt;Hello World !&lt;/H1&gt;'.
    response nextPutLine:'    The URL was: "', aRequest url ,'"'.
    response nextPutLine:'    &lt;BR&gt;'.
    response nextPutLine:'    The requestor was: "', aRequest peerName ,'"'.
    response nextPutLine:'    &lt;BR&gt;'.
    response nextPutLine:'    The current time is: "', Time now printString ,'"'.
    response nextPutLine:'    &lt;BR&gt;'.
    response nextPutLine:'    The relative URL path is: "', aRequest pathRelativeToService ,'"'.
    response nextPutLine:'  &lt;/BODY&gt;'.
    response nextPutLine:'&lt;/HTML&gt;'.
</PRE></CODE></A>

Of course, you can generate whatever response you like here.
It is even possible to send an HTTP-request to another webServer and postprocess its
response (that is what a meta-search engines do).
<P>
Also notice, that the response is completely generated by your program.
There are no files involved, as required in PHP based systems.
However, if you want to work that way, have a look at the STT-service.
But be warned: debugging is less fun if you work file-based.


<H2><A NAME="SUBPAGES">Adding Sub-Page Responses</A></H2>

One particular interresting piece of information in the request is <VAR>pathRelativeToService</VAR>.
This is the URL-path relative the the services linkName
and can be used to dispatch into sub-pages of our service.
<BR>
For example, to have two sub-pages named "foo" and "bar",
let us first create two corresponding methods:
<A TYPE="copyexample"><CODE><PRE>
foo:aRequest
    |response|

    response := aRequest response.
    response nextPutLine:'&lt;HTML&gt;'.
    response nextPutLine:'  &lt;HEAD&gt;'.
    response nextPutLine:'  &lt;TITLE&gt;Foo&lt;/TITLE&gt;'.
    response nextPutLine:'  &lt;/HEAD&gt;'.
    response nextPutLine:'  &lt;BODY&gt;'.
    response nextPutLine:'    &lt;H1&gt;Hello Foo !&lt;/H1&gt;'.
    response nextPutLine:'  &lt;/BODY&gt;'.
    response nextPutLine:'&lt;/HTML&gt;'.
</PRE></CODE></A>
and
<A TYPE="copyexample"><CODE><PRE>
bar:aRequest
    |response|

    response := aRequest response.
    response nextPutLine:'&lt;HTML&gt;'.
    response nextPutLine:'  &lt;HEAD&gt;'.
    response nextPutLine:'  &lt;TITLE&gt;Bar&lt;/TITLE&gt;'.
    response nextPutLine:'  &lt;/HEAD&gt;'.
    response nextPutLine:'  &lt;BODY&gt;'.
    response nextPutLine:'    &lt;H1&gt;Hello Bar !&lt;/H1&gt;'.
    response nextPutLine:'  &lt;/BODY&gt;'.
    response nextPutLine:'&lt;/HTML&gt;'.
</PRE></CODE></A>
and then change the main-process method into a dispatcher:
<A TYPE="copyexample"><CODE><PRE>
process:aRequest
    "This is the web applications main processing method.
     It will be invoked for every incoming webBrowser-request.
     The argument, aRequest contains the parameters (url, fields, parameters etc.)."

    |response nameOfSubPage|

    response := aRequest response.

    nameOfSubPage := aRequest pathRelativeToService.
    ( #('foo' 'bar' ) includes:nameOfSubPage) ifTrue:[
	self
	    perform:(nameOfSubPage , ':') asSymbol
	    with:aRequest.
	^ self.
    ].

    response nextPutLine:'Bad Request.'.
</PRE></CODE></A>

In the above code, please have a look at two specialities:
<OL>
<LI>the use of a <CODE>perform:</CODE>-message, which takes the pages name as a message-selector
to dispatch into the <CODE>"foo:"</CODE> and <CODE>"bar:"</CODE> methods.
<P>
<LI>the check for the name being in a "list of allowed pages" (the includes:-line).
Without that, an bad guy could send you any message and possibly do harm to your
service. This is needed because the use of the above <CODE>perform:</CODE>-message
can possibly open security holes.
</OL>

Now, try the URLs:
<CODE><PRE>     http://localhost:8080/NewService/foo</PRE></CODE>
and
<CODE><PRE>     http://localhost:8080/NewService/bar</PRE></CODE>

Notice the default behavior for unknown pages.
<BR>
A better response would be to send a proper error message,
which is done by a <CODE>"reportBadRequest:</CODE>-message to the request,
as in:

<A TYPE="copyexample"><CODE><PRE>
process:aRequest
    "This is the web applications main processing method.
     It will be invoked for every incoming webBrowser-request.
     The argument, aRequest contains the parameters (url, fields, parameters etc.)."

    |response nameOfSubPage|

    response := aRequest response.

    nameOfSubPage := aRequest pathRelativeToService.
    ( #('foo' 'bar' ) includes:nameOfSubPage) ifTrue:[
	self
	    perform:(nameOfSubPage , ':') asSymbol
	    with:aRequest.
	^ self.
    ].

    aRequest reportNotFound:'This is not a valid foo-bar request !'.
</PRE></CODE></A>
Have a look into the <CODE>HTTPRequest</CODE> classes' "error-reporting"
category for more possible answers.
<P>

If your webservice has a relatively static structure,
this selector-dispatching approach may be ok for you.
There is already an abstract service class called "<CODE>HTTPSelectorService</CODE>"
which does the above dispatch for you. Take a look in a browser for more info.
<P>
For very dynamic websites, this selector approach often not flexible enough.
These will typically dispatch by other means into the page-generating code.
(Some even fetch the generating Smalltalk code from a database.)


<H2><A NAME="HTML_GENERATION">Easier HTML Generation</A></H2>

In the above examples, HTML was generated as plain line oriented text.
Although this is ok to begin with, you will sooner or later encounter
difficulties in generating proper html.
<BR>
Every programmer makes mistakes, and so will you - especially, when the generated HTML
becomes complex and tag-structures become deeply nested.
Typical bugs are missing end-tags, unallowed tags (such as TR outside of a table), typing errors etc.
<BR>
To help in those situations, a set of classes is provided, which is able to
represent the html document as a tree of objects.
These deal with nesting and also know which element is allowed to be contained in which other.
Also, as the tree is constructed by messages sends (which are named after the desired element),
typing errors are detected earlier and you will get a doesNotUnderstand in the worst case.
Instead of sending invalid HTML to the browser. Typically, the syntax checker will even detect the
typo while you type in the code.
<P>
The classes for HTML building are found under the "Net-Documents-ModelTree" category.
If they are not already in your system, load the package with "<CODE>Smalltalk loadPackage:'stx:goodies/webServer/htmlTree'</CODE>.
the classes to look at are <CODE>"HTML::AbstractElement"</CODE> for the
entities and <CODE>"HTML::TreeBuilder"</CODE> for building.
<P>
The treebuilder understands HTML-tag-like messages,
and constructs a dom-like tree of HTMLElement objects on the fly.
Eventually, the tree is asled for its textual representation,
which can be returned as the HTTP-requests response.
<P>
The advantage of using a tree is that there is no longer a need to construct it
sequentially from top to bottom, as would be the case with sequential, linewise html-generation.
Thus, you can define and use a much more modular aproach, in which components and parts
of the document can be easily generated from building blocks.
<P>
Using this library, the code for the foo-handler would be:

<A TYPE="copyexample"><CODE><PRE>
foo:aRequest
    |builder|

    builder := HTML::TreeBuilder new.

    builder
	html;
	  head;
	    title:'Foo';
	  headEnd;
	  body;
	    h1:'Hello Foo!';
	  bodyEnd;
	htmlEnd.

    aRequest response
	nextPutAll:(builder htmlString).
</PRE></CODE></A>


<HR>
<P>
[...Text to be continued...]
<P>

<H2><A NAME="TREEBUILDING">Subclassing the HTMLTreeBuilder</A></H2>
<H2><A NAME="SESSION_CONTROL">Session Control</A></H2>
<H2><A NAME="COOKIES">Cookies</A></H2>
<H2><A NAME="TEMPORARY_LINKS">Temporary Links</A></H2>
<H2><A NAME="HIGHER_LEVEL_FRAMEWORKS">Higher Level Frameworks</A></H2>
<!-- <H2><A NAME="UI_PAINTING_WEBPAGES">UI-Painting Webpages</A></H2>  -->

<H2><A NAME="EXISTING_SERVICES">Existing Services</A></H2>
Please use the system browser, to find out more about existing services.
You will find both mature services for production use and also demo services for demonstration purpose.
<P>
As a start, look at the following services:
<TABLE BORDER>
<TR>
 <TD>
    <A HREF='../help/HTTPServices/fileServiceSettings.html'>HTTPFileService</A>
 </TD>
 <TD>
Provides access to plain (HTML-document or other) files,
    <BR>
&nbsp;and optionally directories to be listed.
 </TD>
</TR>

<TR>
 <TD>
    <A HREF='../help/HTTPServices/classDocSettings.html'>ClassDocService</A>
 </TD>
 <TD>
Provides just-in-time generated class documentation.
    <BR>
&nbsp;(nice for the intranet, when working in a team).
 </TD>
</TR>

<TR>
 <TD>
    <A HREF='../help/HTTPServices/webSlideShowSettings.html'>WebSlideShowService</A>
 </TD>
 <TD>
Provides a slideshow for bitmap images and digital photos.
 </TD>
</TR>

<TR>
 <TD>
    HelloWorldService
 </TD>
 <TD>
A simple example, showing the minimum required code for a web service.
 </TD>
</TR>

<TR>
 <TD>
    WebHomePageForSTX
 </TD>
 <TD>
An entry page, which dynamically provides links to other configured services.
 </TD>
</TR>

<TR>
 <TD>
    WebProcessList
 </TD>
 <TD>
Presents a list of currently present Smalltalk processes (threads)
<br>of the running Smalltalk executable.
 </TD>
</TR>

</TABLE>

<HR>
Continue in <A HREF="tut_4.html">"Creating a GUI Applicaiton"</A>.

<P>
<P>
<HR>
<P>
<IMG NOPRINT ALIGN=middle SRC="../../icons/stx.gif" ALT="[stx-logo]">
<BR>Copyright &copy; Claus Gittinger Development & Consulting
<BR>Copyright &copy; eXept Software AG
<P>
<ADDRESS>
<tt>&lt;<a href="mailto:cg@exept.de">cg@exept.de</a>&gt;</tt>
</ADDRESS>

<HR>
Doc $Revision: 1.20 $ $Date: 2014-04-04 01:28:15 $

</BODY>
</HTML>
