<HEAD>
<TITLE>Using the System Browser - menu functions</TITLE>
</HEAD>

<BODY>
<A NOPRINT HREF="intro.html">  <IMG SRC="../../../icons/DocsLeftArrow.gif" ALT="[prev]"></A>
<A NOPRINT HREF="TOP.html"> <IMG SRC="../../../icons/DocsUpArrow.gif" ALT="[up]"></A>
<A NOPRINT HREF="accept.html"> <IMG SRC="../../../icons/DocsRightArrow.gif" ALT="[next]"></A>

<H2><A NAME="MENU" HREF="TOP.html#I_MENU">Menu functions</A></H2>

  Each of the views provides its own middle button popup menu - activated by
  pressing the middle mouse button (the right button if you use a 2-button mouse).

<H3><A NAME="CLASSCATEGORY_MENU" HREF="TOP.html#I_CLASSCATEGORY_MENU">Class category list popup menu functions</A></H3>

<IMG SRC="../../../pictures/SystemBrowserMenuClassCategory.gif" ALT="[class category menu hardcopy] ">
<BR>Class category lists menu
<P>

  The class category list provides the following menu functions:
    <UL>
    <LI><A NAME="I_CLASSCATEGORY_MENU.FILEOUT"       HREF="#CLASSCATEGORY_MENU.FILEOUT">fileOut</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.FILEOUT_EACH"  HREF="#CLASSCATEGORY_MENU.FILEOUT_EACH">fileOut each</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.PRINTOUT"      HREF="#CLASSCATEGORY_MENU.PRINTOUT">printOut</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.PRINTOUT_PROT" HREF="#CLASSCATEGORY_MENU.PRINTOUT_PROT">printOut protocol</A>
    <P>
    <LI><A NAME="I_CLASSCATEGORY_MENU.CLONE"         HREF="#CLASSCATEGORY_MENU.CLONE">clone</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.OPENFOR"       HREF="#CLASSCATEGORY_MENU.OPENFOR">open for class</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.SPAWN"         HREF="#CLASSCATEGORY_MENU.SPAWN">spawn</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.SPAWN_FULL"    HREF="#CLASSCATEGORY_MENU.SPAWN_FULL">spawn full class</A>
    <P>
    <LI><A NAME="I_CLASSCATEGORY_MENU.UPDATE"        HREF="#CLASSCATEGORY_MENU.UPDATE">update</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.FIND_CLASS"    HREF="#CLASSCATEGORY_MENU.FIND_CLASS">find class</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.FIND_METHOD"   HREF="#CLASSCATEGORY_MENU.FIND_METHOD">find method</A>
    <P>
    <LI><A NAME="I_CLASSCATEGORY_MENU.NEW_CATEGORY"  HREF="#CLASSCATEGORY_MENU.NEW_CATEGORY">new class category</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.RENAME"        HREF="#CLASSCATEGORY_MENU.RENAME">rename</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.REMOVE"        HREF="#CLASSCATEGORY_MENU.REMOVE">remove</A>
    </UL>

  If the <VAR>others</VAR> item is selected,
  or if the <KBD>"<B>Control</B>"</KBD>-key is pressed simultaneously,
  another menu pops up, offering less frequently used functions:
<P>
<IMG SRC="../../../pictures/SystemBrowserMenuClassCategoryCTRL.gif" ALT="[class category ctrl-menu hardcopy] ">
<BR>Class category lists CTRL-menu
<P>


    <UL>
    <LI><A NAME="I_CLASSCATEGORY_MENU.FILEOUT_EACHBIN"  HREF="#CLASSCATEGORY_MENU.FILEOUT_EACHBIN">fileOut each binary</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.HISTORY"  HREF="#CLASSCATEGORY_MENU.HISTORY">repository history</A>
    <LI><A NAME="I_CLASSCATEGORY_MENU.CHECKIN_EACH"  HREF="#CLASSCATEGORY_MENU.CHECKIN_EACH">checkin each</A>
    </UL>

<DL>

<DT><A NAME="CLASSCATEGORY_MENU.FILEOUT" HREF="#I_CLASSCATEGORY_MENU.FILEOUT">fileOut</A>
<DD>save all classes in the currently selected
class category into one big source file.
The file will be named <CODE>"<VAR>categoryName</VAR>.st"</CODE>
and contain the code such that it can be
reloaded later or moved to another system
(see the FileBrowser's
<A HREF="../fbrowser/fileList.html#MENU.FILEIN"><VAR>fileIn</VAR></A>
function).
<BR>
The format in which the code is saved is compatible
to <EM>Smalltalk-80</EM>'s fileOut format.
<BR>
The file is created in the current project-directory (see
<A HREF="../misc/TOP.html#PROJECTS">projects</A> ).
<P>

<DT><A NAME="CLASSCATEGORY_MENU.FILEOUT_EACH" HREF="#I_CLASSCATEGORY_MENU.FILEOUT_EACH">fileOut each</A>
<DD>save all classes, but put each class into a
separate file, named <CODE>"<VAR>className</VAR>.st"</CODE>.
<BR>
Having classes in separate source files is required if the
classes are to be compiled later by <VAR>stc</VAR> (for machine code),
or for archival into some source repository.
<P>
The files are created in the current projects fileout directory - by default,
this is the current directory. (see <A HREF="../misc/TOP.html#PROJECTS">projects</A> )
<P>

<DT><A NAME="CLASSCATEGORY_MENU.PRINTOUT" HREF="#I_CLASSCATEGORY_MENU.PRINTOUT">printOut</A>
<DD>sends a printed representation of all classes
in the selected category to the printer.
The printout may become long and includes each methods source code.
<P>

<DT><A NAME="CLASSCATEGORY_MENU.PRINTOUT_PROT" HREF="#I_CLASSCATEGORY_MENU.PRINTOUT_PROT">printOut protocol</A>
<DD>sends a short protocol-only printed representation
of all classes in the selected category to the
printer. This printout will not include the methods
full source code - instead only the methods selector and the first comment
found in the method is printed.
<BR>
This format is very valuable for
documentation purposes
(if your methods were written with a short descriptive comment at the beginning).
<P>


<DT><A NAME="CLASSCATEGORY_MENU.CLONE" HREF="#I_CLASSCATEGORY_MENU.CLONE">clone</A>
<DD>opens a new browser, showing the same class/method as
currently selected. Quite useful for excursions.
<P>


<DT><A NAME="CLASSCATEGORY_MENU.OPENFOR" HREF="#I_CLASSCATEGORY_MENU.OPENFOR">open for class</A>
<DD>opens a new browser after asking for the class.
Quite useful for excursions.
<P>



<DT><A NAME="CLASSCATEGORY_MENU.SPAWN" HREF="#I_CLASSCATEGORY_MENU.SPAWN">spawn</A>
<DD>starts a class category browser on the currently
selected class category.
This is a browser without the class category list.
<BR>
In practice, this type of browser is seldom used.
<P>

<DT><A NAME="CLASSCATEGORY_MENU.SPAWN_FULL" HREF="#I_CLASSCATEGORY_MENU.SPAWN_FULL">spawn full class</A>
<DD>starts a full class browser.
A full class browser allows editing a classes complete
code in one view. This is very handy, if changes
to many methods are to be done - especially if those
changes depend on each other
(for example, to globally rename a methods selector or a variables name).
<P>

<DT><A NAME="CLASSCATEGORY_MENU.UPDATE" HREF="#I_CLASSCATEGORY_MENU.UPDATE">update</A>
<DD>will rescan all classes in the system and update the lists shown.
<BR>
Normally, the systemBrowser tries to keep track of changes done by
other parts of the system; however, there are situations, in which the browser
does not get notified of these changes and needs a manual update.
<P>

<DT><A NAME="CLASSCATEGORY_MENU.FIND_CLASS" HREF="#I_CLASSCATEGORY_MENU.FIND_CLASS">find class</A>
<DD>pops up a box to enter the name of a class.
This class will be searched for and shown in this browser.
The entered string may include wildcard characters.
<BR>
For example, it is possible to search for all classes
containing the substring <CODE>"Collection"</CODE> in their name by
entering <CODE>"*Collection*"</CODE>.
<BR>
The box performs classname completion (<KBD>"<B>Tab</B>"</KBD> key)
so you don't have to enter the full name.
<P>
No action is performed, if the entered class does not
exist.
<P>

<DT><A NAME="CLASSCATEGORY_MENU.FIND_METHOD" HREF="#I_CLASSCATEGORY_MENU.FIND_METHOD">find method</A>
<DD>pops up a box to enter the name of a selector.
The implementors of this message are searched for,
and, if only one found, the method is immediately displayed.
<BR>
If there are multiple implementors, a popup box allows
the class to be selected.
<BR>
Both the selector box and the class box
perform name completion (<KBD>"<B>Tab</B>"</KBD> key).
<BR>
No action is performed, if the entered selector is nowhere implemented.
<P>
This is a <STRONG>very</STRONG> useful function when you remember
a methods name or part of it. Basically, it performs a function similar
to the <VAR>implementors</VAR> function, but displays the method in the
current browser (instead of opening a new one).
<P>

<DT><A NAME="CLASSCATEGORY_MENU.NEW_CATEGORY" HREF="#I_CLASSCATEGORY_MENU.NEW_CATEGORY">new class category</A>
<DD>allows creation of a new class category.
<BR>
Notice, that the new category will become persistent only after a class has
been created with that category.
<P>

<DT><A NAME="CLASSCATEGORY_MENU.RENAME" HREF="#I_CLASSCATEGORY_MENU.RENAME">rename</A>
<DD>rename a category. This will change the class category
attribute of all classes in the currently selected
class category.
<P>

<DT><A NAME="CLASSCATEGORY_MENU.REMOVE" HREF="#I_CLASSCATEGORY_MENU.REMOVE">remove</A>
<DD>remove all classes (& subclasses) in the current class
category. You will be warned by a popup box which has
to be answered positively, for the deletion to be
actually performed.
</DL>
<P>

<h4>Control menu functions</h4>

<DL>
<DT><A NAME="CLASSCATEGORY_MENU.FILEOUT_EACHBIN" HREF="#I_CLASSCATEGORY_MENU.FILEOUT_EACHBIN">fileOut each binary</A>
<DD>like <I>fileOut each</I>, but saves the classes in binary format.
<BR>
This format is portable across machines, iff no primitive code is contained
OR the target system supports dynamic compilation to machine code.
<P>

<DT><A NAME="CLASSCATEGORY_MENU.HISTORY" HREF="#I_CLASSCATEGORY_MENU.HISTORY">repository history</A>
<DD>Display a history of changes made to the source code repository.
<BR>
You have to enter a starting date - all changes made since that date
will be listed.
<BR>
Of course, you have to have the sourceCodeManagement facility running for this
to work (which is only provided with the full commercial release).
<P>

<DT><A NAME="CLASSCATEGORY_MENU.CHECKIN_EACH" HREF="#I_CLASSCATEGORY_MENU.CHECKIN_EACH">checkin each</A>
<DD>Check every changed class in the current category back into the
source code repository. Unchanged classes do not affect the repository.
<BR>
Of course, you have to have the sourceCodeManagement facility running for this
to work (which is only provided with the full commercial release).
<P>



</DL>



<H3><A NAME="CLASS_MENU" HREF="TOP.html#I_CLASS_MENU">Class list popup menu functions</A></H3>

<IMG SRC="../../../pictures/SystemBrowserMenuClassList.gif" ALT="[class menu hardcopy] ">
<BR>Class lists menu
<P>

Most functions in the class lists popupmenu affect the currently selected class.
It provides the following operations:

    <UL>
    <LI><A NAME="I_CLASS_MENU.FILEOUT" HREF="#CLASS_MENU.FILEOUT">fileOut</A>
    <LI><A NAME="I_CLASS_MENU.PRINTOUT" HREF="#CLASS_MENU.PRINTOUT">printOut</A>
    <LI><A NAME="I_CLASS_MENU.PRINTOUT_PROT" HREF="#CLASS_MENU.PRINTOUT_PROT">printOut protocol</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.SPAWN" HREF="#CLASS_MENU.SPAWN">spawn</A>
    <LI><A NAME="I_CLASS_MENU.SPAWN_FULLPROTOCOL" HREF="#CLASS_MENU.SPAWN_FULLPROTOCOL">spawn full protocol</A>
    <LI><A NAME="I_CLASS_MENU.SPAWN_HIERARCHY" HREF="#CLASS_MENU.SPAWN_HIERARCHY">spawn hierarchy</A>
    <LI><A NAME="I_CLASS_MENU.SPAWN_SUBCLASSES" HREF="#CLASS_MENU.SPAWN_SUBCLASSES">spawn subclasses</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.HIERARCHY" HREF="#CLASS_MENU.HIERARCHY">hierarchy</A>
    <LI><A NAME="I_CLASS_MENU.DEFINITION" HREF="#CLASS_MENU.DEFINITION">definition</A>
    <LI><A NAME="I_CLASS_MENU.COMMENT" HREF="#CLASS_MENU.COMMENT">comment</A>
    <LI><A NAME="I_CLASS_MENU.CLASS_INSTVARS" HREF="#CLASS_MENU.CLASS_INSTVARS">class instvars</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.CLASS_REFS" HREF="#CLASS_MENU.CLASS_REFS">class refs</A>
    <LI><A NAME="I_CLASS_MENU.NEW_CLASS" HREF="#CLASS_MENU.NEW_CLASS">new class</A>
    <LI><A NAME="I_CLASS_MENU.NEW_SUBCLASS" HREF="#CLASS_MENU.NEW_SUBCLASS">new subclass</A>
    <LI><A NAME="I_CLASS_MENU.RENAME" HREF="#CLASS_MENU.RENAME">rename</A>
    <LI><A NAME="I_CLASS_MENU.REMOVE" HREF="#CLASS_MENU.REMOVE">remove</A>
    </UL>

  If the <VAR>others</VAR> item is selected,
  or if the <KBD>"<B>Control</B>"</KBD>-key is pressed simultaneously,
  another menu pops up, offering less frequently used functions.
<P>
<IMG SRC="../../../pictures/SystemBrowserMenuClassListCTRL.gif" ALT="[class ctrl-menu hardcopy] ">
<BR>Class lists CTRL-menu
<P>

    <UL>
    <LI><A NAME="I_CLASS_MENU.FILEOUTBIN" HREF="#CLASS_MENU.FILEOUTBIN">fileOut binary</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.INSPECTCLASS" HREF="#CLASS_MENU.INSPECTCLASS">inspect class</A>
    <LI><A NAME="I_CLASS_MENU.INSPECTINSTS" HREF="#CLASS_MENU.INSPECTINSTS">inspect instances</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.PRIMDEFS" HREF="#CLASS_MENU.PRIMDEFS">primitive definitions</A>
    <LI><A NAME="I_CLASS_MENU.PRIMVARS" HREF="#CLASS_MENU.PRIMVARS">primitive variables</A>
    <LI><A NAME="I_CLASS_MENU.PRIMFUNCS" HREF="#CLASS_MENU.PRIMFUNCS">primitive functions</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.CONTAINER" HREF="#CLASS_MENU.CONTAINER">source container</A>
    <LI><A NAME="I_CLASS_MENU.RMCONTAINER" HREF="#CLASS_MENU.RMCONTAINER">remove source container</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.REVLOG" HREF="#CLASS_MENU.REVLOG">revision log</A>
    <LI><A NAME="I_CLASS_MENU.COMPARE" HREF="#CLASS_MENU.COMPARE">compare with repository</A>
    <P>
    <LI><A NAME="I_CLASS_MENU.CHECKIN" HREF="#CLASS_MENU.CHECKIN">check into repository</A>
    <LI><A NAME="I_CLASS_MENU.FILEINREP" HREF="#CLASS_MENU.FILEINREP">fileIn from repository</A>
    </UL>



<DL>
<DT><A NAME="CLASS_MENU.FILEOUT" HREF="#I_CLASS_MENU.FILEOUT">fileOut</A>
<DD>save the currently selected classes source code
			  in a file named <CODE>"<VAR>className</VAR>.st"</CODE>.
			  The file is created in the current project directory.
<P>

<DT><A NAME="CLASS_MENU.PRINTOUT" HREF="#I_CLASS_MENU.PRINTOUT">printOut</A>
<DD>send the currently selected classes source code to the printer.
<P>

<DT><A NAME="CLASS_MENU.PRINTOUT_PROT" HREF="#I_CLASS_MENU.PRINTOUT_PROT">printOut protocol</A>
<DD>send the currently selected classes protocol
description to the printer. This output will contain
the class description, class comment and the classes
protocol. For each method, the selector and the methods description
is printed in a format that is very valuable for documentation purposes
(if your methods were written with
a short descriptive comment at the beginning).
<P>

<DT><A NAME="CLASS_MENU.SPAWN" HREF="#I_CLASS_MENU.SPAWN">spawn</A>
<DD>start a single class browser on the currently selected
class (try and see)
If the codeview has a valid className highlighted
(i.e. selected), a browser is spawned on that class.
<P>

<DT><A NAME="CLASS_MENU.SPAWN_FULLPROTOCOL" HREF="#I_CLASS_MENU.SPAWN_FULLPROTOCOL">spawn full protocol</A>
<DD>start a full protocol browser on the currently selected
class. A full protocol browser shows all messages understood by a class (try and see).
If the codeview has a valid className selected,
a hierarchy browser is spawned on that class.
<P>

<DT><A NAME="CLASS_MENU.SPAWN_HIERARCHY" HREF="#I_CLASS_MENU.SPAWN_HIERARCHY">spawn hierarchy</A>
<DD>start a hierarchy browser on the currently selected
class, all of its superclasses and all subclasses.
If the codeview has a valid className selected,
a hierarchy browser is spawned on that class.
<P>

<DT><A NAME="CLASS_MENU.SPAWN_SUBCLASSES" HREF="#I_CLASS_MENU.SPAWN_SUBCLASSES">spawn subclasses</A>
<DD>start a browser on all subclasses of the currently
selected class.
(this includes subclasses of subclasses etc).
If the codeview has a valid className highlighted,
a subclass browser is spawned on that class.
<P>

<DT><A NAME="CLASS_MENU.HIERARCHY" HREF="#I_CLASS_MENU.HIERARCHY">hierarchy</A>
<DD>show the hierarchy of the currently selected class in
the code view. If the class-toggle is pressed, the
metaclass hierarchy is shown.
<P>

<DT><A NAME="CLASS_MENU.DEFINITION" HREF="#I_CLASS_MENU.DEFINITION">definition</A>
<DD>shows the classes definition in the codeview.
Editing the definition and <VAR>accepting</VAR> in the code view
allows changing the classes definition (i.e. inheritance, instance variables
and category).
<P>

<DT><A NAME="CLASS_MENU.COMMENT" HREF="#I_CLASS_MENU.COMMENT">comment</A>
<DD>shows the class comment in the code view.
Editing the comment and <VAR>accepting</VAR> allows changing the classes comment.
<P>

<DT><A NAME="CLASS_MENU.CLASS_INSTVARS" HREF="#I_CLASS_MENU.CLASS_INSTVARS">class instvars</A>
<DD>shows the classes class-instance-variables in the code
			  view.
			  Editing and <VAR>accepting</VAR> in the code view allows
			  changing the classes instance variables.
<BR>
			  <STRONG>Do not confuse class-instance-variables with class-variables</STRONG> -
see the Smalltalk language documentation for this.
<P>

<DT><A NAME="CLASS_MENU.CLASS_REFS" HREF="#I_CLASS_MENU.CLASS_REFS">class refs</A>
<DD>searches for uses of the selected class, and
			  opens a browser on all referencing methods.
			  This is the same as the <CODE>globals</CODE> function in
			  the method-menu; it has been added for the convenience
			  of <CITE>ST-80</CITE> users.
<P>

<DT><A NAME="CLASS_MENU.VARIABLE_SEARCH" HREF="#I_CLASS_MENU.VARIABLE_SEARCH">variable search</A>
<DD>this entry provides access to a submenu offering
			  searches for different variable references.
			  After the search, another browser showing all methods
			  referencing the variable of interest.
			  The search can be for any reference or modifying references.
			  You may either search locally (in the selected class only)
or over the whole tree of subclasses.
			  You may use wildcards when searching.
<P>
			  Notice, that this search may take some time, the system
			  has to parse the source of all involved methods to find
			  these accesses.
			  If no method is found referencing the variable, the
			  <A HREF="../misc/TOP.html#TRANSCRIPT">Transcript</A>
 will show a short message (<SAMP>"none found"</SAMP>).
<P>
Starting with release 2.10.4 this menu function is now found in
the new <CITE>``variable list''</CITE> subview.
<P>

<DT><A NAME="CLASS_MENU.NEW_CLASS" HREF="#I_CLASS_MENU.NEW_CLASS">new class</A>
<DD>shows a new class definition prototype in the code view.
			  You should edit this template, by changing the classes
			  name and filling in the instanceVariables and/or classVariable names.
			  <VAR>accepting</VAR> in the code view will actually create the
			  new class.
<P>

<DT><A NAME="CLASS_MENU.NEW_SUBCLASS" HREF="#I_CLASS_MENU.NEW_SUBCLASS">new subclass</A>
<DD>same as new class, but the offered class definition
			  will be for a subclass of the currently selected class.
<P>

<DT><A NAME="CLASS_MENU.RENAME" HREF="#I_CLASS_MENU.RENAME">rename</A>
<DD>change the name of the currently selected class.
			  Since this class may be referenced by other code in the
			  system, all references to that class are searched for
			  and shown in another browser - you should then decide
			  if those references should be changed or not
			  (edit those references and <VAR>accept</VAR> in this new
			   browsers code view).
<P>

<DT><A NAME="CLASS_MENU.REMOVE" HREF="#I_CLASS_MENU.REMOVE">remove</A>
<DD>will remove the currently selected class and all of its
			  subclasses. You will get a chance to cancel, if
			  you changed your mind.
</DL>



<h4>Control menu functions</h4>

<DL>
<DT><A NAME="CLASS_MENU.FILEOUTBIN" HREF="#I_CLASS_MENU.FILEOUTBIN">fileOut binary</A>
<DD>like <I>fileOut</I>, but saves the class in binary format.
<BR>
This format is portable across machines, iff no primitive code is contained
in any method.
<BR>
If there is primitive code in any method,
the target system must support dynamic compilation to machine code
in order to be able to load that binary.
<P>

<DT><A NAME="CLASS_MENU.INSPECTCLASS" HREF="#I_CLASS_MENU.INSPECTCLASS">inspect class</A>
<DD>Launch an inspector in the class object (to look at class instance variables)
<BR>
This can be also done by typing in the name of the class and inspecting it;
however, most of us are lazy ...
<P>

<DT><A NAME="CLASS_MENU.INSPECTINSTS" HREF="#I_CLASS_MENU.INSPECTINSTS">inspect instances</A>
<DD>Launch an inspector in the collection if all instances.
<BR>
Sometimes useful when debugging ...
<P>

<DT><A NAME="CLASS_MENU.PRIMDEFS" HREF="#I_CLASS_MENU.PRIMDEFS">primitive definitions</A>
<DD>Display the classes primitive definitions section (if it has any).
<P>

<DT><A NAME="CLASS_MENU.PRIMVARS" HREF="#I_CLASS_MENU.PRIMVARS">primitive variables</A>
<DD>Display the classes primitive variables section (if it has any).
<P>

<DT><A NAME="CLASS_MENU.PRIMFUNCS" HREF="#I_CLASS_MENU.PRIMFUNCS">primitive functions</A>
<DD>Display the classes primitive functions section (if it has any).
<P>

<DT><A NAME="CLASS_MENU.CONTAINER" HREF="#I_CLASS_MENU.CONTAINER">source container</A>
<DD>Display and allow changing the classes source container in the repository.
<BR>
You have to have the sourceCodeManagement facility running for this
to work.
<P>

<DT><A NAME="CLASS_MENU.RMCONTAINER" HREF="#I_CLASS_MENU.RMCONTAINER">remove source container</A>
<DD>Removes a classes source container from the repository.
<BR>
You have to have the sourceCodeManagement facility running for this
to work.
<P>

<DT><A NAME="CLASS_MENU.REVLOG" HREF="#I_CLASS_MENU.REVLOG">revision log</A>
<DD>Display the classes revision log in the repository.
<BR>
You have to have the sourceCodeManagement facility running for this
to work.
<P>

<DT><A NAME="CLASS_MENU.COMPARE" HREF="#I_CLASS_MENU.COMPARE">compare with repository</A>
<DD>Compare the class with any revision log in the source code repository.
<BR>
You have to have the sourceCodeManagement facility running for this
to work.
<P>

<DT><A NAME="CLASS_MENU.CHECKIN" HREF="#I_CLASS_MENU.CHECKIN">check into repository</A>
<DD>Update the repository by checking in the class into the repository.
<BR>
You have to have the sourceCodeManagement facility running for this
to work.
<P>

<DT><A NAME="CLASS_MENU.FILEINREP" HREF="#I_CLASS_MENU.FILEINREP">fileIn from repository</A>
<DD>Load any version from the repository. A Dialog asks for the version to load.
<BR>
You have to have the sourceCodeManagement facility running for this
to work.
<P>
</DL>


<H3><A NAME="METHODCATEGORY_MENU" HREF="TOP.html#I_METHODCATEGORY_MENU">Method category list popup menu functions</A></H3>

<IMG SRC="../../../pictures/SystemBrowserMenuMethodCategory.gif" ALT="[methodcategory menu hardcopy] ">
<BR>Method category list menu
<P>

The method category list provides the following menu functions:

    <UL>
    <LI><A NAME="I_METHODCATEGORY_MENU.FILEOUT" HREF="#METHODCATEGORY_MENU.FILEOUT">fileOut</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.FILEOUT_ALL" HREF="#METHODCATEGORY_MENU.FILEOUT_ALL">fileOut all</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.PRINTOUT" HREF="#METHODCATEGORY_MENU.PRINTOUT">printOut</A>
    <P>
    <LI><A NAME="I_METHODCATEGORY_MENU.SPAWN" HREF="#METHODCATEGORY_MENU.SPAWN">spawn</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.SPAWN_CATEGORY" HREF="#METHODCATEGORY_MENU.SPAWN_CATEGORY">spawn category</A>
    <P>
    <LI><A NAME="I_METHODCATEGORY_MENU.FIND_HERE" HREF="#METHODCATEGORY_MENU.FIND_HERE">find method here</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.FIND" HREF="#METHODCATEGORY_MENU.FIND">find method</A>
    <P>
    <LI><A NAME="I_METHODCATEGORY_MENU.NEW_CATEGORY" HREF="#METHODCATEGORY_MENU.NEW_CATEGORY">new category</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.COPY_CATEGORY" HREF="#METHODCATEGORY_MENU.COPY_CATEGORY">copy category</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.CREATE_ACCESS" HREF="#METHODCATEGORY_MENU.CREATE_ACCESS">create access methods</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.CREATE_DOC" HREF="#METHODCATEGORY_MENU.CREATE_DOC">create documentation stubs</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.RENAME" HREF="#METHODCATEGORY_MENU.RENAME">rename</A>
    <LI><A NAME="I_METHODCATEGORY_MENU.REMOVE" HREF="#METHODCATEGORY_MENU.REMOVE">remove</A>
    </UL>

<DL>
<DT><A NAME="METHODCATEGORY_MENU.FILEOUT" HREF="#I_METHODCATEGORY_MENU.FILEOUT">fileOut</A>
<DD>save the currently selected method categorys source
code in a file named <CODE>"<VAR>className-category</VAR>.st"</CODE>.
The file is created in the current project directory.
Not very useful - except to transfer parts of a class
to others.
<P>

<DT><A NAME="METHODCATEGORY_MENU.FILEOUT_ALL" HREF="#I_METHODCATEGORY_MENU.FILEOUT_ALL">fileOut all</A>
<DD>save all methods (from all classes) which have the same category as the
currently selected method category in a file named
<CODE>"<VAR>category</VAR>.st"</CODE>.
The file is created in the current project directory.
<BR>
If you use unique method categories for individual projects,
this allows easy fileOut of all methods belonging to that project.
<P>

<DT><A NAME="METHODCATEGORY_MENU.PRINTOUT" HREF="#I_METHODCATEGORY_MENU.PRINTOUT">printOut</A>
<DD>print all methods of the currently selected category.
<P>

<DT><A NAME="METHODCATEGORY_MENU.SPAWN" HREF="#I_METHODCATEGORY_MENU.SPAWN">spawn</A>
<DD>start a method category browser on all methods in the selected category (try and see).
<P>

<DT><A NAME="METHODCATEGORY_MENU.SPAWN_CATEGORY" HREF="#I_METHODCATEGORY_MENU.SPAWN_CATEGORY">spawn category</A>
<DD>start a browser on all methods (i.e. of all classes)
which have the same method category as the currently
selected one (try and see).
<P>

<DT><A NAME="METHODCATEGORY_MENU.FIND_HERE" HREF="#I_METHODCATEGORY_MENU.FIND_HERE">find method here</A>
<DD>allows searching for the method implementing a selector.
The selector has to be entered into a box - wildcards
are allowed.
No action is performed, if there is no method
implementing that selector.
<P>

<DT><A NAME="METHODCATEGORY_MENU.FIND" HREF="#I_METHODCATEGORY_MENU.FIND">find method</A>
<DD>same, but searches up in the class hierarchy for the
first class implementing the selector. This answers the
question <EM>"when I send #foo to instances of this class,
which method gets evaluated ?"</EM>
No action is performed, if there is no method
implementing that selector.
<P>

<DT><A NAME="METHODCATEGORY_MENU.NEW_CATEGORY" HREF="#I_METHODCATEGORY_MENU.NEW_CATEGORY">new category</A>
<DD>addes a new category to the list. For this new category
			  to become persistent, at least one method must exist
			  with this category attribute.
<P>

<DT><A NAME="METHODCATEGORY_MENU.COPY_CATEGORY" HREF="#I_METHODCATEGORY_MENU.COPY_CATEGORY">copy category</A>
<DD>allows copying all methods within another classes category to
the currently selected class. You can specify wildcards
in the category name.
For example, entering <CODE>"*"</CODE> as category, will copy all methods from
the other class. This function is very useful if you want to clone a class
(for example, to experiment with a modified system class).
<P>

<DT><A NAME="METHODCATEGORY_MENU.CREATE_ACCESS" HREF="#I_METHODCATEGORY_MENU.CREATE_ACCESS">create access methods</A>
<DD>creates methods to access instance variables. This menu item is only shown when a classes
instance protocol is visible (turn on the <VAR>``instance''</VAR> toggle).
			  For each instance variable <VAR>foo</VAR>, two methods are created:
<BLOCKQUOTE>
				<CODE>#foo</CODE>    - which returns this instance variable
</BLOCKQUOTE>
			  and:
<BLOCKQUOTE>
				<CODE>#foo:</CODE>   - which sets this instance variable
</BLOCKQUOTE>
			  This function is non-destructive: if a method by that
			  name already exists, it is not overwritten or changed.
<P>

<DT><A NAME="METHODCATEGORY_MENU.CREATE_DOC" HREF="#I_METHODCATEGORY_MENU.CREATE_DOC">create documentation stubs</A>
<DD>creates empty documentation methods in the classes documentation protocol.
This menu item is only shown when a classes
class protocol is visible (turn on the <VAR>``class''</VAR> toggle).
<BR>
We highly recommend you to always add documentation methods
- you yourself and others will appreciate that later ;-)
<P>

<DT><A NAME="METHODCATEGORY_MENU.RENAME" HREF="#I_METHODCATEGORY_MENU.RENAME">rename</A>
<DD>rename the method category
<P>

<DT><A NAME="METHODCATEGORY_MENU.REMOVE" HREF="#I_METHODCATEGORY_MENU.REMOVE">remove</A>
<DD>remove all methods (in the currently selected class only)
which are members of the selected method category.
<BR>
You will be asked to confirm before the remove is actually performed.
</DL>
<P>





<H3><A NAME="METHOD_MENU" HREF="TOP.html#I_METHOD_MENU">Method list popup menu functions</A></H3>

<IMG SRC="../../../pictures/SystemBrowserMenuMethod.gif" ALT="[method menu hardcopy] ">
<BR>Method lists menu
<P>

  The method list offers the following menu functions:
    <UL>
    <LI><A NAME="I_METHOD_MENU.FILEOUT" HREF="#METHOD_MENU.FILEOUT">fileOut</A>
    <LI><A NAME="I_METHOD_MENU.PRINTOUT" HREF="#METHOD_MENU.PRINTOUT">printOut</A>
    <P>
    <LI><A NAME="I_METHOD_MENU.SPAWN" HREF="#METHOD_MENU.SPAWN">spawn</A>
    <P>
    <LI><A NAME="I_METHOD_MENU.SENDERS" HREF="#METHOD_MENU.SENDERS">find senders</A>
    <LI><A NAME="I_METHOD_MENU.IMPLEMENTORS" HREF="#METHOD_MENU.IMPLEMENTORS">find implementors</A>
    <LI><A NAME="I_METHOD_MENU.GLOBALS" HREF="#METHOD_MENU.GLOBALS">find global references</A>
    <LI><A NAME="I_METHOD_MENU.STRINGSEARCH" HREF="#METHOD_MENU.STRINGSEARCH">find a string</A>
    <LI><A NAME="I_METHOD_MENU.APROPOS" HREF="#METHOD_MENU.APROPOS">find apropos keyword</A>
    <P>
    <LI><A NAME="I_METHOD_MENU.NEW_METHOD" HREF="#METHOD_MENU.NEW_METHOD">new method</A>
    <LI><A NAME="I_METHOD_MENU.CHANGE_CATEGORY" HREF="#METHOD_MENU.CHANGE_CATEGORY">change category</A>
    <LI><A NAME="I_METHOD_MENU.MOVE" HREF="#METHOD_MENU.MOVE">move</A>
    <LI><A NAME="I_METHOD_MENU.REMOVE" HREF="#METHOD_MENU.REMOVE">remove</A>
    </UL>

If the <VAR>others</VAR> item is selected,
  or if the <KBD>"<B>Control</B>"</KBD>-key is pressed simultaneously,
  another menu pops up, offering less frequently used functions.
<P>
<IMG SRC="../../../pictures/SystemBrowserMenuMethodCTRL.gif" ALT="[method ctrl-menu hardcopy] ">
<BR>Method lists CTRL-menu
<P>

    <UL>
    <LI><A NAME="I_METHOD_MENU.INSPECT" HREF="#METHOD_MENU.INSPECT">inspect method</A>
    <LI><A NAME="I_METHOD_MENU.COMPILE" HREF="#METHOD_MENU.COMPILE">compile to machine code</A>
    <LI><A NAME="I_METHOD_MENU.DECOMPILE" HREF="#METHOD_MENU.DECOMPILE">decompile</A>
    <P>
    <LI><A NAME="I_METHOD_MENU.PUBLIC" HREF="#METHOD_MENU.PUBLIC">make public</A>
    <LI><A NAME="I_METHOD_MENU.PRIVATE" HREF="#METHOD_MENU.PRIVATE">make private</A>
    <LI><A NAME="I_METHOD_MENU.PROTECTED" HREF="#METHOD_MENU.PROTECTED">make protected</A>
    <LI><A NAME="I_METHOD_MENU.IGNORED" HREF="#METHOD_MENU.IGNORED">make ignored</A>
    <P>
    <LI><A NAME="I_METHOD_MENU.BREAKPOINT" HREF="#METHOD_MENU.BREAKPOINT">breakpoint</A>
    <LI><A NAME="I_METHOD_MENU.BREAKPOINTIN" HREF="#METHOD_MENU.BREAKPOINTIN">breakpoint in ...</A>
    <P>
    <LI><A NAME="I_METHOD_MENU.TRACE" HREF="#METHOD_MENU.TRACE">trace</A>
    <LI><A NAME="I_METHOD_MENU.TRACE_SENDER" HREF="#METHOD_MENU.TRACE_SENDER">trace sender</A>
    <LI><A NAME="I_METHOD_MENU.TRACE_FULL" HREF="#METHOD_MENU.TRACE_FULL">trace full walkback</A>
    <P>
    <LI><A NAME="I_METHOD_MENU.UNBREAK" HREF="#METHOD_MENU.UNBREAK">remove break/trace</A>
    <LI><A NAME="I_METHOD_MENU.TIMING" HREF="#METHOD_MENU.TIMING">start/stop timing</A>
    <LI><A NAME="I_METHOD_MENU.COUNTING" HREF="#METHOD_MENU.COUNTING">start/stop counting</A>
    <LI><A NAME="I_METHOD_MENU.MEMUSAGE" HREF="#METHOD_MENU.MEMUSAGE">start/stop memory usage statistics</A>
    </UL>


<DL>
<DT><A NAME="METHOD_MENU.FILEOUT" HREF="#I_METHOD_MENU.FILEOUT">fileOut</A>
<DD>save the currently selected method in a file named
			  <CODE>"<VAR>className-selector</VAR>.st"</CODE>.
			  The file is created in the current project directory.
			  Not very useful - except to transfer individual methods
			  to others.
<P>

<DT><A NAME="METHOD_MENU.PRINTOUT" HREF="#I_METHOD_MENU.PRINTOUT">printout</A>
<DD>send a printed representation of the currently selected
			  method to the printer.
<P>

<DT><A NAME="METHOD_MENU.SPAWN" HREF="#I_METHOD_MENU.SPAWN">spawn</A>
<DD>start a browser for editing the selected method.
<BR>
This is seldom used;
however, if a string of the form <CODE>"<VAR>classname</VAR> &#187; <VAR>selector</VAR>"</CODE>
is currently selected in the codeview,
a browser is opened on that method instead.
<BR>
Many method comments contain this kind of cross-reference in a comment
to allow quick excursions to related parts of the system.
<P>

<DT><A NAME="METHOD_MENU.SENDERS" HREF="#I_METHOD_MENU.SENDERS">senders</A>
<DD>starts a new browser on all methods sending a specific
 message. The message selector must be entered in a box;
 however, the box offers a reasonable default,
 which is the current methods selector or the selection in the code view.
 If the code views selection consists of a code fragment, the browser tries to extract
 the selector (try & see).
<BR>
 You may also enter a string containing a search pattern.
<BR>(Try it with the pattern: "<CODE>*[pP]ut*</CODE>".)
<P>
This is highly useful, if you only remember a part of a selector.

<P>
<DT><A NAME="METHOD_MENU.IMPLEMENTORS" HREF="#I_METHOD_MENU.IMPLEMENTORS">implementors</A>
<DD>starts a new browser on all methods implementing a
specific message.
<BR>
The same selection and search mechanism as in <VAR>"senders"</VAR> is used.
<P>

<DT><A NAME="METHOD_MENU.GLOBALS" HREF="#I_METHOD_MENU.GLOBALS">globals</A>
<DD>starts a new browser on all methods accessing a global
<BR>
The same selection and search mechanism as in <VAR>"senders"</VAR> is used.
<P>

<DT><A NAME="METHOD_MENU.STRINGSEARCH" HREF="#I_METHOD_MENU.STRINGSEARCH">string search</A>
<DD>starts a new browser on all methods where some sub-string is found in the source.
<BR>
Since all methods sourcecode has to be processed, this may take a while, if the number of
consulted classes is big.
<P>

<DT><A NAME="METHOD_MENU.APROPOS" HREF="#I_METHOD_MENU.APROPOS">apropos</A>
<DD>starts a new browser on all methods where some keyword is found in the selector or comment.
<BR>
Since all methods sourcecode has to be processed, this may take a while, if the number of
consulted classes is big..
<P>



<DT><A NAME="METHOD_MENU.NEW_METHOD" HREF="#I_METHOD_MENU.NEW_METHOD">new method</A>
<DD>shows a method template in the code view.
You should edit this template and <VAR>accept</VAR> in the code view.
<BR>
Actually, this template is simply a reminder on method syntax.
To create a method,
it is sufficient to <VAR>accept</VAR> in the code view with any method category
selected. (i.e. just edit and <VAR>accept</VAR>)
<P>
Typically new methods are created by copying some existing
code into an empty codeview,
then the selector and code are modified as needed,
and finally <VAR>accepted</VAR>.
<P>

<DT><A NAME="METHOD_MENU.CHANGE_CATEGORY" HREF="#I_METHOD_MENU.CHANGE_CATEGORY">change category</A>
<DD>allows putting the currently selected method into another category
(i.e. change the category of the selected method)
<P>


<DT><A NAME="METHOD_MENU.REMOVE" HREF="#I_METHOD_MENU.REMOVE">remove</A>
<DD>removes the currently selected method. No confirmations are asked for.
<P>

<DT><A NAME="METHOD_MENU.MOVE" HREF="#I_METHOD_MENU.MOVE">move</A>
<DD>moves the currently selected method to some other class. The class is to be entered
into an entryBox. For example, this is useful, to move some method to a superclass.

</DL>

<h4>Control menu functions</h4>

<DL>

<DT><A NAME="METHOD_MENU.INSPECT" HREF="#I_METHOD_MENU.INSPECT">inspect method</A>
<DD>Launch an inspector on the selected method.
<BR>
This is probably only useful for ST/X developers to debug internals.
<P>

<DT><A NAME="METHOD_MENU.COMPILE" HREF="#I_METHOD_MENU.COMPILE">compile to machine code</A>
<DD>Call the <VAR>stc</VAR> compiler to generate an optimized machine code
version of this method. Notice, that this is NOT related to just-in-time compilation,
which is done automatically. Instead, this calls for the <VAR>stc</VAR> compiler,
to generate a machine code file and loads the resulting module into the system.
<BR>
<VAR>Stc</VAR> generated code typically runs faster than just-in-time compiled
or interpreted code.
<BR>
This menu function is only available on systems which allow for machine code
to be dynamically loaded (and non-demo versions, where the <VAR>stc</VAR> compiler
is part of the delivery).
<P>


<DT><A NAME="METHOD_MENU.DECOMPILE" HREF="#I_METHOD_MENU.DECOMPILE">decompile</A>
<DD>Show the bytecode of the method as a symbolic ``disassembly''.
<BR>
This is probably only useful for ST/X developers to debug internals.
<P>



<DT><A NAME="METHOD_MENU.PUBLIC" HREF="#I_METHOD_MENU.PUBLIC">make public</A>
<DD>allow everyone to invoke this method (public access).
<P>


<DT><A NAME="METHOD_MENU.PRIVATE" HREF="#I_METHOD_MENU.PRIVATE">make private</A>
<DD>allow this method to only be invoked by methods from within that class(private access).
<BR>
If invoked by others, an exception will be raised at runtime.
<BR>
This is useful during development, to make certain that private methods
are not invoked by other team members.
<BR>
Be aware, that private methods limit the reusability of code - therefore, this is
a very soft atribute, which is easily changed to public.
<BR>
However, you must do that actively - being reminded of what you do.
<P>

<DT><A NAME="METHOD_MENU.PROTECTED" HREF="#I_METHOD_MENU.PROTECTED">make protected</A>
<DD>allow this method to only be invoked by methods from within that class and subclasses (protected access).
<BR>
Like above, if invoked by others, an exception will be raised at runtime.
<P>

<DT><A NAME="METHOD_MENU.IGNORE" HREF="#I_METHOD_MENU.IGNORE">make ignored</A>
<DD>ignore this method with respect to message lookup - i.e. the system behaves
as if this method was removed. A send of the corresponding selector will lead
to a doesNotUnderstand exception (or a superclasses method to be invoked).
<BR>
Useful to temporarily disable a method, or to remove a method but keep its
code as documentation.
<P>


<DT><A NAME="METHOD_MENU.BREAKPOINT" HREF="#I_METHOD_MENU.BREAKPOINT">breakpoint</A>
<DD>sets a breakpoint on the selected method.
<BR>
The debugger will be entered, whenever a breakpointed method is about to be executed.
A single step or continue will then actually start execution of the method.
<P>

<DT><A NAME="METHOD_MENU.BREAKPOINTIN" HREF="#I_METHOD_MENU.BREAKPOINTIN">breakpoint in ...</A>
<DD>sets a breakpoint on the selected method, which is only triggered, if that
method is invoked by a particular process. A popup box opens up to allow for the
process to be selected.
<BR>
Use this, if you want a breakpoint to be placed upon a method which is also
used by the system or other processes, and others should not be affected by
breakpoints. For example, if some View method is to be breakpointed.
<P>


<DT><A NAME="METHOD_MENU.TRACE" HREF="#I_METHOD_MENU.TRACE">trace</A>
<DD>turns on tracing of the selected method.
<BR>
Traced methods will output some information on the standard-error
(Stderr) both on entry and exit.
To trace into a file, Stderr can be set to some fileStream opened for writing.
<P>

<DT><A NAME="METHOD_MENU.TRACE_SENDER" HREF="#I_METHOD_MENU.TRACE_SENDER">trace sender</A>
<DD>turns on sender-tracing of the selected method.
<BR>
Like trace,
but only a short note identifying the sender of
the method will be written to Stderr.
<P>

<DT><A NAME="METHOD_MENU.TRACE_FULL" HREF="#I_METHOD_MENU.TRACE_FULL">trace full walkback</A>
<DD>Like trace, but dumps a full walkback to Stderr.
<P>



<DT><A NAME="METHOD_MENU.UNBREAK" HREF="#I_METHOD_MENU.UNBREAK">remove break/trace</A>
<DD>remove breakpointing or tracing of the selected method.
<BR>
Any trace- or breakpoint is also removed,
whenever the current method is recompiled (i.e. <VAR>accepted</VAR>).
<P>

<DT><A NAME="METHOD_MENU.TIMING" HREF="#I_METHOD_MENU.TIMING">start/stop timing</A>
<DD>install/deinstall a statistic wrapper, which monitors the execution
time of the method.
<BR>
The min/max and average times are shown in the browser - but that display is only
updated, if you click on the item again (to avoid flicker ...).
<P>


<DT><A NAME="METHOD_MENU.COUNTING" HREF="#I_METHOD_MENU.COUNTING">start/stop counting</A>
<DD>install/deinstall a counter to be incremented whenever the method is invoked.
<BR>
The current count is shown in the browser - but that display is only
updated, if you click on the item again (to avoid flicker ...).
<P>


<DT><A NAME="METHOD_MENU.MEMUSAGE" HREF="#I_METHOD_MENU.MEMUSAGE">start/stop memory usage statistics</A>
<DD>install/deinstall a memory usage statistic on the selected method
<BR>
The amount of memory allocated by the method and all methods called by it
will be displayed in the browser. No automatic update is performed - click on the
methods item again, to get an update.
<P>

</DL>

<HR>
Doc $Revision: 1.20 $ $Date: 2016-11-05 17:38:36 $

</BODY>
</HTML>
