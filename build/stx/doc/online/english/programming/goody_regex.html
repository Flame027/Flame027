<HTML>

<HEAD>
<TITLE>Smalltalk/X Programmers guide - Regular Expression Parser/Matcher</Title>
</HEAD>

<BODY>

<A NOPRINT HREF="goody_rdoit.html">     <IMG SRC="../../icons/DocsLeftArrow.gif" ALT="[prev]"></A>
<A NOPRINT HREF="TOP.html">   <IMG SRC="../../icons/DocsUpArrow.gif" ALT="[up]"></A>
<A NOPRINT HREF="goody_stxInExtWin.html">   <IMG SRC="../../icons/DocsRightArrow.gif" ALT="[next]"></A>

<H1>Regular Expression Parser/Matcher</H1>

<H2>Overview</H2>

These classes implement a parser/matcher for regular expressions.

<P>


<H2>Documentation</H2>

The following text is an html- transcription of the text found in
the class methods in "documentation-manual" of the <code>Regex::RxParser</code> class.
In addition, if you need further info: "<I>use the source - Luke</I>".
<p>


<p>These pages will not teach you regular expression usage nor the Smalltalk language.
<br>
  For regular expressions, the following excellent book is recommended:</p>
<ul>
  <li><a href="http://www.oreilly.com/catalog/regex/">Mastering Regular Expressions</a>
    by Jeffrey E.F. Friedl, O'Reilly (http://www.oreilly.com/catalog/regex).<br>
  </li>
</ul>
  For smalltalk literature, please refer to the <a href="../reading.html">"Reading List"</a>.


<H3>Introduction</H3>

A regular expression is a template specifying a class of strings.
A regular expression matcher is an tool that determines whether a string
belongs to a class specified by a regular expression.
This is a common task of a user input validation code, and the use of regular
expressions can GREATLY simplify and speed up development of such code.
<br>
As an example, here is how to verify that a string is a valid
hexadecimal number in Smalltalk notation, using this matcher package:
<code><pre>
	aString matchesRegex: '16r[[:xdigit:]]+'
</pre></code>
(Coding the same ``the hard way'' is an exercise to a curious reader).
<p>
This matcher is offered to the Smalltalk community in hope it will be useful.
It is free in terms of money, and to a large extent -- in terms of rights of use.
Refer to `Boring Stuff' section for legalese.
<UL>
<li>The <a href="#WHATSNEW" name="I_WHATSNEW">'What's new in this release'</a> section describes the functionality introduced in 1.1 release.
<p>
<li>The <a href="#SYNTAX" name="I_SYNTAX">`Syntax'</a> section explains the recognized syntax of regular expressions.
<p>
<li>The <a href="#USAGE" name="I_USAGE">`Usage'</a> section explains matcher capabilities that go beyond what <code>String &#187; matchesRegex:</code> method offers.
<p>
<li>The <a href="#IMPLEMENTATION" name="I_IMPLEMENTATION">`Implementation notes'</a> sections says a few words about what is under the hood.
</ul>
<p>
Happy hacking,
<br>
Vassili Bykov
&lt;vassili@objectpeople.com>
&lt;vassili@magma.ca>
<p>
August 6, 1996  (first release)
<br>
April 4, 1999 (rel1.1)



<H3><a name="WHATSNEW" href="#I_WHATSNEW">Whats new in Version1.1 (Oct 1999)</a></H3>

Regular expression syntax corrections and enhancements:
<ol>
<li>Backslash escapes similar to those in Perl are allowed in patterns:
<br>
 <dl>
  <dt><code>\w</code>
	<dd>any word constituent character (equivalent to <code>[a-zA-Z0-9_]</code>)

  <dt><code>\W</code>
	<dd>any character but a word constituent (equivalent to <code>[^a-xA-Z0-9_]</code>)
  <dt><code>\d</code>
	<dd>a digit (same as <code>[0-9]</code>)
  <dt><code>\D</code>
	<dd>anything but a digit
  <dt><code>\s</code>
	<dd>a whitespace character
  <dt><code>\S</code>
	<dd>anything but a whitespace character
  <dt><code>\b</code>
	<dd>an empty string at a word boundary
  <dt><code>\B</code>
	<dd>an empty string not at a word boundary
  <dt><code>\&lt;</code>
	<dd>an empty string at the beginning of a word
  <dt><code>\></code>
	<dd>an empty string at the end of a word
 </dl>
  For example, <code>'\w+'</code> is now a valid expression matching any word.
<p>

<li>The following backslash escapes are also allowed in character sets
  (between square brackets):
<p>
<pre>
    <code>\w</code>, <code>\W</code>, <code>\d</code>, <code>\D</code>, <code>\s</code>, and <code>\S</code>.
</pre>
<p>

<li>The following grep(1)-compatible named character classes are
  recognized in character sets as well:
<p>
<code><pre>
    [:alnum:]
    [:alpha:]
    [:blank:]
    [:cntrl:]
    [:digit:]
    [:graph:]
    [:lower:]
    [:print:]
    [:punct:]
    [:space:]
    [:upper:]
    [:xdigit:]
</pre></code>
<p>
  For example, the following patterns are equivalent:
<p>
<code><pre>
    '[[:alnum:]]+'
    '\w+'
    '[\w]+'
    '[a-zA-Z0-9_]+'
</pre></code>
<p>
<li>Some non-printable characters can be represented in regular
  expressions using a common backslash notation:
<p>
<code><pre>
    \t      tab (Character tab)
    \n      newline (Character lf)
    \r      carriage return (Character cr)
    \f      form feed (Character newPage)
    \e      escape (Character esc)
</pre></code>
<p>
<li>A dot is correctly interpreted as 'any character but a newline'
  instead of 'anything but whitespace'.
<p>

<li>Case-insensitive matching.  The easiest access to it are new
  messages CharacterArray understands:
<code><pre>
    #asRegexIgnoringCase
    #matchesRegexIgnoringCase:
    #prefixMatchesRegexIgnoringCase:
</pre></code>
<p>

<li>The matcher (an instance of RxMatcher, the result of
  String &#187; asRegex) now provides a collection-like interface to matches
  in a particular string or on a particular stream, as well as
  substitution protocol. The interface includes the following messages:
<p>
<code><pre>
    matchesIn: aString
    matchesIn: aString collect: aBlock
    matchesIn: aString do: aBlock

    matchesOnStream: aStream
    matchesOnStream: aStream collect: aBlock
    matchesOnStream: aStream do: aBlock

    copy: aString translatingMatchesUsing: aBlock
    copy: aString replacingMatchesWith: replacementString

    copyStream: aStream to: writeStream translatingMatchesUsing: aBlock
    copyStream: aStream to: writeStream replacingMatchesWith: aString
</pre></code>
<p>
  Examples:
<p>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'\w+'</font> <font color="#0066FF">asRegex matchesIn:</font> <font color="#993399">'now is the time'</font>
</pre></code></a>
<p>
  returns an OrderedCollection containing four strings: 'now', 'is', 'the', and 'time'.
<p>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'\&lt;t\w+'</font> <font color="#0066FF">asRegexIgnoringCase
	    copy:</font> <font color="#993399">'now is the Time'</font>
	    <font color="#0066FF">translatingMatchesUsing: [:match | match asUppercase]</font>
</pre></code></a>
<p>
  returns 'now is THE TIME'
  (the regular expression matches words beginning with either an uppercase or a lowercase T).
<p>
</ol>


<h3><a name="SYNTAX" href="#I_SYNTAX">Syntax</a></h3>

  [You can <!-- select and --> `print it' examples in this text. <!-- Just don't forget to cancel the changes. -->]
<p>
<h4>Exact Character Match</h4>
The simplest regular expression is a single character.
  It matches <b>exactly that character</b>.

  A sequence of characters matches a string with exactly the same sequence of characters:
<p>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'a'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a'</font>                   "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'foobar'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'foobar'</font>         "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'blorple'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'foobar'</font>        "-> false"
</pre></code></a>

  The above paragraph introduced a primitive regular expression (a character),
  and an operator (sequencing).
  Operators are applied to regular expressions to produce more complex regular expressions.
  Sequencing (placing expressions one after another) as an operator is,
  in a certain sense, `invisible'--yet it is arguably the most common.
<p>

<h4>Any Character Match ( . )</h4>
  The special `any' character "." (dot) matches ANY character EXCEPT newline.
<br>Thus
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abc'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a..'</font>               "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abcd'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a..'</font>              "-> false"
</pre></code></a>
actually it matches any 3-character string,
except those which include a newline character.


<h4>Repeated Matches ( * for ZERO or more occurrences)</h4>
  A more `visible' operator is Kleene closure, more often simply referred to as `a star'.
  A regular expression followed by an asterisk (`*')
  matches <b>any number (including 0)</b> of matches of the original expression.
<br>
  For example:
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ab'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a*b'</font>                "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'aaaaab'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a*b'</font>            "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'b'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a*b'</font>                 "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'aac'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a*b'</font>               "-> false: b does not match"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'123aa'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'.*aa'</font>            "-> true (matches any string which ends with 'aa', but not containing a newline)"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'123aa456'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'.*aa.*'</font>       "-> true (matches any string containing 'aa', but not containing a newline)"
</pre></code></a>
<p>

  A star's precedence is higher than that of sequencing.
  A star applies to the shortest possible subexpression that precedes it.
  For example, 'ab*' means `a followed by zero or more occurrences of b',
  not `zero or more occurrences of ab':

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abbb'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab*'</font>              "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abab'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab*'</font>              "-> false"
</pre></code></a>

<h4>Parentheses for Grouping</h4>
  To actually make a regex matching `zero or more occurrences of ab',
  `ab' is enclosed in parentheses:

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abab'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(ab)*'</font>            "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abcab'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(ab)*'</font>           "-> false: c spoils the fun"
</pre></code></a>

<h4>Repeated Matches ( + for ONE or more occurrences, ? for ZERO or ONE occurrence)</h4>
  Two other operators similar to `*' are `+' and `?'.
<br>
<ul>
<li>  `+'  (positive closure, or simply `plus') matches <b>one or more</b> occurrences of the
  original expression (i.e. at least one).
<li>
  `?' (`optional') matches <b>zero or one</b>, but never more, occurrences.
</ul>
For example:

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ac'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab*c'</font>               "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ac'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab+c'</font>               "-> false: need at least one b"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abbc'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab+c'</font>             "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abbc'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab?c'</font>             "-> false: too many b's"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ac'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab?c'</font>               "-> true: the b is optional"
</pre></code></a>

<h4>Escaping Special Characters</h4>
  As we have seen, characters `*', `+', `?', `(', and `)' have special meaning in regular expressions.
  If one of them is to be used literally, it should be quoted: preceded with a backslash.
  (Thus, backslash is also special character,
  and needs to be quoted for a literal match--as well as any other special character described further).

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ab*'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab*'</font>               "-> false: star in the right string is special"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ab*'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab\*'</font>              "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'a\c'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a\\c'</font>              "-> true"
</pre></code></a>

<h4>Alternative Match Patterns ( | )</h4>
  The last operator is <b>`|' meaning `or'</b>.
<br>
  It is placed between two regular expressions, and the resulting expression matches if one of the expressions matches.
  It has the lowest possible precedence (lower than sequencing).
  For example, <code>`ab*|ba*'</code> means `a followed by any number of b's, or b followed by any number of a's':

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abb'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab*|ba*'</font>           "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'baa'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab*|ba*'</font>           "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'baab'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'ab*|ba*'</font>          "-> false"
</pre></code></a>

  A bit more complex example is the following expression,
  matching the name of any of the Lisp-style `car', `cdr', `caar', `cadr', ... functions:
<code><pre>
    c(a|d)+r
</pre></code>

  It is possible to write an expression matching an empty string, for example: <code>`a|'</code>.
  However, it is an error to apply `*', `+', or `?' to such expression: <code>`(a|)*'</code> is an invalid expression.
<p>
<h4>Character Sets ( [ ... ] )</h4>
  So far, we have used only characters as the 'smallest' components of regular expressions.
  There are other, more `interesting', components.
<p>
  A character set is a string of characters enclosed in square brackets.
  It matches <b>any single character if it appears between the brackets</b>.
<br>
  For example, `[01]' matches either `0' or `1':
<p>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'0'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[01]'</font>         "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'3'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[01]'</font>         "-> false"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'11'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[01]'</font>        "-> false: a set matches only one character"
</pre></code></a>

<br>
  Using the plus operator, we can build the following binary number recognizer:

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'10010100'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[01]+'</font>        "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'10001210'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[01]+'</font>        "-> false"
</pre></code></a>

<h4>Inverted Character Set ( [ ^... ] )</h4>
  If the first character after the opening bracket is `^',
  the set is inverted: it matches any single character *not* appearing between the brackets:

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'0'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[^01]'</font>               "-> false"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'3'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[^01]'</font>               "-> true"
</pre></code></a>

<h4>Character Ranges in a Set ( [ x-y ] )</h4>
  For convenience, a set may include ranges: pairs of characters separated with `-'.
  This is equivalent to listing all characters between them: `[0-9]' is the same as `[0123456789]'.
<p>
  Special characters within a set are `^', `-', and `]' that closes the set.
<br>
  Below are the examples of how to literally use them in a set:
<code><pre>
    [01^]           -- put the caret anywhere except the beginning
    [01-]           -- put the dash as the last character
    []01]           -- put the closing bracket as the first character
    [^]01]             (thus, empty and universal sets cannot be specified)
</pre></code>
<h4>Special Characters in a Set</h4>
  Be careful: `.' and similar special characters are no longer special inside the character set;
<br>
  therefore:
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'1'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[1.]'</font>         "-> true"
</pre></code></a>
and:
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'.'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[1.]'</font>         "-> true"
</pre></code></a>
but not:
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'2'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[1.]'</font>         "-> false"
</pre></code></a>

<h4>Common Character Classes</h4>
  Regular expressions can also include the following backquote escapes
  to refer to popular classes of characters:
<code><pre>
    \w      any word constituent character (same as [a-zA-Z0-9_])
    \W      any character but a word constituent
    \d      a digit (same as [0-9])
    \D      anything but a digit
    \s      a whitespace character
    \S      anything but a whitespace character
</pre></code>
  These escapes are also allowed in character classes: '[\w+-]' means
  'any character that is either a word constituent, or a plus, or a
  minus'.
<p>
  Character classes can also include the following grep(1)-compatible
  elements to refer to:
<code><pre>
    [:alnum:]               any alphanumeric, i.e., a word constituent, character
    [:alpha:]               any alphabetic character
    [:blank:]               space or tab.
    [:cntrl:]               any control character.
			    In this version, it means any character whith ascii-code is &lt; 32.
    [:digit:]               any decimal digit.
    [:graph:]               any graphical character.
			    In this version, this mean any character with ascii-code &gt;= 32.
    [:lower:]               any lowercase character
    [:print:]               any printable character.
			    In this version, this is the same as [:cntrl:]
    [:punct:]               any punctuation character.
    [:space:]               any whitespace character.
    [:upper:]               any uppercase character.
    [:xdigit:]              any hexadecimal character.
</pre></code>

  Note that these elements are components of the character classes,
  i.e. they have to be enclosed in an extra set of square brackets to
  form a valid regular expression.
<br>
  For example, a non-empty string of digits would be represented as <code>'[[:digit:]]+'</code>.
<p>
<h4>Smalltalk Specific: Character Test Messages</h4>
  The above primitive expressions and operators are common to many
  implementations of regular expressions. The next primitive expression
  is unique to this Smalltalk implementation.
<p>
  A sequence of characters between colons is treated as a unary selector
  which is supposed to be understood by characters. A character matches
  such an expression if it answers true to a message with that
  selector. This allows a more readable and efficient way of specifying
  character classes (by adding appropriate protocol to the character class,
  it can also be easily extended).
<br>
  For example, <code>`[0-9]'</code> is equivalent to <code>`:isDigit:'</code>,
  but the latter is more efficient. Analogously to character sets,
  character classes can be negated: <code>`:^isDigit:'</code> matches a Character
  that answers false to #isDigit,
  and is therefore equivalent to <code>`[^0-9]'</code>.
<p>
The following messages from Smalltalk's Character protocol are useful here:
<CODE><PRE>
    :isControlCharacter:  <VAR>true if I am a control character (i.e. ascii value &lt; 32 or == 16rFF)</VAR>
    :isDigit:             <VAR>as described above</VAR>
    :isLetter:            <VAR>a-z or A-Z</VAR>
    :isLetterOrDigit:     <VAR>a-z or A-Z or 0-9</VAR>
    :isNationalLetter:    <VAR>any letter in the whole Unicode set (not just a-z, A-Z)</VAR>
    :isNationalAlphaNumeric:  <VAR>any letter or digit from the Unicode set</VAR>
    :isLowercase:         <VAR>any lowercase letter in the Unicode set (i.e. not only a-z)</VAR>
    :isUppercase:         <VAR>any uppercase letter in the Unicode set (i.e. not only A-Z)</VAR>
    :isSeparator:         <VAR>any whitespace (space, nl, cr, tab, ff)</VAR>
    :isVowel:             <VAR>aeiouAEIOU</VAR>
    :isHexDigit:          <VAR>0-9, a-f, A-F</VAR>
</PRE></CODE>

  As an summarizing example, so far we have seen the following equivalent ways to
  write a regular expression that matches a non-empty string of digits:
<code><pre>
    '[0-9]+'
    '\d+'
    '[\d]+'
    '[[:digit::]+'
    :isDigit:+'
</pre></code>

<h4>More Special Characters</h4>
  The last group of special primitive expressions includes:
<code><pre>
    .       matching any character except a newline;
    ^       matching an empty string at the beginning of a line;
    $       matching an empty string at the end of a line.
    \b      an empty string at a word boundary
    \B      an empty string not at a word boundary
    \&lt;      an empty string at the beginning of a word
    \&gt;      an empty string at the end of a word
</pre></code>
  Again, all the above three characters (`.', `^' and `$')
  are special and should be quoted to be matched literally.
<p>
Examples:
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'axyzb'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a.+b'</font>            "-> true"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ax zb'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'a.+b'</font>            "-> true (space is matched by `.')"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    (<font color="#993399">'ax'</font> , Character cr ,<font color="#993399">'zb'</font>)
	<font color="#0066FF">matchesRegex:</font> <font color="#993399">'a.+b'</font>                "-> false (newline is not matched by `.')"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    (<font color="#993399">'ax'</font> , Character cr ,<font color="#993399">'zb'</font>)
	<font color="#0066FF">matchesRegex:</font> <font color="#993399">'a(.|\n)+b'</font>           "-> true)"
</pre></code></a>

<h3>EXAMPLES</h3>

  As the introductions said, a great use for regular expressions is user
  input validation. Following are a few examples of regular expressions
  that might be handy in checking input entered by the user in an input
  field. Try them out by entering something between the quotes and
  print-iting. (Also, try to imagine Smalltalk code that each validation
  would require if coded by hand).  Most example expressions could have
  been written in alternative ways.
<p>
  Checking if aString may represent a nonnegative integer number:

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">':isDigit:+'</font>
</pre></code>
  or
<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[0-9]+'</font>
</pre></code>
  or
<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'\d+'</font>
</pre></code>

  Checking if aString may represent an integer number with an optional
  sign in front:

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(\+|-)?\d+'</font>
</pre></code>

  Checking if aString is a fixed-point number, with at least one digit
  is required after a dot:

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(\+|-)?\d+(\.\d+)?'</font>
</pre></code>

  The same, but allow notation like `123.':

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(\+|-)?\d+(\.\d*)?'</font>
</pre></code>

  Recognizer for a string that might be a name: one word with first
  capital letter, no blanks, no digits.  More traditional:

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'[A-Z][A-Za-z]*'</font>
</pre></code>

  more Smalltalkish:

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">':isUppercase::isAlphabetic:*'</font>
</pre></code>

  A date in format MMM DD, YYYY with any number of spaces in between, in
  XX century:

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(\d\d?)[ ]*,[ ]*19(\d\d)'</font>
</pre></code>

  Note parentheses around some components of the expression above. As
  `Usage' section shows, they will allow us to obtain the actual strings
  that have matched them (i.e. month name, day number, and year number).
<p>
  For dessert, coming back to numbers: here is a recognizer for a
  general number format: anything like 999, or 999.999, or -999.999e+21.

<code><pre>
    aString <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(\+|-)?\d+(\.\d*)?((e|E)(\+|-)?\d+)?'</font>
</pre></code>




<h3><a name="USAGE" href="#I_USAGE">Usage</a></h3>

The preceding section covered the syntax of regular expressions.
It used the simplest possible interface to the matcher:
sending a <code>#matchesRegex:</code>-message to the sample string,
with a regular expression string as the argument.
<br>
This section explains hairier ways of using the matcher.

<h4>Prefix Matching and Case-Insensitive Matching</h3>

A CharacterArray also understands these messages:
<code><pre>
    aString <font color="#0066FF">prefixMatchesRegex:</font> regexString
    aString <font color="#0066FF">matchesRegexIgnoringCase:</font> regexString
    aString <font color="#0066FF">prefixMatchesRegexIgnoringCase:</font> regexString
</pre></code>
#prefixMatchesRegex: is just like #matchesRegex, except that the whole
receiver is not expected to match the regular expression passed as the
argument; matching just a prefix of it is enough.
<br>
For example:

<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abcde'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'(a|b)+'</font>          "-> false"
</pre></code></a>
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'abcde'</font> <font color="#0066FF">prefixMatchesRegex:</font> <font color="#993399">'(a|b)+'</font>    "-> true"
</pre></code></a>

The last two messages are case-insensitive versions of matching.

<h4>ENUMERATION INTERFACE</h4>

  An application can be interested in all matches of a certain regular
  expression within a String. The matches are accessible using a
  protocol modelled after the familiar Collection-like enumeration
  protocol:

<code><pre>
    aString <font color="#0066FF">regex:</font> regexString <font color="#0066FF">matchesDo:</font> aBlock
</pre></code>

  Evaluates a one-argument &lt;aBlock&gt; for every match of the regular
  expression within the receiver string.

<code><pre>
    aString <font color="#0066FF">regex:</font> regexString <font color="#0066FF">matchesCollect:</font> aBlock
</pre></code>

  Evaluates a one-argument &lt;aBlock> for every match of the regular
  expression within the receiver string.
  Collects results of evaluations and anwers them as a SequenceableCollection.

<code><pre>
    aString <font color="#0066FF">allRegexMatches:</font> regexString
</pre></code>

  Returns a collection of all matches (substrings of the receiver string) of the regular expression.
<br>
  It is an equivalent of
<code><pre>
    aString <font color="#0066FF">regex:</font> regexString <font color="#0066FF">matchesCollect:</font> [:each | each].
</pre></code>


<h4>REPLACEMENT AND TRANSLATION</h4>

  It is possible to replace all matches of a regular expression with a
  certain string using the message:

<code><pre>
    aString <font color="#0066FF">copyWithRegex:</font> regexString <font color="#0066FF">matchesReplacedWith:</font> aString
</pre></code>

  For example:
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ab cd ab'</font> <font color="#0066FF">copyWithRegex:</font> <font color="#993399">'(a|b)+'</font> <font color="#0066FF">matchesReplacedWith:</font> <font color="#993399">'foo'</font>
</pre></code></a>
returns the string: 'foo cd foo'.
<p>
A more general substitution is match translation:

<code><pre>
    aString <font color="#0066FF">copyWithRegex:</font> regexString <font color="#0066FF">matchesTranslatedUsing:</font> aBlock
</pre></code>

  This message evaluates a block passing it each match of the regular
  expression in the receiver string and answers a copy of the receiver
  with the block results spliced into it in place of the respective
  matches.
<br>
  For example:
<a type="example" SHOWRESULT><code><pre>
    <font color="#993399">'ab cd ab'</font> <font color="#0066FF">copyWithRegex:</font> <font color="#993399">'(a|b)+'</font> <font color="#0066FF">matchesTranslatedUsing:</font> [:each | each asUppercase]
</pre></code></a>
results in the string: 'AB cd AB'.
<p>
  All messages of enumeration and replacement protocols perform a case-sensitive match.
  Case-insensitive versions are not provided as part of a CharacterArray protocol.
  Instead, they are accessible using the lower-level matching interface.

<h4>LOWER-LEVEL INTERFACE</h4>

  Internally, <code>aString matchesRegex:</code> works as follows:

<ol>
<li>A fresh instance of <code>RxParser</code> is created,
    and the regular expression string is passed to it, yielding the expression's syntax tree.
<p>

<li>The syntax tree is passed as an initialization parameter to an
  instance of <code>RxMatcher</code>. The instance sets up some data structure that
  will work as a recognizer for the regular expression described by the tree.
<p>

<li>The original string is passed to the matcher, and the matcher checks for a match.
</ol>


<h4>THE MATCHER</h4>

  If you repeatedly match a number of strings against the same regular
  expression using one of the messages defined in CharacterArray,
  the regular expression string is parsed and a matcher is created anew for every match.
  You can avoid this overhead by building a matcher for
  the regular expression, and then reusing the matcher over and over
  again.
  You can, for example, create a matcher at a class or instance
  initialization stage, and store it in a variable for future use.
<p>
  You can create a matcher using one of the following methods:
<p>
<ul>
<li>Sending a <code>forString:ignoreCase:</code> message to <code>RxMatcher class</code>,
  with the regular expression string and a Boolean indicating whether case is ignored as arguments.
<p>

<li>Sending <code>forString:</code> message.
<br>It is equivalent to "<code>... forString: regexString ignoreCase: false</code>".
</ul>

  A more convenient way is using one of the two matcher-created messages
  understood by CharacterArray.
<ul>
<li>"<code>regexString asRegex</code>" is equivalent to
    "<code>RxMatcher forString: regexString</code>".
<p>

<li>"<code>regexString asRegexIgnoringCase</code>"
<br>is equivalent to
    "<code>RxMatcher forString: regexString ignoreCase: true</code>".
<p>
</ul>

  Here are four examples of creating a matcher:
<code><pre>
    hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+'
    hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+' ignoreCase: false
    hexRecognizer := '16r[0-9A-Fa-f]+' asRegex
    hexRecognizer := '16r[0-9A-F]+' asRegexIgnoringCase
</pre></code>


<h4>MATCHING</h4>

  The matcher understands these messages (all of them return true to
  indicate successful match or search, and false otherwise):
<dl>
<dt> <code> <font color="#0066FF">matches:</font> aString </code>
<dd>
	  True if the whole target string (aString) matches.
<p>

<dt> <code> <font color="#0066FF">matchesPrefix:</font> aString </code>
<dd>
	  True if some prefix of the string (not necessarily the whole
	  string) matches.
<p>

<dt> <code> <font color="#0066FF">search:</font> aString </code>
<dd>
	  Search the string for the first occurrence of a matching
	  substring. (Note that the first two methods only try matching from
	  the very beginning of the string). Using the above example with a
	  matcher for `a+', this method would answer success given a string
	  `baaa', while the previous two would fail.
<p>

<dt> <code> <font color="#0066FF">matchesStream:</font> aStream </code>
<dt> <code> <font color="#0066FF">matchesStreamPrefix:</font> aStream </code>
<dt> <code> <font color="#0066FF">searchStream:</font> aStream </code>
<dd>
	  Respective analogs of the first three methods, taking input from a
	  stream instead of a string. The stream must be positionable and
	  peekable.
</dl>

  All these methods answer a boolean indicating success. The matcher
  also stores the outcome of the last match attempt and can report it:

<dl>
<dt> <code> <font color="#0066FF">lastResult</font> </code>
<dd>
	  Answers a Boolean -- the outcome of the most recent match
	  attempt. If no matches were attempted, the answer is unspecified.
</dl>

<h4>SUBEXPRESSION MATCHES</h4>

  After a successful match attempt, you can query the specifics of which
  part of the original string has matched which part of the whole
  expression.

  A subexpression is a parenthesized part of a regular expression, or
  the whole expression. When a regular expression is compiled, its
  subexpressions are assigned indices starting from 1, depth-first,
  left-to-right.
<br>
  For example, <code>`((ab)+(c|d))?ef'</code> includes the following subexpressions with these indices:

<code><pre>
	  1:      ((ab)+(c|d))?ef
	  2:      (ab)+(c|d)
	  3:      ab
	  4:      c|d
</pre></code>
  Be aware, that the first subexpressions represents the whole match.
<br>

  After a successful match, the matcher can report what part of the
  original string matched what subexpression. It understandards these
  messages:

<dl>
<dt> <code>   <font color="#0066FF">subexpressionCount</font>  </code>
<dd>
	  Answers the total number of subexpressions: the highest value that
	  can be used as a subexpression index with this matcher. This value
	  is available immediately after initialization and never changes.
<p>

<dt> <code>   <font color="#0066FF">subexpression:</font> anIndex  </code>
<dd>
	  An index must be a valid subexpression index, and this message
	  must be sent only after a successful match attempt. The method
	  answers a substring of the original string the corresponding
	  subexpression has matched to.
<p>

<dt> <code>   <font color="#0066FF">subBeginning:</font> anIndex  </code>
<dt> <code>   <font color="#0066FF">subEnd:</font> anIndex </code>
<dd>
	  Answer positions within the original string or stream where the
	  match of a subexpression with the given index has started and
	  ended, respectively.
</dl>
  This facility provides a convenient way of extracting parts of input
  strings of complex format. For example, the following piece of code
  uses the 'MMM DD, YYYY' date format recognizer example from the
  `Syntax' section to convert a date to a three-element array with year,
  month, and day strings (you can select and evaluate it right here):

<a type="example" SHOWRESULT><code><pre>
    | matcher |
    matcher := Regex::RxMatcher new <font color="#0066FF">initializeFromString:</font> '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(:isDigit::isDigit:?)[ ]*,[ ]*19(:isDigit::isDigit:)'.
    (matcher <font color="#0066FF">matches:</font> 'Aug 6, 1996')
	    ifTrue:
		    [Array
			    with: (matcher <font color="#0066FF">subexpression:</font> 4)
			    with: (matcher <font color="#0066FF">subexpression:</font> 2)
			    with: (matcher <font color="#0066FF">subexpression:</font> 3)]
	    ifFalse: ['no match']
</pre></code></a>
  (should answer `<code>#('96' 'Aug' '6')</code>').

<h4>ENUMERATION AND REPLACEMENT</h4>

  The enumeration and replacement protocols exposed in CharacterArray
  are actually implemented by the mather.
<br>
  The following messages are understood:
<code><pre>
    <font color="#0066FF">matchesIn:</font> aString
    <font color="#0066FF">matchesIn:</font> aString <font color="#0066FF">do:</font> aBlock
    <font color="#0066FF">matchesIn:</font> aString <font color="#0066FF">collect:</font> aBlock
    <font color="#0066FF">copy:</font> aString <font color="#0066FF">replacingMatchesWith:</font> replacementString
    <font color="#0066FF">copy:</font> aString <font color="#0066FF">translatingMatchesUsing:</font> aBlock

    <font color="#0066FF">matchesOnStream:</font> aStream
    <font color="#0066FF">matchesOnStream:</font> aStream <font color="#0066FF">do:</font> aBlock
    <font color="#0066FF">matchesOnStream:</font> aStream <font color="#0066FF">collect:</font> aBlock
    <font color="#0066FF">copy:</font> sourceStream <font color="#0066FF">to:</font> targetStream <font color="#0066FF">replacingMatchesWith:</font> replacementString
    <font color="#0066FF">copy:</font> sourceStream <font color="#0066FF">to:</font> targetStream <font color="#0066FF">translatingMatchesWith:</font> aBlock
</pre></code>


<h4>ERROR HANDLING</h4>

  Exception signaling objects are
  accessible through <code>RxParser class</code> protocol.
  To handle possible errors, use the protocol described below to obtain the exception objects
  and use the protocol of the native Smalltalk implementation to handle them.
<p>
  If a syntax error is detected while parsing expression,
  <code>RxParser &#187; <font color="#0066FF">syntaxErrorSignal</font></code> is raised/signaled.
<p>
  If an error is detected while building a matcher,
  <code>RxParser &#187; <font color="#0066FF">compilationErrorSignal</font></code> is raised/signaled.
<p>
  If an error is detected while matching
  (for example, if a bad selector was specified using `:&lt;selector>:' syntax,
  or because of the matcher's internal error),
  <code>RxParser &#187; <font color="#0066FF">matchErrorSignal</font></code> is raised
<p>
  <code>RxParser &#187; <font color="#0066FF">regexErrorSignal</font></code> is the parent of all three.
  Since any of the three signals can be raised within a call to #matchesRegex:,
  it is handy if you want to catch them all.
<p>
  For example:
<p>
  Ansi-Smalltalk (VisualWorks, SmalltalkX, Squeak etc.):
<code><pre>
    [ <font color="#993399">'abc'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'))garbage['</font> ]
	<font color="#0066FF">on:</font> RxParser <font color="#0066FF">regexErrorSignal</font>
	<font color="#0066FF">do:</font> [:ex | ex <font color="#0066FF">returnWith:</font> nil]
</pre></code>
  VisualWorks, SmalltalkX:
<code><pre>
    RxParser <font color="#0066FF">regexErrorSignal</font>
	<font color="#0066FF">handle:</font> [:ex | ex <font color="#0066FF">returnWith:</font> nil]
	<font color="#0066FF">do:</font> [ <font color="#993399">'abc'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'))garbage['</font> ]
</pre></code>
  VisualAge, SmalltalkX:
<code><pre>
    [ <font color="#993399">'abc'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'))garbage['</font> ]
	<font color="#0066FF">when:</font> RxParser <font color="#0066FF">regexErrorSignal</font>
	<font color="#0066FF">do:</font> [:signal | signal <font color="#0066FF">exitWith:</font> nil]
</pre></code>


<h3><a name="IMPLEMENTATION" href="#I_IMPLEMENTATION">Implementation</a></h3>

Version:                1.1
<br
Released:               October 1999
<br>
Mail to:                Vassili Bykov &lt;vassili@magma.ca>, &lt;vassili@objectpeople.com>
<br>
Flames to:              /dev/null

<h4>WHAT IS ADDED</h4>

  The matcher includes classes in two categories:
<code><pre>
    VB-Regex-Syntax
    VB-Regex-Matcher
</pre></code>
  and a few <code>CharacterArray</code> methods in <code>`VB-regex'</code> protocol.
  No system classes or methods are modified.


<h4>WHAT TO LOOK AT FIRST</h4>

<dl>
<dt> <code> String  &#187;  <font color="#0066FF">matchesRegex:</font> </code>
<dd> in 90% cases this method is all you need to access the package.
<p>

<dt> <code> RxParser </code>
<dd> accepts a string or a stream of characters with a regular expression,
    and produces a syntax tree corresponding to the expression.
    The tree is made of instances of <code>Rxs&lt;whatever></code> classes.

<dt> <code> RxMatcher </code>
<dd> accepts a syntax tree of a regular expression built by
  the parser and compiles it into a matcher: a structure made of
  instances of Rxm&lt;whatever> classes. The RxMatcher instance can test
  whether a string or a positionable stream of characters matches the
  original regular expression, or search a string or a stream for
  substrings matching the expression. After a match is found, the
  matcher can report a specific string that matched the whole
  expression, or any parenthesized subexpression of it.
</dl>

  All other classes support the above functionality and are used by
  <code>RxParser</code>, <code>RxMatcher</code>, or both.

<h4>CAVEATS</h4>

  The matcher is similar in spirit, but NOT in the design--let alone the
  code--to the original Henry Spencer's regular expression
  implementation in C.  The focus is on simplicity, not on efficiency.
  I didn't optimize or profile anything.  I may in future--or I may not:
  I do this in my spare time and I don't promise anything.
<p>
  The matcher passes H. Spencer's test suite (see 'test suite'
  protocol), with quite a few extra tests added, so chances are good
  there are not too many bugs.  But watch out anyway.

<h4>EXTENSIONS, FUTURE, ETC.</h4>

  With the existing separation between the parser, the syntax tree, and
  the matcher, it is easy to extend the system with other matchers based
  on other algorithms. In fact, I have a DFA-based matcher right now,
  but I don't feel it is good enough to include it here.  I might add
  automata-based matchers later, but again I don't promise anything.

<h4>HOW TO REACH ME</h4>

  As of today (October 3, 1999), you can contact me at
  &lt;vassili@objectpeople.com&gt;. If this doesn't work, look around
  comp.lang.smalltalk and comp.lang.lisp.




<h3>Boring Stuff</h4>

The Regular Expression Matcher (``The Software'')
is Copyright (C) 1996, 1999 Vassili Bykov.
It is provided to the Smalltalk community in hope it will be useful.

<ol>
<li>This license applies to the package as a whole, as well as to any
   component of it. By performing any of the activities described
   below, you accept the terms of this agreement.
<p>

<li>The software is provided free of charge, and ``as is'', in hope
   that it will be useful, with ABSOLUTELY NO WARRANTY. The entire
   risk and all responsibility for the use of the software is with
   you.  Under no circumstances the author may be held responsible for
   loss of data, loss of profit, or any other damage resulting
   directly or indirectly from the use of the software, even if the
   damage is caused by defects in the software.
<p>

<li>You may use this software in any applications you build.
<p>

<li>You may distribute this software provided that the software
   documentation and copyright notices are included and intact.
<p>

<li>You may create and distribute modified versions of the software,
   such as ports to other Smalltalk dialects or derived work, provided
   that:
<p>

<br><b>a.</b> any modified version is expressly marked as such and is not
   misrepresented as the original software;

<br><b>b.</b> credit is given to the original software in the source code and
   documentation of the derived work;

<br><b>c.</b> the copyright notice at the top of this document accompanies
   copyright notices of any modified version.

</ol>










<h3>ACKNOWLEDGEMENTS</h3>

  Since the first release of the matcher, thanks to the input from
  several fellow Smalltalkers, I became convinced a native Smalltalk
  regular expression matcher was worth the effort to keep it alive.
  For the advice and encouragement that made this release possible,
  I want to thank:
<p>
<pre>
    Felix Hack
    Eliot Miranda
    Robb Shecter
    David N. Smith
    Francis Wolinski
</pre>
<p>
  and anyone whom I haven't yet met or heard from, but who agrees this
  has not been a complete waste of time.


<H2>More Examples</H2>
Via string protocol:

<A type="example" SHOWRESULT>
<CODE><PRE>
    <font color="#993399">'hello world'</font> <font color="#0066FF">matchesRegex:</font> <font color="#993399">'h.*d'</font>
</PRE></CODE></A>
Or:
<a type="example" SHOWRESULT><CODE><PRE>
    |matcher|

    matcher := <font color="#993399">'.*ll.*'</font> <font color="#0066FF">asRegex</font>.
    matcher <font color="#0066FF">matches:</font> <font color="#993399">'hello world'</font>.
</PRE></CODE></A>
Fetching matched subexpressions:
<a type="example"><CODE><PRE>
    |matcher sub1 sub2 sub3|

    matcher := <font color="#993399">'\D*([0-9]+)\s([0-9]+)\D*.*'</font> <font color="#0066FF">asRegex</font>.
    (matcher <font color="#0066FF">matches:</font> <font color="#993399">'bla bla 123456 123 bla bla'</font>) ifTrue:[
	Transcript showCR:(matcher <font color="#0066FF">subexpressionCount</font> printString , ' subExpressions').
	sub1 := matcher <font color="#0066FF">subexpression:</font>1.
	sub2 := matcher <font color="#0066FF">subexpression:</font>2.
	sub3 := matcher <font color="#0066FF">subexpression:</font>3.
	Transcript showCR:'subExpr1 is ' , sub1.
	Transcript showCR:'subExpr2 is ' , sub2.
	Transcript showCR:'subExpr3 is ' , sub3.
    ].
</PRE></CODE></a>

<H2>Licensing</H2>
This addOn package is NOT to be considered part of the base ST/X system.
It is provided physically with the ST/X delivery, but only for your
convenience.
<P>
Legally, it is a freeware or public domain goody, as specified in
the goodies copyright notice (see the goodies source).

<H2>No Warranty</H2>
This goody is provided AS-IS without any warranty whatsoever.



<H2>Origin/Authors</H2>
Found in and ported from the smalltalk archives.
<BR>
Author:
<P>
    Vassili Bykov
<P>
    See <code>RxParser class &#187; boringStuff</code> for legal information.
<P>
<P>
<HR>
<P>
<IMG NOPRINT ALIGN=middle SRC="../../icons/stx.gif">
Copyright &copy; 1999 eXept Software AG

<P>
<ADDRESS>
<tt>&lt;<a href="mailto:info@exept.de">info@exept.de</a>&gt;</tt>
</ADDRESS>

<HR>
Doc $Revision: 1.16 $
</BODY>
</HTML>
