<HTML>

<HEAD>
<TITLE>Smalltalk/X Programmers Guide - View Programming</Title>
</HEAD>

<BODY>

<A NOPRINT HREF="finalization.html"> <IMG SRC="../../icons/DocsLeftArrow.gif" ALT="[prev]"></A>
<A NOPRINT HREF="TOP.html"> <IMG SRC="../../icons/DocsUpArrow.gif" ALT="[up]"></A>
<A NOPRINT HREF="stxstyleguide.html"> <IMG SRC="../../icons/DocsRightArrow.gif" ALT="[next]"></A>
<P>

<P>
<IMG SRC="../../pictures/at_work.gif" alt="Work in progress">
This document is being prepared - it is not complete.
<P>

<H1>Introduction to View Programming</H1>

<H2>Contents</H2>
<UL>
 <LI><A HREF="#INTRO" NAME="I_INTRO">Introduction</A>
<P>
 <LI><A HREF="#MVC" NAME="I_MVC">Model-View-Controller vs. callback operation</A>
<P>
 <LI><A HREF="#TOPVIEWS" NAME="I_TOPVIEWS">Topviews</A>
 <UL>
   <LI><A HREF="#TOP_MODES" NAME="I_TOP_MODES">Modeless vs. modal</A>
   <LI><A HREF="#TOP_LABELS" NAME="I_TOP_LABELS">Window labels, icons &amp; titles</A>
 </UL>
<P>
 <LI><A HREF="#DIMENSIONS" NAME="I_DIMENSIONS">Window dimensions &amp; position</A>
 <UL>
   <LI><A HREF="#DIM_FIXED" NAME="I_TOP_FIXED">Fixed size</A>
   <LI><A HREF="#DIM_RELATIVE" NAME="I_DIM_RELATIVE">Relative size</A>
   <LI><A HREF="#DIM_COMPUTED" NAME="I_DIM_COMPUTED">Dynamically computed size</A>
   <LI><A HREF="#DIM_LAYOUT" NAME="I_DIM_LAYOUT">Layout objects</A>
 </UL>
<P>
 <LI><A HREF="#GENERAL" NAME="I_GENERAL">General view appearance</A>
 <UL>
   <LI><A HREF="#LAYOUT_STYLES" NAME="I_LAYOUT_STYLES">Do not fight the style sheet</A>
 </UL>
<P>
 <LI><A HREF="#LAYOUT" NAME="I_LAYOUT">Layout of subviews</A>
 <UL>
   <LI><A HREF="#LAYOUT_SUBVIEWS" NAME="I_LAYOUT_SUBVIEWS">Using simple subviews for layout</A>
   <LI><A HREF="#LAYOUT_THREED" NAME="I_LAYOUT_THREED">3D level, border &amp; background</A>
   <LI><A HREF="#LAYOUT_BGPATTERN" NAME="I_LAYOUT_BGPATTERN">... and background pattern</A>
   <LI><A HREF="#LAYOUT_INSET" NAME="I_LAYOUT_INSET">Inset</A>
   <LI><A HREF="#LAYOUT_LABELS" NAME="I_LAYOUT_LABELS">Labels</A>
   <LI><A HREF="#LAYOUT_PANELS" NAME="I_LAYOUT_PANELS">Panels</A>
   <UL>
     <LI><A HREF="#LAYOUT_HVPANELS" NAME="I_LAYOUT_HVPANELS">Horizontal and vertical panels</A>
     <LI><A HREF="#LAYOUT_LAYOUT" NAME="I_LAYOUT_LAYOUT">Specifying how elements are arranged</A>
     <LI><A HREF="#LAYOUT_SPACING" NAME="I_LAYOUT_SPACING">Specifying the spacing between elements</A>
     <LI><A HREF="#LAYOUT_CONFLICTS" NAME="I_LAYOUT_CONFLICTS">Layout conflicts</A>
   </UL>
   <LI><A HREF="#LAYOUT_VARPANELS" NAME="I_LAYOUT_VARPANELS">Variable panels</A>
   <LI><A HREF="#LAYOUT_INVISIBLE" NAME="I_LAYOUT_INVISIBLE">Invisible views</A>
   <LI><A HREF="#LAYOUT_HIDDEN" NAME="I_LAYOUT_HIDDEN">Stacked views</A>
   <LI><A HREF="#LAYOUT_SCROLLING" NAME="I_LAYOUT_SCROLLING">Scrolling views</A>
 </UL>
<P>
 <LI><A HREF="#INTER" NAME="I_INTER">Interactors</A>
 <UL>
   <LI><A HREF="#INTER_BUTTONS" NAME="I_INTER_BUTTONS">Buttons</A>
   <UL>
     <LI><A HREF="#BUTTONS_ACTION" NAME="I_BUTTONS_ACTION">Attaching an action to a button</A>
     <LI><A HREF="#BUTTONS_APPEAR" NAME="I_BUTTONS_APPEAR">Fonts and images</A>
     <LI><A HREF="#BUTTONS_ENABLE" NAME="I_BUTTONS_ENABLE">Enabling &amp; disabling</A>
     <LI><A HREF="#BUTTONS_LOGOS" NAME="I_BUTTONS_LOGOS">Different active/passive logos</A>
     <LI><A HREF="#BUTTONS_FIX" NAME="I_BUTTONS_FIX">Fix size vs. variable size</A>
   </UL>
   <LI><A HREF="#INTER_TOGGLES" NAME="I_INTER_TOGGLES">Toggles and radio buttons</A>
   <LI><A HREF="#INTER_CTOGGLES" NAME="I_INTER_CTOGGLES">CheckToggle and CheckBox</A>
   <LI><A HREF="#INTER_SLIDERS" NAME="I_INTER_SLIDERS">Sliders and scrollers</A>
   <LI><A HREF="#INTER_SCROLLBARS" NAME="I_INTER_SCROLLBARS">Scrollbars</A>
   <LI><A HREF="#INTER_SCRVIEW" NAME="I_INTER_SCRVIEW">Scrolled views</A>
   <UL>
     <LI><A HREF="#MINISCROLLERS" NAME="I_MINISCROLLERS">Miniscrollers</A>
   </UL>
 </UL>
<P>
 <LI><A HREF="#TEXTVIEWS" NAME="I_TEXTVIEWS">Textviews</A>
 <UL>
   <LI><A HREF="#TEXT_LISTVIEW" NAME="I_TEXT_LISTVIEW">ListView - a view for simple lists</A>
   <LI><A HREF="#TEXT_TEXTVIEW" NAME="I_TEXT_TEXTVIEW">TextView - a view for readonly text</A>
   <LI><A HREF="#TEXT_EDITTEXTVIEW" NAME="I_TEXT_EDITTEXTVIEW">EditTextView - editable text</A>
   <LI><A HREF="#TEXT_TEXTCOLL" NAME="I_TEXT_TEXTCOLL">TextCollector - streaming into a textView</A>
   <LI><A HREF="#TEXT_WORKSPACE" NAME="I_TEXT_WORKSPACE">Workspace - editable text plus doIt</A>
   <LI><A HREF="#TEXT_CODEVIEW" NAME="I_TEXT_CODEVIEW">CodeView - editable source code</A>
 </UL>

<P>
 <LI><A HREF="#SELECTION" NAME="I_SELECTION">Selection views</A>
 <UL>
   <LI><A HREF="#SELECTION_SELECTIONINLISTVIEW" NAME="I_SELECTION_SELECTIONINLISTVIEW">SelectionInListView - single selection in a list</A>
   <LI><A HREF="#SELECTION_MULTISELECTIONINLIST" NAME="I_SELECTION_MULTISELECTIONINLIST">MultiSelectionInList - multiple selections in a list</A>
   <LI><A HREF="#SELECTION_FILESELECTIONLISTVIEW" NAME="I_SELECTION_FILESELECTIONLISTVIEW">FileSelectionListView - file selections</A>
 </UL>

<P>
 <LI><A HREF="#DIALOGS" NAME="I_DIALOGS">Dialog boxes</A>
 <UL>
  <LI><A HREF="#DIALOG_STD" NAME="I_DIALOG_STD">Standard dialogs</A>
  <UL>
   <LI><A HREF="#DIALOG_INFO" NAME="I_DIALOG_INFO">InfoBox - information display</A>
   <LI><A HREF="#DIALOG_WARN" NAME="I_DIALOG_WARN">WarningBox - warnings</A>
   <LI><A HREF="#DIALOG_YESNO" NAME="I_DIALOG_YESNO">YesNoBox - yes/no confirmers</A>
   <LI><A HREF="#DIALOG_ENTER" NAME="I_DIALOG_ENTER">EnterBox - ask for a string</A>
   <LI><A HREF="#DIALOG_ENTER2" NAME="I_DIALOG_ENTER2">EnterBox2</A>
   <LI><A HREF="#DIALOG_OPTION" NAME="I_DIALOG_OPTION">OptionBox - many buttons</A>
   <LI><A HREF="#DIALOG_TEXTBOX" NAME="I_DIALOG_TEXTBOX">TextBox - multiline text entry</A>
   <LI><A HREF="#DIALOG_LISTSELECTIONBOX" NAME="I_DIALOG_LISTSELECTIONBOX">ListSelectionBox - selection from a list</A>
   <LI><A HREF="#DIALOG_FILESELECTION" NAME="I_DIALOG_FILESELECTION">File open &amp; save dialogs</A>
   <UL>
   <LI><A HREF="#DIALOG_FILESELECTIONBOX" NAME="I_DIALOG_FILESELECTIONBOX">FileSelectionBox - file open dialog</A>
   <LI><A HREF="#DIALOG_FILESAVEBOX" NAME="I_DIALOG_FILESAVEBOX">FileSaveBox - file save dialog</A>
   </UL>
   <LI><A HREF="#DIALOG_FONTPANEL" NAME="I_DIALOG_FONTPANEL">FontPanel - choose a font</A>
  </UL>
  <LI><A HREF="#DIALOG_COMPATIBILITY" NAME="I_DIALOG_COMPATIBILITYM">Dialog compatibility protocol</A>
  <LI><A HREF="#DIALOG_CUSTOM" NAME="I_DIALOG_CUSTOM">Custom dialogs</A>
  <PRE>
   to be written ...
  </PRE>
 </UL>

<P>
 <LI><A HREF="#POPUPS" NAME="I_POPUPS">Popup menus</A>
 <UL>
   <LI><A HREF="#POPUPS_MIDDLE" NAME="I_POPUPS_MIDDLE">Defining a middle button menu</A>
   <LI><A HREF="#POPUPS_CHECK" NAME="I_POPUPS_CHECK">Check-mark entries</A>
   <LI><A HREF="#POPUPS_WRAP" NAME="I_POPUPS_WRAP">Wrapping arbitrary views as popup</A>
   <LI><A HREF="#POPUPS_ST80" NAME="I_POPUPS_ST80">ST-80 style menus</A>
   <LI><A HREF="#POPUPS_SUBMENU" NAME="I_POPUPS_SUBMENU">Defining submenus</A>
   <LI><A HREF="#POPUPS_ADDREMOVE" NAME="I_POPUPS_ADDREMOVE">Dynamically adding/removing entries</A>
   <LI><A HREF="#POPUPS_DYNAMIC" NAME="I_POPUPS_DYNAMICE">Dynamic menus</A>
 </UL>

<P>
 <LI><A HREF="#PULLDOWN" NAME="I_PULLDOWN">Pulldown menus</A>
<PRE>
   to be written ...
</PRE>

<P>
 <LI><A HREF="#SPECIAL" NAME="I_SPECIAL">Special views</A>
 <UL>
   <LI><A HREF="#SPECIAL_SHADOW" NAME="I_SPECIAL_SHADOW">ShadowView - shadows under views</A>
   <LI><A HREF="#SPECIAL_INPUTVIEW" NAME="I_SPECIAL_INPUTVIEW">InputView - a transparent (input-only) view</A>
   <LI><A HREF="#SPECIAL_SHAPES" NAME="I_SPECIAL_SHAPES">Arbitrary shaped views</A>
   <LI><A HREF="#SPECIAL_ROOT" NAME="I_SPECIAL_ROOT">The root view</A>
   <LI><A HREF="#SPECIAL_DISPLAY" NAME="I_SPECIAL_DISPLAY">The Display</A>
   <LI><A HREF="#SPECIAL_MODALNONMODAL" NAME="I_SPECIAL_MODALNONMODAL">Using modal views nonmodal and vice versa  </A>
 </UL>

<P>
 <LI><A HREF="#OTHER" NAME="I_OTHER">Other views</A>
 <UL>
   <LI><A HREF="#OTHER_RULER" NAME="I_OTHER_RULER">Rulers</A>
   <LI><A HREF="#OTHER_OBJVIEW" NAME="I_OTHER_OBJVIEW">ObjectView - for structured graphics</A>
 </UL>

<P>
 <LI><A HREF="#NEWWIDGETS" NAME="I_NEWWIDGETS">Creating your own views</A>
<PRE>
   to be written ...
</PRE>

<P>
 <LI><A HREF="#MVC2" NAME="I_MVC2">Model-View-Controller operation again</A>
 <UL>
 <LI><A HREF="#MVC2_BUTTONS" NAME="I_MVC2_BUTTONS">Buttons, Toggles etc. with a model</A>
 <LI><A HREF="#MVC2_EDITFIELD" NAME="I_MVC2_EDITFIELD">EditFields with a model</A>
 <LI><A HREF="#MVC2_TEXTV" NAME="I_MVC2_TEXTV">TextViews with a model</A>
 <LI><A HREF="#MVC2_SELLISTV" NAME="I_MVC2_SELLISTV">SelectionInListViews with a model</A>
 <LI><A HREF="#MVC2_COMPLEX_MODELS" NAME="I_MVC2_COMPLEX_MODELS">Complex models </A>
<PRE>
  more to be written ...
</PRE>
 </UL>

<P>
 <LI><A HREF="#APPS" NAME="I_APPS">Applications and TopView control</A>
 <UL>
 <LI><A HREF="#APPS_WINDOWMODES" NAME="I_APPS_WINDOWMODES">Window Modes</A>
 <LI><A HREF="#APPS_MULTIPLETOP" NAME="I_APPS_MULTIPLETOP">Controlling Multiple TopViews</A>
 <LI><A HREF="#APPS_EVENTFLUSHING" NAME="I_APPS_EVENTFLUSHING">Flushing Events for an Application</A>
 </UL>

<P>
 <LI><A HREF="#DEMOVIEW_SETUP" NAME="I_DEMOVIEW_SETUP">Demo View Setup</A>

<P>
 <LI><A HREF="#DRAWING" NAME="I_DRAWING">Smalltalks drawing model</A>
 <UL>
   <LI><A HREF="#COORDINATES" NAME="I_COORDINATES">Drawing coordinates</A>
   <LI><A HREF="#DRAWING_PAINT" NAME="I_DRAWING_PAINT">The paint color</A>
   <LI><A HREF="#DRAWING_LINES" NAME="I_DRAWING_LINES">Drawing lines</A>
   <LI><A HREF="#DRAWING_RECTANGLES" NAME="I_DRAWING_RECTANGLES">Rectangles</A>
   <LI><A HREF="#DRAWING_ARCS" NAME="I_DRAWING_ARCS">Arcs, ellipses &amp; circles</A>
   <LI><A HREF="#DRAWING_POLYGONS" NAME="I_DRAWING_POLYGONS">Polygons</A>
   <LI><A HREF="#DRAWING_STRINGS" NAME="I_DRAWING_STRINGS">Strings</A>
   <LI><A HREF="#DRAWING_BITMAPS" NAME="I_DRAWING_BITMAPS">Bitmaps &amp; images</A>
   <LI><A HREF="#FILLING_RECTANGLES" NAME="I_FILLING_RECTANGLES">Filled rectangles</A>
   <LI><A HREF="#FILLING_ARCS" NAME="I_FILLING_ARCS">Filled arcs, ellipses &amp; circles</A>
   <LI><A HREF="#FILLING_POLYGONS" NAME="I_FILLING_POLYGONS">Filled polygons</A>
   <LI><A HREF="#DRAWING_OPQ" NAME="I_DRAWING_OPQ">Opaque drawing</A>
   <LI><A HREF="#DRAWING_OPQ_STRINGS" NAME="I_DRAWING_OPQ_STRINGS">Opaque strings</A>
   <LI><A HREF="#DRAWING_OPQ_BITMAPS" NAME="I_DRAWING_OPQ_BITMAPS">Opaque bitmaps</A>
   <LI><A HREF="#DRAWING_IMAGEPAINT" NAME="I_IMAGEPAINT">Using bitmaps as paint</A>
   <LI><A HREF="#DRAWING_LINESTYLE" NAME="I_DRAWING_LINESTYLE">Line styles</A>
   <LI><A HREF="#DRAWING_LINEWIDTH" NAME="I_DRAWING_LINEWIDTH">Line width</A>
   <LI><A HREF="#DRAWING_JOINSTYLE" NAME="I_DRAWING_JOINSTYLE">Join styles</A>
   <LI><A HREF="#DRAWING_CAPSTYLE" NAME="I_DRAWING_CAPSTYLE">Cap styles</A>
   <LI><A HREF="#DRAWING_TRANSFORMATION" NAME="I_DRAWING_TRANSFORMATION">Transformations</A>
 </UL>

<P>
<LI><A HREF="#COLORS" NAME="I_COLORS">Colors</A>

<P>
<LI><A HREF="#FONTS" NAME="I_FONTS">Fonts</A>

<P>
 <LI><A HREF="#CURSORS" NAME="I_CURSORS">Cursors</A>

<P>
 <LI><A HREF="#EVENTS" NAME="I_EVENTS">Events</A>
 <UL>
   <LI><A HREF="#EVENTS_TYPES" NAME="I_EVENTS_TYPES">Event types</A>
   <LI><A HREF="#EVENTS_ENABLING" NAME="I_EVENTS_ENABLING">Enabling/disabling events</A>
   <LI><A HREF="#EVENTS_FORWARDING" NAME="I_EVENTS_FORWARDING">Event forwarding: delegates and controllers</A>
   <LI><A HREF="#EVENTS_SENDING" NAME="I_EVENTS_SENDING">Sending events to other (alien) views</A>
   <LI><A HREF="#EVENTS_LISTENING" NAME="I_EVENTS_LISTENING">Event listening</A>
   <LI><A HREF="#EVENTS_FLUSHING" NAME="I_EVENTS_FLUSHING">Flushing events</A>
 </UL>

<P>
 <LI><A HREF="#MULTISCREEN" NAME="I_MULTISCREEN">Handling multiple screens</A>
 <LI><A HREF="#TROUBLEGUIDE" NAME="I_TROUBLEGUIDE">Trouble Guide</A>
</UL>




<H2><A HREF="#I_INTRO" NAME="INTRO">Introduction</A></H2>

This document presents a way of quickly starting to use
the <CITE>ST/X</CITE> View &amp; Widget classes.
It consists of tutorial text and code fragments to present
some starting points.
Of course, its far from being complete.
<P>
Learning <CITE>'by doing'</CITE> is usually much better
than <CITE>'by reading manuals'</CITE>.
<BR>
Therefore,
it is suggested that you best learn by creating your own little goodies,
taking existing code as an example
(i.e. copy some code which creates a view looking similar to what you need,
and modify/enhance it step by step).
<P>
In the fileBrowser, the examples below can be selected and evaluated using
<A HREF="../overview/editing.html#POPUPMENU"><CITE>doit</CITE></A> from the menu
  or by typing
<A HREF="../overview/editing.html#EXECUTING"><KBD>"<B>CMD-d</B>"</KBD></A>
 on the keyboard.
<BR>
If you are looking at this text using a HTML reader (Mosaic, netscape etc.),
copy the code fragments from the viewer and
<A HREF="../overview/editing.html#EDITING">paste</A>
them into a workspace. Then select and execute it there.
<BR>
Finally, if you read it via the smalltalk documentation reader,
some code fragments can be directly executed by clicking on them.
Executable code is marked with a different color, as in:
<PRE><CODE onclick="StxExample">
<A TYPE="example">
	Transcript flash
</A>
</CODE></PRE>
<P>
Read the text and the example code,
try to understand what's going on,
execute the example and
play around with the parameters
(i.e. get the code into a workspace, modify it and execute it again).
<P>
Each example  provides you some new information based on the previous ones, thus
together providing step by step lessions.
For beginners, it does not make sense to skip examples.
Read the text, and execute the corresponding examples in sequence.
<P>
Also, look into the actual code implementing the used functionality.
Do so by opening a  <A HREF="../tools/sbrowser/TOP.html">SystemBrowser</A>
and inspect the code.
Since the examples only cover a fraction of the full functionality,
this reading may also lead to more advanced uses of some classes.
<BR>
Especially have a look at the classes' documentation and examples which are found in
the class protocol under the <CITE>documentation</CITE> category.
<P>
As a side effect, you will also learn how to find your way through the system using
the various search functions in the browser.
<P>
Close all example views using the window manager.



<H3><A HREF="#I_MVC" NAME="MVC">Model-View-Controller vs. Callback Operation</A></H3>

Traditionally, in <CITE>Smalltalk</CITE>, the graphical user interface was
built upon the <CITE>Model-View-Controller (MVC)</CITE> mechanism.
<BR>
This means that the user interfacing is done by three distinct components:
<UL>
<LI>the model
<BR>
which is the object being shown in a view,
<P>
<LI>the view
<BR>
which is responsible to present the models state graphically,
<P>
<LI>the controller
<BR>
which interacts with the user, provides menus, and handles mouse actions
</UL>

<P>

In contrast, many non-smalltalk user interfaces (for example: Motif, Xtoolkit etc)
are based upon a callback model of operation.
Here, a widget also contains controller functionality, and often has a tight
relation to the data being represented (i.e. the model).
User actions (such as press of a button) are forwarded via a callback function
to the application.

<P>

In <CITE>Smalltalk/X</CITE>, widgets can be used both with and without
a model. To provide both compatibility to existing smalltalk setups AND
beginners an easier start, both mechanisms are supported.
<BR>
For simple widgets, there is usually no need to define or create
a model; instead, the operation of the widget can be controlled by giving it
an actionBlock which is evaluated on user interaction.
<P>
In the following, we will start by describing  the non-MVC operation.
<BR>
MVC operation is described in <A HREF="#MVC2">more detail</A> in a section below.




<H2><A HREF="#I_TOPVIEWS" NAME="TOPVIEWS">TopViews</A></H2>

  In <CITE>Smalltalk/X</CITE>, most visible User Interface (UI) elements are derived from
  a common superclass, called <CODE>View</CODE>.
A view can have subviews, and each of these subviews
  has this view as their common superview.
<BR>
The one view in such a hierarchy, which has no superview,
is called a <VAR>topview</VAR>.
Topviews are the outermost views, which usually get decorated by labels
and borders by your X-window manager.
<P>
Notice for the curious:
<BLOCKQUOTE>
<VAR>Topviews</VAR> also have a special place in <CITE>ST/X</CITE>
with respect to event handling:
<BR>
a topView together with all of its
subviews are handled by one process within <CITE>ST/X</CITE> and will
usually be served from one shared event queue.
<BR>
This means, that within such a so called <VAR>windowGroup</VAR>
execution is normally not parallel.
(However, with some tricks,
you can arrange for subviews to be put into separate windowgroups.)
</BLOCKQUOTE>

  Let us create &amp; show our first view:
<BR>
(click on the code-line below, or copy it to the workspace,
and execute it with the <VAR>doIt</VAR>-function)

<A TYPE="example">
<PRE><CODE>
  (View new) open "create a view, and make it show itself"
</CODE></PRE>
</A>

  The above code performs two steps:
<UL>
<LI><CODE>View new</CODE>
<BR>
- asks the <CODE>View</CODE>-class for a new instance of itself;
<CODE>View</CODE> will create one, initialize it and return it.
<P>
<LI><CODE>open</CODE>
<BR>
- tells the returned view to display itself. We will not discuss the
individual actions now. Roughly, it will create
a windowGroup for the view, start an event handling process for it
and finally make the view visible on the screen.
</UL>
<P>
  Instances of this (general) view-class do not support icons and window-labels.
There is a specialized class, called <CODE>StandardSystemView</CODE>,
which was written exactly for that purpose.
Usually, all of your topviews should be instances of this class,
or of a subclass of it.
<BR>
Although it is possible to use any view as a topView (as was done in the
above example and will be done later for demonstration purposes),
applications should use an instance of <CODE>StandardSystemView</CODE>
as the topView.
<BR>
Changing the above example to use <CODE>StandardSystemView</CODE>:

<A TYPE="example">
<PRE><CODE>
  (StandardSystemView new) open "create a view, and make it show itself"
</CODE></PRE>
</A>

opens a view with a (default) label and a (default) icon.


<H3><A HREF="#I_TOP_MODES" NAME="TOP_MODES">Modeless vs. Modal Open</A></H3>

In the above example, the newly created view was opened by sending it the
<CODE>open</CODE> message. This creates a new process and made the view
independent of the currently running process.
<BR>
  It can also be opened under control of the current process with:
<PRE><CODE>
    v openModal (where v is the view)
</CODE></PRE>
If opened this way, the currently executing process will not get control
until the view is closed. Modal opening is typically done for dialogs which have
to be finished before operation of the main view is to be continued.
<BR>

Your application views should normally run as a separate process (except, if its
some kind of dialog box. If nonmodal, errors occuring in it will not
affect the process which created and opened your view.
<P>

Internally, there are two open messages which are understood by views:
<PRE><CODE>
	openModeless
</CODE></PRE>
and
<PRE><CODE>
	openModal
</CODE></PRE>

Each view <VAR>knows</VAR> what is the most useful way of opening itself,
and the general
<PRE><CODE>
    v open
</CODE></PRE>
is redefined according to that.
<BR>
(i.e. sending <CODE>#open</CODE> to a <CODE>StandardSystemView</CODE> will open
it modeless, while sending it to some Dialogbox opens it modal).
<P>
Therefore, you usually do not have to take care of this yourself,
just use <CODE>#open</CODE> for all
views (of course, there could be applications where this is not true,
there you should use
an explicit <CODE>#openModal</CODE> or <CODE>#openModeless</CODE>).

<P>
When a view is opened, all of its subviews (we will shortly learn more on this)
are opened with it - however, all under control of the single windowGroup
process. There is no need to open all views individually.
<BR>
However, it is possible to arrange for subviews to be
<A HREF="#LAYOUT_INVISIBLE">initially invisible</A>.
<P>
See more below in the <A HREF="#APPS_WINDOWMODES">"Window Modes"</A>-chapter.



<H3><A HREF="#I_TOP_LABELS" NAME="TOP_LABELS">Window labels, Icons &amp; Titles</A></H3>

Lets see how a standardSystemViews can be decorated.
The following defines the views window label, its icon and an icon label.
(Not all windowmanagers show this icon label, though):

<A TYPE="example">
<PRE><CODE>
  |v|
  v := StandardSystemView new.                        "create new topview"
  v label:'Hello World'.                              "set its window-label"
  v icon:(Image fromFile:'../../goodies/bitmaps/gifImages/balloon_tiny.gif'). "set its icon"
  v iconLabel:'world'.                                "set its iconlabel"
  v open                                              "- bring it up"
</CODE></PRE>
</A>

  Just to see the difference, try (read on before doing it):

<A TYPE="example">
<PRE><CODE>
  |v|
  v := StandardSystemView new.
  v label:'Hello World'.
  v icon:(Image fromFile:'clients/Demos/bitmaps/hello_world.icon').
  v iconLabel:'world'.
  v openModal                                         "- bring it up modal"
</CODE></PRE>
</A>

  and find out, that the interaction with this view is lost
  until the helloview is closed. However, you can still interact with other
  topviews. Close the hello-view with the window manager.
<BLOCKQUOTE>
Notice:
<BR>
For reasons not to be explained here, the above is not
exactly true for the documentation viewer;
Its actions are performed in a separate process and are not affected
by a modalBox being modal)
</BLOCKQUOTE>
<P>
There is currently no <CITE>ST/X</CITE> icon editor available,
but you can create and edit
bitmaps using <CITE>X</CITE>'s bitmap tools,
or any other icon editor provided by your system.
(<CITE>ST/X</CITE> supports many different image formats:
<CITE>XBM</CITE>, <CITE>XPM</CITE>, SUN-<CITE>ICON</CITE> , Windows &amp; OS/2's
   <CITE>BMP</CITE> formats, <CITE>GIF</CITE>, <CITE>face</CITE>
and even <CITE>TIFF</CITE> and <CITE>Targa</CITE> formats).
<P>
  The following demonstrates this with a nice icon:

<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v label:'Hello World'.
    v icon:((Image fromFile:'goodies/bitmaps/gifImages/garfield.gif') magnifiedTo:64 @ 64).
    v iconLabel:'world'.
    v open
</CODE></PRE>
</A>

Hint:
<BR>
You should use black&amp;white images for icons, since some
displays do not support color images.
Althought <CITE>ST/X</CITE> does convert the image to
black&amp;white, on these displays, this may not look too pretty for some images.

<A NAME="TOP_ICONIFY"></A>
<P>
By the way: you can programatically force iconification and deiconification
of a topView, by sending it a <CODE>#collapse</CODE> or <CODE>#expand</CODE>
message.
<BR>
For example:
<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v label:'Hello World'.
    v icon:((Image fromFile:'goodies/bitmaps/gifImages/garfield.gif') magnifiedTo:64 @ 64).
    v iconLabel:'world'.
    v open.

    Delay waitForSeconds:5.
    v collapse.

    Delay waitForSeconds:5.
    v expand.
</CODE></PRE>
</A>

<A NAME="TOP_ICONIFIED"></A>
You can also force a topView to be started as icon:
<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v label:'Hello World'.
    v icon:((Image fromFile:'goodies/bitmaps/gifImages/garfield.gif') magnifiedTo:64 @ 64).
    v iconLabel:'world'.
    v openIconified.
</CODE></PRE>
</A>

or force it to be opened at a particular position
(instead of whatever the windowManagers default is):
<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v label:'Hello World'.
    v icon:((Image fromFile:'goodies/bitmaps/gifImages/garfield.gif') magnifiedTo:64 @ 64).
    v iconLabel:'world'.
    v openAt:100@100.
</CODE></PRE>
</A>
Notice: it has been reported, that some window managers ignore this,
and always position the topView or always ask the user to provide a
frame for it.



<H2><A HREF="#I_DIMENSIONS" NAME="DIMENSIONS">Window Dimensions &amp; Position</A></H2>

A view will come up in its default dimension (i.e. <VAR>extent</VAR>),
which is defined in the classes <CODE>defaultExtent</CODE>-method.
For <CODE>StandardSystemView</CODE>, the default value is
<CODE>640 @ 400</CODE> (read as: "<VAR>640 pixels wide and 400 pixels high</VAR>"),
<BR>
for normal (non-topViews) views the default is
<CODE>100 @ 100</CODE> (which is also normally not what you want).

<P>
You can change a views extent with:
<PRE><CODE>
    v extent:(400 @ 300)
</CODE></PRE>
  or (better style !) in a device independent way, with:
<PRE><CODE>
    v extent:(Display pixelPerMillimeter * (20 @ 10)) rounded
</CODE></PRE>

Now you see, why <VAR>opening</VAR> is a separate action from view creation:
you can change
all these settings before the view is visible - otherwise you would get quite some
visible action on your display! Ttry changing the extent after the open.

<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v label:'Hello World'.
    v icon:(Image fromFile:'clients/Demos/bitmaps/hello_world.icon').
    v iconLabel:'world'.
    v extent:(400 @ 300).                        "- set its extent"
    v open
</CODE></PRE>
</A>

a topviews extent is normally under control of the window system.
This means, that the window manager lets the user specify
the size of the view (however, some window managers show the view immediately).
<BR>
In any case, you can set some limits, which the window system should
honor:

<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v label:'try to resize me'.
    v extent:(300 @ 300).
    v maxExtent:(600 @ 600).
    v minExtent:(200 @ 200).
    v open
</CODE></PRE>
</A>
  you already thought this: a fix size is done with:

<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v label:'no way to resize me'.
    v extent:(300 @ 300).
    v maxExtent:(300 @ 300).
    v minExtent:(300 @ 300).
    v open
</CODE></PRE>
</A>

In order to understand the following examples,
we have to make a little excursion,
and learn how to create subviews.
<BR>
Any view can have subviews; these are either created right from the start in
their superView,
<BR>
as in:
<PRE><CODE>
    ...
    topView := StandardSystemView new.
    ...
    subView := View in:topView.
    ...
    topView open.
    ...
</CODE></PRE>
or created without a superview relationship at first, and later
placed into another view (the <CITE>ST-80</CITE> style),
as in:
<PRE><CODE>
    ...
    topView := StandardSystemView new.
    ...
    subView := View new.
    ...
    topView add:subView.
    ...
    topView open.
    ...
</CODE></PRE>
the two mechanisms are almost identical
<A HREF="#FN1" NAME="BACK_FN1">(*)</A>,
choose whichever is more convenient.
<P>


A views position is called <VAR>origin</VAR> and is specified much like
its extent. Be prepared, that most window managers simply ignore the given
origin for topViews - either placing it somewhere on the screen, or asking
the user to position the view by showing a ghostline.
<BR>

<H3><A HREF="#I_DIM_FIXED" NAME="DIM_FIXED">Fixed Size</A></H3>


  You can specify view position and dimension both in pixels (as above) or
  relative to the superviews size. If the coordinate(s) in a <CODE>#origin:</CODE>,
  <CODE>#extent:</CODE> or <CODE>#corner:</CODE>  message is an integer,
it is interpreted as pixels.
  If its a float or fraction, its value should be between 0.0 and 1.0 and
  is interpreted as that fraction of the superviews size.
<BR>
An example with pixel extents is:

<A TYPE="example">
<PRE><CODE>
    |v sub1 sub2|

    v := StandardSystemView new.
    v extent:300 @ 300.

    sub1 := Button in:v.
    sub1 label:'button1'.
    sub1 origin:10 @ 10.
    sub1 extent:100 @ 100.

    sub2 := Button in:v.
    sub2 label:'button2'.
    sub2 origin:10 @ 120.
    sub2 extent:100 @ 100.

    v open
</CODE></PRE>
</A>

many views offer more convenient instance creation methods,
in which the dimension and/or additional attributes can be specified.
<BR>
Using such a combination message, the above becomes:

<A TYPE="example">
<PRE><CODE>
    |v sub1 sub2|

    v := StandardSystemView extent:300 @ 300.

    sub1 := Button label:'button1' in:v.
    sub1 origin:10 @ 10 extent:100 @ 100.

    sub2 := Button label:'button2' in:v.
    sub2 origin:10 @ 120 extent:100 @ 100.

    v open
</CODE></PRE>
</A>

Have a look at a views class protocol in the browser to get a feeling
of what is provided.
<P>
Hint:
<BLOCKQUOTE>
You do <STRONG>not</STRONG> have to learn and use those;
you can always use individual messages to get the same effect.
<BR>
Especially beginners should not confuse themselves by trying to learn
all of this protocol by heart in the beginning.
</BLOCKQUOTE>

Instead of specifying an extent, you can also specify the position
of the lower-right corner point:

<A TYPE="example">
<PRE><CODE>
    |v sub1 sub2|

    v := StandardSystemView extent:300 @ 300.

    sub1 := Button label:'button1' in:v.
    sub1 origin:10 @ 10 corner:110 @ 110.

    sub2 := Button label:'button2' in:v.
    sub2 origin:10 @ 120 corner:110 @ 210.

    v open
</CODE></PRE>
</A>

Due to rounding errors when pixel coordinates are computed,
it is generally better to use <CODE>#origin:corner:</CODE> messages instead of
<CODE>#origin:extent:</CODE>, when multiple subviews are to be placed into
some frame view.
<BR>
Examine the following code, and think what happens if the topView is opened-with
or resized-to to an odd number 99 pixels:
<PRE><CODE>
    |top sub1 sub2|

    top := StandardSystemView extent:100@100.
    top viewBackground:Color black.

    sub1 := View in:top.
    sub1 viewBackground:Color red.
    sub1 origin:0 @ 0 extent:0.5 @ 1.0.

    sub2 := View in:top.
    sub2 viewBackground:Color yellow.
    sub2 origin:0.5 @ 0 extent:0.5 @ 1.0.

    top open
</CODE></PRE>
in this case, a one pixel wide fragment of the topViews black viewBackground will
be visible at the right border.
<P>
With relative corners, this problem is avoided; however, the second view
may be one pixel wider:
<PRE><CODE>
    |top sub1 sub2|

    top := StandardSystemView extent:100@100.
    top viewBackground:Color black.

    sub1 := View in:top.
    sub1 viewBackground:Color red.
    sub1 origin:0 @ 0 corner:0.5 @ 1.0.

    sub2 := View in:top.
    sub2 viewBackground:Color yellow.
    sub2 origin:0.5 @ 0 corner:1.0 @ 1.0.

    top open
</CODE></PRE>


<P>
Most views compute a reasonable default extent when first created;
for buttons, this default is based upon the label given.
<BR>
If you do not set the extent, this (view specific) default is used:

<A TYPE="example">
<PRE><CODE>
    |v sub1 sub2|

    v := StandardSystemView new.
    v extent:300 @ 300.

    sub1 := Button label:'button1' in:v.
    sub1 origin:10 @ 10.

    sub2 := Button label:'button2' in:v.
    sub2 origin:10 @ 120.

    v open
</CODE></PRE>
</A>

(you should read on, at least up to the chapter on panels, if you
 do not like the placement of the buttons in the above example)
<P>

<H3><A HREF="#I_DIM_RELATIVE" NAME="DIM_RELATIVE">Relative Size</A></H3>

If a component is given as a fraction or float number,
it is interpreted as relative to its superviews size.
The value should be within 0.0 .. 1.0, for reasonable results
<BR>
(you can specify a view to be larger than its superview - in this case,
 only part of the view will be visible; depending on its origin).
<P>
An example with relative extents is:

<A TYPE="example">
<PRE><CODE>
    |v sub1 sub2|

    v := StandardSystemView extent:300 @ 300.

    sub1 := Button label:'button1' in:v.
    sub1 origin:0.1 @ 0.1.
    sub1 extent:0.8 @ 0.4.

    sub2 := Button label:'button2' in:v.
    sub2 origin:0.1 @ 0.5.
    sub2 extent:0.4 @ 0.4.

    v open
</CODE></PRE>
</A>

It is possible and often useful to combine a relative dimension with a pixel value.
<BR>
here is an example which defines a relative width, but absolute pixel heights:

<A TYPE="example">
<PRE><CODE>
    |v sub1 sub2|

    v := StandardSystemView extent:300 @ 300.

    sub1 := Button label:'button1' in:v.
    sub1 origin:0.1 @ 0.1.
    sub1 extent:0.8 @ 100.

    sub2 := Button label:'button2' in:v.
    sub2 origin:0.1 @ 0.5.
    sub2 extent:0.4 @ 100.

    v open
</CODE></PRE>
</A>

If you resize these topviews, the subviews position and/or dimensions
will be adjusted automatically.
<P>

If you specify a relative extent for a topview,
its extent is computed relative to the screen size:

<A TYPE="example">
<PRE><CODE>
    |v|
    v := StandardSystemView new.
    v origin:(0.25 @ 0.25).
    v corner:(0.75 @ 0.75).
    v open
</CODE></PRE>
</A>

  creates a topview with half-width and half-height of the sceen.
  (Notice, that some window managers insist on letting the user specify
   the origin of the view - thus the origin argument may be ignored on
   some systems).



<H3><A HREF="#I_DIM_COMPUTED" NAME="DIM_COMPUTED">Dynamically Computed Size</A></H3>

  The most flexible way of specifying dimensions is by passing a
  <VAR>computation rule</VAR> as a block.
  This block is supposed to return the new value as a point
  (again: either in pixels or relative).
<BR>
  You can do arbitrary complex size computations in these blocks.
  The block will be (re)evaluated whenever the superviews size changes.
<BR>
  Example:
<BR>
(ignore the button details here - it will be described later.
<BR>
Concentrate on the <CODE>origin:</CODE> and <CODE>corner:</CODE>-stuff):

<A TYPE="example">
<PRE><CODE>
    |top b goodHeight|

    top := StandardSystemView new.
    top extent:(200 @ 200).

    b := Button label:'hello' in:top.

    goodHeight := b preferredExtent y.

    b origin:(10 @ 10).
    b corner:[ (top width - 10) @ (10 + goodHeight) ].

    top open.
</CODE></PRE>
</A>

notice that we first ask the button about what it thinks is a good height
(based upon the fonts height) and remember this height.
Thus the button will have a fixed height, combined with a variable width.
<P>
  If you base your computation on some other subviews position or size,
  you should keep in mind that those blocks are evaluated in the order
  in which the subviews were created within the superview.
<BR>
  Therefore, subview creation order may have an influence on the layout.
<BR>
  Example:
<BR>
(uses the first buttons corner when computing the origin of the second button)

<A TYPE="example">
<PRE><CODE>
    |top b1 b2 h1 h2|

    top := StandardSystemView new.
    top extent:(200 @ 200).

    b1 := Button in:top.
    b1 label:'hello'.
    h1 := b1 preferredExtent y.
    b1 origin:(10 @ 10).
    b1 corner:[ (top width // 2 - 5) @ (10 + h1) ].

    b2 := Button in:top.
    b2 label:'wow'.
    h2 := b2 preferredExtent y.
    b2 origin:[ (b1 corner x + 5) @ 10 ].
    b2 corner:[ (top width - 10) @ (10 + h2) ].

    top open.
</CODE></PRE>
</A>

  the following example demonstrates the effect of the evaluation order
  and will not work correctly:
<BR>
  (because <CODE>b2</CODE>'s rule-block will always be evaluated
before <CODE>b1</CODE>'s rule,
   while <CODE>b2</CODE> depends on the value computed in <CODE>b1</CODE>'s rule.
<BR>
Thus the old corner of <CODE>b1</CODE> will be used in the computation of
<CODE>b2</CODE>'s origin.)

<A TYPE="example">
<PRE><CODE>
    |top b1 b2 h1 h2|

    top := StandardSystemView new.
    top extent:200 @ 200.

    b2 := Button label:'wow' in:top.
    h2 := b2 height.
    b2 origin:[(b1 corner x + 5) @ 10].
    b2 corner:[(top width - 10) @ (10 + h2)].

    b1 := Button label:'hello' in:top.
    h1 := b1 height.
    b1 origin:(10 @ 10).
    b1 corner:[(top width // 2 - 5) @ (10 + h1)].

    top open.
</CODE></PRE>
</A>

Hint:
<BLOCKQUOTE>
     You can force evaluation of these blocks (i.e. simulating
     a size-change) by sending <CODE>#sizeChanged:nil</CODE> to the superview or
     <CODE>#superViewChangedSize</CODE> to the view itself.
</BLOCKQUOTE>

Hint:
<BLOCKQUOTE>
     Although you can also specify the extent as <VAR>relative extent</VAR>
     it is not wise to do so, since rounding errors may lead to
     off-by-one pixel errors (for example, specifying a width of
     0.5 for two side-by-side views, will produce a one-pixel
     error if the superviews width has an odd number of pixels.
     This possibly leads to an ugly looking layout, where views overlap
     or are not aligned correctly).
<BR>
     In contrast, <VAR>relative corners</VAR> do not show this problem
     and will produce a good looking
     result; of course, one of the views will be smaller by one pixel
     in this case.
</BLOCKQUOTE>

Hint:
<BLOCKQUOTE>
     In many cases, a block is not really required. If combined with
     insets (as described below), most layouts can be specified using
     relative sizes.
<BR>
     Also, have a look at the layout views (<CODE>HorizontalPanelView</CODE>
     and <CODE>VerticalPanelView</CODE>; these should solve most typical
     arrangements without a need to setup complicated dimension blocks.
</BLOCKQUOTE>



<H3><A HREF="#I_DIM_LAYOUT" NAME="DIM_LAYOUT">Layout Objects</A></H3>

In addition to the above, you can also let some other object
control the dimension of a view.
These objects are called <VAR>layout objects</VAR>,
and are asked to provide a size much like the blocks described above.
Actually, sizing blocks and layout object can simulate each other;
 they are comparable in the functionality they provide.
 Having both is due to historical reasons - blocks were first, and layout objects
 were added later for compatibility reasons,
 These two mechanisms may be mapped onto one internal mechanism in future versions.
<BR>
Layout objects have been added to make porting of <CITE>VW</CITE> applications
easier, since in this system, these are used to control a views dimension
(you will find quite a lot of PD code, using these layout objects).
<P>
As a basic framework, some layout classes are already provided with the system,
but you can  of course add your own ones for special requirements.
The classes already available are:
<UL>
<LI>LayoutOrigin
<BR>
controls a subviews origin only. The extent will be the subviews
preferred extent. The origin can be specified as relative, absolute or
combined (relative plus offset).
<BR>
A LayoutOrigin object specifies a components position by
<CITE>leftFraction</CITE>, <CITE>topFraction</CITE>,
<CITE>leftOffset</CITE> and <CITE>topOffset</CITE>.
<BR>
The fractional parts are relative to the superviews size, the offsets are
interpreted as pixels and added.
<BR>
Thus, a LayoutOrigin without fractional parts is equivalent to specifying
a subviews origin in pixels - a LayoutOrigin without offsets is equivalent
to specifying it relative.
<BR>
(i.e. the standard <CODE>origin:</CODE> settings can also be represented
by layoutOrigins)


<P>
<LI>AlignmentOrigin
<BR>
like above, but allows an arbitrary point in the view to be aligned,
while a LayoutOrigin always aligns the top-left of a component.
(for example, to place views centered along a line)

<P>
<LI>LayoutFrame
<BR>
controls both origin and corner. Either relative, absolute or combined.
</UL>

<P>
It may be confusing, having another mechanism in addition to the previously
described origin/corner methods. There are two reasons for having layout objects:
<UL>
<LI>they are somewhat more flexible and (when new layout objects are created)
can be more powerful.
<LI>they are used in ST-80 and provided here for compatibility
</UL>

<P>
Lets see some examples; to place three buttons aligned along a vertical row,
we could write:

<A TYPE="example">
<PRE><CODE>
    |top b1 b2 b3|

    top := StandardSystemView new.
    top label:'3 buttons'.
    top extent:200 @ 200.

    b1 := Button label:'button1'.
    b1 layout:(LayoutOrigin new
			leftFraction:0.25;
			topFraction:0.0).
    top add:b1.

    b2 := Button label:'butt2'.
    b2 layout:(LayoutOrigin new
			leftFraction:0.25;
			topFraction:(1/3)).
    top add:b2.

    b3 := Button label:'this is button3'.
    b3 layout:(LayoutOrigin new
			leftFraction:0.25;
			topFraction:(2/3)).
    top add:b3.

    top open
</CODE></PRE>
</A>

however, if these have different width, you may want to align
them along their horizontal centers (instead of their left borders):

<A TYPE="example">
<PRE><CODE>
    |top b1 b2 b3|

    top := StandardSystemView new.
    top label:'3 buttons'.
    top extent:200 @ 200.

    b1 := Button label:'button1'.
    b1 layout:(AlignmentOrigin new
			leftFraction:0.5;
			topFraction:0.0;
			leftAlignmentFraction:0.5;
			topAlignmentFraction:0.0).
    top add:b1.

    b2 := Button label:'butt2'.
    b2 layout:(AlignmentOrigin new
			leftFraction:0.5;
			topFraction:(1/3);
			leftAlignmentFraction:0.5;
			topAlignmentFraction:0.0).
    top add:b2.

    b3 := Button label:'this is button3'.
    b3 layout:(AlignmentOrigin new
			leftFraction:0.5;
			topFraction:(2/3);
			leftAlignmentFraction:0.5;
			topAlignmentFraction:0.0).
    top add:b3.

    top open
</CODE></PRE>
</A>

the above left the size as preferred by the buttons;
a layoutFrame controls both origin and extent:

<A TYPE="example">
<PRE><CODE>
    |top b1 b2 b3|

    top := StandardSystemView new.
    top label:'3 buttons'.
    top extent:200 @ 200.

    b1 := Button label:'button1'.
    b1 layout:(LayoutFrame new
			leftFraction:0.25;
			topFraction:0.0;
			rightFraction:0.75;
			bottomFraction:(1/3)).
    top add:b1.

    b2 := Button label:'butt2'.
    b2 layout:(LayoutFrame new
			leftFraction:0.25;
			topFraction:(1/3);
			rightFraction:0.75;
			bottomFraction:(2/3)).
    top add:b2.

    b3 := Button label:'this is button3'.
    b3 layout:(LayoutFrame new
			leftFraction:0.25;
			topFraction:(2/3);
			rightFraction:0.75;
			bottomFraction:1).
    top add:b3.

    top open
</CODE></PRE>
</A>
finally, you can add offsets (in pixels);
these fixed numbers are added to the views border position
after the relative computation.
These allow shifting a border and combining relative with
absolute values:

<A TYPE="example">
<PRE><CODE>
    |top b1 b2 b3|

    top := StandardSystemView new.
    top label:'3 buttons'.
    top extent:200 @ 200.

    b1 := Button label:'button1'.
    b1 layout:(LayoutFrame new
			leftFraction:0.25;
			topFraction:0.0;
			topOffset:5;
			rightFraction:0.75;
			bottomFraction:(1/3);
			bottomOffset:-5).
    top add:b1.

    b2 := Button label:'butt2'.
    b2 layout:(LayoutFrame new
			leftFraction:0.25;
			topFraction:(1/3);
			topOffset:5;
			rightFraction:0.75;
			bottomFraction:(2/3);
			bottomOffset:-5).
    top add:b2.

    b3 := Button label:'this is button3'.
    b3 layout:(LayoutFrame new
			leftFraction:0.25;
			topFraction:(2/3);
			topOffset:5;
			rightFraction:0.75;
			bottomFraction:1;
			bottomOffset:-5).
    top add:b3.

    top open
</CODE></PRE>
</A>

Choose whichever layout specification fits your applications
needs best;
however, if you plan for portability with <CITE>VisualWorks</CITE>,
(or are used to <CITE>VW</CITE>), you may prefer to use layout objects.
<P>

Note:
<BR>
The offsets in a layout are much like the insets, which will be described
below. However, offsets always shift the affected border down/right.
In contrast, insets always shift towards the center.
<P>
Note:
<BR>
Of course, you can define your own layout class, which computes
any dimension you like. This may be useful for special arrangements.



<H2><A HREF="#I_GENERAL" NAME="GENERAL">General View Appearance</A></H2>

A views appearance consists of many paramaters,
<UL>
<LI>border color
<LI>border width
<LI>view background color or pattern
<LI>3D level
</UL>
to name some. In general, if using existing widgets for your application,
you should not specify these explicit, but depend on the default values,
which are provided by a so called <VAR>styleSheet</VAR>.
<BR>
Doing so makes it possible to change the appearance of <CITE>ST/X</CITE>
applications and make these applications fit nicely into existing frameworks.


<H4><A HREF="#I_LAYOUT_STYLES" NAME="LAYOUT_STYLES">Do not Fight the Style Sheet</A></H4>

The headline already says it: do not hardcode any style settings into
your code. (It used to be so in previous versions of <CITE>ST/X</CITE>
and took alot of hard work to make it more flexible - don't repeat my bugs).
<P>
In situations, where the default values are not acceptable,
read the value from the styleSheet (after all, its nothing more than
a table of name&lt;->value associations). For example, if you have
a button which you think should show itself in red color, do not
hardcode <CODE>Color red</CODE> into your application.
Instead, use something like:
<PRE><CODE>
    StyleSheet colorAt:'mySpecialButtonsColor' default:Color red
</CODE></PRE>
so others can add an entry to the styleSheet(s):
<PRE><CODE>
    ...
    mySpecialButtonsColor       Color green
    ...
</CODE></PRE>
This avoids <VAR>dictating</VAR> your personal style onto other users.
<BR>
(all <CITE>ST/X</CITE> classes cache these values in class variables,
 and/or read them at view creation time into a views instance variable.
 This avoids repeated lookups for those values)

<P>
As always, there are some exceptions to the above rule. For example,
the default border for views is 1-pixel of black in the <VAR>normal</VAR>
(i.e. non 3D) style. If you want to use a simple view for grouping (as described below),
you usually do not want a border to be visible.
In this case, you can set the border explicit to zero.


<H3><A HREF="#I_LAYOUT" NAME="LAYOUT">Layout of Subviews</A></H3>

<H4><A HREF="#I_LAYOUT_SUBVIEWS" NAME="LAYOUT_SUBVIEWS">Using Simple Subviews for Layout</A></H4>


Typical applications consist of many elements which have to be organized
into topviews. The following chapter describes how subviews are
arranged and how to control the geometric layout.
<P>
  For very simple layouts, use just another subview, as in:

<A TYPE="example">
<PRE><CODE>
    |top frame1 frame2|

    top := StandardSystemView label:'two views'.
    top extent:300@300.

    frame1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:top.
    frame2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:top.

    top open
</CODE></PRE>
</A>

(please read on, if you think the example does not work ...)
<BR>
Notice, that the origin and corners are given as floating point
(i.e. rational) numbers in the range [0..1].
In this case, they are interpreted as fraction of the superviews extent.
<P>
<STRONG>Remember:</STRONG>
<BLOCKQUOTE>
<UL>
<LI>integer values are interpreted in pixel,

<LI>rationals as <VAR>relative to the superviews size</VAR>

<LI>blocks are evaluated at resize time and should return an integer or rational
which is taken in pixel or relative respectively.
</UL>
</BLOCKQUOTE>
When doing your first experiments, you may run into trouble
when erroneously using <CODE>"1"</CODE> instead of <CODE>"1.0"</CODE> as
a dimension in the extent or corner parameter.



<H3><A HREF="#I_LAYOUT_THREED" NAME="LAYOUT_THREED">3D Level, Border &amp; Background</A></H3>

  You did NOT see the subviews in the above example, because all have the same background, and
  no border around (non-3D styles will show a border though).
  For some 3D effect, you can make views "come out-of" or "go-into" the display, by setting its
  Z-level relative to the superView.
<BR>
  As in:

<A TYPE="example">
<PRE><CODE>
    |top frame1 frame2|

    top := StandardSystemView label:'two views'.
    top extent:300@300.

    frame1 := View origin:(0.1 @ 0.1) corner:(0.9 @ 0.5) in:top.
    frame2 := View origin:(0.1 @ 0.6) corner:(0.9 @ 0.9) in:top.

    frame1 level:-1.
    frame2 level:-1.

    top open
</CODE></PRE>
</A>

  or:

<A TYPE="example">
<PRE><CODE>
    |top frame1 frame2|

    top := StandardSystemView label:'two views'.
    top extent:300@300.

    frame1 := View origin:(0.1 @ 0.1) corner:(0.9 @ 0.9) in:top.
    frame2 := View origin:(0.25 @ 0.25) corner:(0.75 @ 0.75) in:frame1.

    frame1 level:2.
    frame2 level:-2.

    top open
</CODE></PRE>
</A>

On non 3D view styles (see configuration), the level is ignored.
Here you can try:

<A TYPE="example">
<PRE><CODE>
    |top frame1 frame2|

    top := StandardSystemView label:'two views'.
    top extent:300@300.

    frame1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:top.
    frame2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:top.

    frame1 viewBackground:(Color grey:50).
    frame2 viewBackground:(Color red:75 green:75 blue:25).

    top open
</CODE></PRE>
</A>

Which also shows us how to use colors, and how a views background color is defined.
<P>
By the way:
<BR>
the values given to <CODE>#grey:</CODE>
and <CODE>#red:green:blue:</CODE> are interpreted in percent,
<BR>
thus:
<PRE><CODE>
    Color red:100 green:100 blue:0
</CODE></PRE>
is yellow;
while:
<PRE><CODE>
    Color grey:25
</CODE></PRE>
is some darkish grey.
<BR>
For the standard colors, there are also shorter messages,
such as "<CODE>Color red</CODE>", "<CODE>Color blue</CODE>" etc.
<P>
For those used to <CITE>ST-80</CITE>,
a compatibility class called <CODE>ColorValue</CODE> is provided
which expects fractional arguments; thus you can also write
<PRE><CODE>
    ColorValue red:1.0 green:1.0 blue:0.0
</CODE></PRE>
and
<PRE><CODE>
    ColorValue brightness:0.25
</CODE></PRE>
Here, the arguments are in [0..1].
<P>
  On black&amp;white displays, Smalltalk has a hard time to try to get colors onto the screen - of
  course. But at least it does its best it can (it will put a grey pattern, corresponding to
  the colors brightness into the view).
<BR>
On greyscale displays, a grey color corresponding to the colors brightness
will be used.
<P>
Thus, you really do not have to care for which type of display your
program will eventually run on. However, when designing your application,
you should keep in mind that others may have displays with less capabilities
than yours and the colors may be replaced by greyscales.
<BR>
Never depend only on colors for highlighting or marking.
For example, red-on-green may produce a good contrast on your color screen,
but may not be visible on your friends greyscale or black&amp;white display.



<H3><A HREF="#I_LAYOUT_BGPATTERN" NAME="LAYOUT_BGPATTERN">... and Background Pattern</A></H3>

Aaah, before I forget, not only colors can be defined as background;
have a look at:

<A TYPE="example">
<PRE><CODE>
    |top frame1 frame2|

    top := StandardSystemView label:'two views'.
    top extent:300@300.

    frame1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:top.
    frame2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:top.

    frame1 viewBackground:(Image fromFile:'goodies/bitmaps/gifImages/garfield.gif').
    frame2 viewBackground:(Image fromFile:'clients/Demos/bitmaps/hello_world.icon').

    top open
</CODE></PRE>
</A>

Notice, that "<CODE>Image fromFile:</CODE>" is able to find out the file format
itself.
The first image in the
above example is a depth-8 GIF encoded palette image,
while the second is a monochrome bitmap in
  sun-icon file format.
<BR>
  More formats are supported (TIFF, XBM, XPM, XWD, ST80-Form,
Face, Targa and Windows-bitmap).
  Also notice, that the above example works on any kind of display:
on monochrome or greyscale
  displays, the image will be converted to some useful approximation (dithered).
<P>
  Of course, the bitmaps can also be specified directly in your code
(but, it is always better,
to load them from a file - thereby allowing for more flexibility):

<A TYPE="example">
<PRE><CODE>
    |top|

    top := StandardSystemView label:'a pattern'.
    top extent:200@100.

    top viewBackground:(Form width:8
			     height:8
			     fromArray:#(2r11001100
					 2r00110011
					 2r11001100
					 2r00110011
					 2r11001100
					 2r00110011
					 2r11001100
					 2r00110011)).
    top open
</CODE></PRE>
</A>

  or:

<A TYPE="example">
<PRE><CODE>
    |top|

    top := StandardSystemView label:'smile'.
    top extent:200@100.

    top viewBackground:(Form width:12
			     height:11
			     fromArray:#(
					 2r00000000 2r0000
					 2r00000000 2r0000
					 2r11000110 2r0000
					 2r11000110 2r0000
					 2r00000000 2r0000
					 2r00011000 2r0000
					 2r00011000 2r0000
					 2r00011000 2r0000
					 2r01000010 2r0000
					 2r01100110 2r0000
					 2r00111100 2r0000)).
    top open
</CODE></PRE>
</A>

  As you see, constant bitmaps are defined in chunks of 8 pixels, left to right.
<P>
  You can specify a colormap to be used with monochrome mitmaps too:

<A TYPE="example">
<PRE><CODE>
    |top bitmap|

    top := StandardSystemView label:'smile red/yellow'.
    top extent:200@100.

    bitmap := (Form width:12
		   height:11
		fromArray:#(
			    2r00000000 2r0000
			    2r00000000 2r0000
			    2r11000110 2r0000
			    2r11000110 2r0000
			    2r00000000 2r0000
			    2r00011000 2r0000
			    2r00011000 2r0000
			    2r00011000 2r0000
			    2r01000010 2r0000
			    2r01100110 2r0000
			    2r00111100 2r0000)).
    bitmap colorMap:(Array with:Color red        "to be used for 0-bits"
			   with:Color yellow).    "used for 1-bits"

    top viewBackground:bitmap.
    top open
</CODE></PRE>
</A>

  Just to show what is possible, try the following
  (buttons and insets will be explained below in detail):

<A TYPE="example">
<PRE><CODE>
    |v b granite wood|

    granite := (Image fromFile:'libwidg3/bitmaps/granite.tiff').
    wood := (Image fromFile:'libwidg3/bitmaps/woodH.tiff').

    v := StandardSystemView label:'rock solid &amp; wooden'.
    v extent:300@300.
    v viewBackground:granite.

    b := Button label:'quit' in:v.
    b backgroundColor:wood.
    b activeBackgroundColor:wood.
    b enteredBackgroundColor:wood.

    b action:[v destroy].

    b origin:(0.5 @ 0.5).
    b leftInset:(b width // 2) negated.
    b topInset:(b height // 2) negated.
    v open.
</CODE></PRE>
</A>

In the previous example, another message (#backgroundColor:) was
used to change the buttons background color. To understand this,
let us first understand what the viewBackground is:
whenever a view is exposed or resized, the newly visible areas
are automatically filled with the viewBackground color (or pattern).
Later, the redraw handling method will actually draw any foreground
(text, images or whatever) when the exposure event arrives.
<BR>
Some views make a difference between the viewBackground, and the background
with which the contents is drawn -  for example, a button might want its
edges to be drawn in grey (and therefore defines a viewBackground of grey),
but its label-background to be drawn in another color. To allow this,
button (and some others) define an additional method, called #backgroundColor:,
which changes the color with which the contents is drawn.
<BR>
Here is such a button:
<A TYPE="example">
<PRE><CODE>
    |v b|

    v := StandardSystemView label:'viewBackground vs. backgroundColor'.
    v extent:400@300.

    b := Button label:'bg blue' in:v.
    b origin:0@0 corner:50@50.
    b viewBackground:Color blue.
    b backgroundColor:Color blue.

    b := Button label:'bg blue / vb grey' in:v.
    b origin:60@0 corner:110@50.
    b viewBackground:Color grey.
    b backgroundColor:Color blue.

    v open.
</CODE></PRE>
</A>

The default #backgroundColor: (implemented in a common view superclass)
sets the viewBackground.
<P>

Sometimes, you want to change the viewBackground of a complete views hierarchy
(i.e. of a view with all of its subviews). A concrete example is ST/X's
aboutBox, which changes the topViews background to some darkish grey
(and - of course - want all components viewBackgrounds to be also changed).
<BR>
To do this, use #allViewBackground:, which walks down a views hierachy,
changing all viewbackgrounds:
<A TYPE="example">
<PRE><CODE>
    |v l b t|

    v := StandardSystemView label:'viewBackground'.
    v extent:400@300.

    l := Label label:'label' in:v.
    l origin:5@5 corner:100@50.

    b := Button label:'button' in:v.
    b origin:5@60 corner:100@110.

    t := ScrollableView for:TextView in:v.
    t origin:110@5 corner:(1.0@1.0).
    t contents:'hello, this is some text

foo
bar
baz
'.
    v allViewBackground:(Color grey:30).
    v open.
</CODE></PRE>
</A>



<H3><A HREF="#I_LAYOUT_INSET" NAME="LAYOUT_INSET">Inset</A></H3>

Lets go back to view geometry.
You can also specify a so called <VAR>inset</VAR> on the views
corners, given in pixels.
If set to non-zero, the views dimension is reduced by these insets
(there are four of them)
after any dimension calculation (i.e. after the relative sizes are computed).
Positive insets reduce the size, negative insets increase the size of
the view at that corner.
<BR>
This allows you to create views where the extent is based on the
superviews size (i.e. relative), but offset by some fix margin.
<P>
Notice, that insets combined with a relative dimension provide exactly the same
functionality as provided by layout objects - so you should better use them right
away. However, in many situations, insets are easier to use (especially if you are
a beginner) and will still be supported for backward compatibility in the future.

<P>
For example, to create 2 subviews which take half of the superviews width,
AND have some constant 4-millimeter margin in between, use:

<A TYPE="example">
<PRE><CODE>
    |top sub1 sub2 mm|

    mm := Display verticalPixelPerMillimeter rounded.

    top := StandardSystemView label:'two views'.
    top extent:300@300.

    sub1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:top.
    sub1 level:-1.
    sub1 bottomInset:(mm * 2).

    sub2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:top.
    sub2 level:-1.
    sub2 topInset:(mm * 2).

    top open
</CODE></PRE>
</A>

or:
<BR>
(have a careful look at the labels definition - the insets
 have negative values ...)

<A TYPE="example">
<PRE><CODE>
    |top sub1 sub2 lbl mm|

    mm := Display verticalPixelPerMillimeter rounded.

    top := StandardSystemView label:'wow'.
    top extent:300@300.

    sub1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:top.
    sub1 level:-1.
    sub1 allInset:mm.
    sub1 bottomInset:mm // 2.


    sub2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:top.
    sub2 level:-1.
    sub2 allInset:mm.
    sub2 topInset:mm // 2.
    sub2 bottomInset:mm * 10.

    lbl := Label label:'info:' in:top.
    lbl adjust:#left.
    lbl level:-1.
    lbl origin:(0.0 @ 1.0) corner:(1.0 @ 1.0).
    lbl allInset:mm.
    lbl topInset:(mm * 9) negated.

    top open
</CODE></PRE>
</A>

HINT:
<BR>
As shown in the above example, negative insets are useful to place some view
at the bottom or at the right of its superview,
and you want a constant distance from that edge.
For example, the instance/class toggles in the browser could be
created this way (the inset is choosen so that the toggles are always at
the bottom):

<A TYPE="example">
<PRE><CODE>
    |frame toggleI toggleC hI hC|

    frame := View new.
    frame extent:(300 @ 100).

    toggleI := Toggle label:'instance' in:frame.
    toggleC := Toggle label:'class' in:frame.
    "
     get the default (preferred) heights before changing
     the extent ...
    "
    hI := toggleI height.
    hC := toggleC height.

    "
     now set the origin to the corner to the bottom
     (actually shrinking their height to 0 temporarily)
    "
    toggleI origin:(0.0 @ 1.0) corner:(0.5 @ 1.0).
    toggleC origin:(0.5 @ 1.0) corner:(1.0 @ 1.0).

    "
     finally, set their top-inset to have them
     appear at their preferred height from the bottom line
    "
    toggleI topInset:(hI negated).
    toggleC topInset:(hC negated).

    frame open.
</CODE></PRE>
</A>

Without negative insets, a somewhat complicated block
would be needed to compute the origin and size of those toggles
(taking care of round-off errors, odd sizes and borders ...)
<P>
All of the above are impossible to setup using only relative dimensions.
<P>
Of course, an alternative is to use panels. These will be described below
in detail.

<H3><A HREF="#I_LAYOUT_VIEW" NAME="LAYOUT_VIEW">Layout views</A></H3>

<H3><A HREF="#I_LAYOUT_LABELS" NAME="LAYOUT_LABELS">Labels</A></H3>

The simplest of the layout views is a label.
Labels simply present a string or bitmap image.
<BR>
example:

<A TYPE="example">
<PRE><CODE>
    |top l1 l2|

    top := StandardSystemView new.
    top extent:200@200.

    l1 := Label new.
    l1 label:'hello'.
    l1 origin:0.0 @ 0.0 corner:1.0 @ 0.5.
    top add:l1.

    l2 := Label new.
    l2 label:(Image fromFile:'libtool/bitmaps/SBrowser.xbm').
    l2 origin:0.0 @ 0.5 corner:1.0 @ 1.0.
    top add:l2.

    top open
</CODE></PRE>
</A>

in the above, the attributes of the labels were set individually,
for didactic reasons; to save you some typing, there are
also combination messages:

<A TYPE="example">
<PRE><CODE>
    |top l1 l2|

    top := StandardSystemView extent:200@200.

    l1 := Label label:'hello' in:top.
    l1 origin:0.0 @ 0.0 corner:1.0 @ 0.5.

    l2 := Label label:(Image fromFile:'libtool/bitmaps/SBrowser.xbm') in:top.
    l2 origin:0.0 @ 0.5 corner:1.0 @ 1.0.

    top open
</CODE></PRE>
</A>

The default label uses a level of 0 and no border in all 3D
viewStyles and a borderWidth of 1 in non 3D styles.
<BR>
In the above example, the labels real boundaries can be made visible,
by setting their levels:

<A TYPE="example">
<PRE><CODE>
    |top l1 l2|

    top := StandardSystemView extent:200@200.

    l1 := Label label:'hello' in:top.
    l1 origin:0.0 @ 0.0 corner:1.0 @ 0.5.
    l1 level:-1.

    l2 := Label label:(Image fromFile:'libtool/bitmaps/SBrowser.xbm') in:top.
    l2 origin:0.0 @ 0.5 corner:1.0 @ 1.0.
    l2 level:-1.

    top open
</CODE></PRE>
</A>

<H4><A NAME="LAYOUT_LABELS_ADJUST">Positioning the Labels Contents</A></H4>

A labels default layout strategy is to place its logo centered in
its viewing area. You can control this by setting its <VAR>adjust</VAR>;
possible values are <CODE>#left</CODE>, <CODE>#right</CODE>,
<CODE>#center</CODE> (which is the default) or <CODE>#fit</CODE>.
<BR>
For example:

<A TYPE="example">
<PRE><CODE>
    |top l1 l2|

    top := StandardSystemView extent:200@200.

    l1 := Label label:'hello' in:top.
    l1 origin:0.0 @ 0.0 corner:1.0 @ (1/3).
    l1 adjust:#left.
    l1 level:-1.

    l2 := Label label:(Image fromFile:'libtool/bitmaps/SBrowser.xbm') in:top.
    l2 origin:0.0 @(1/3) corner:1.0 @ (2/3).
    l2 adjust:#right.
    l2 level:-1.

    l2 := Label label:(Image fromFile:'libtool/bitmaps/SBrowser.xbm') in:top.
    l2 origin:(1/3) @ (2/3) corner:(2/3) @ 1.0.
    l2 allInset:5.
    l2 adjust:#fit.
    l2 level:-1.

    top open
</CODE></PRE>
</A>

<P>

Since labels are often used to display some changing information string
(such as a current pathname), it may happen that the string is too
large to fit into the label.
To support this, labels offer special
adjusts which switch between a <VAR>center</VAR> adjust and one of <VAR>right</VAR>
or <VAR>left</VAR> adjust, depending on the strings size.
(this makes sense, with path names, where the right part is usually the
more interesting).
<BR>
See what happens when you resize the following view (horizontically):

<A TYPE="example">
<PRE><CODE>
    |top l1 l2 l3|

    top := StandardSystemView extent:100@150.

    l1 := Label label:'a very, very long label; could be a pathname' in:top.
    l1 origin:0.0 @ 0.0 corner:1.0 @ (1/3).
    l1 adjust:#centerRight.

    l2 := Label label:'a name or other string, where the left is more interesting' in:top.
    l2 origin:0.0 @ (1/3) corner:1.0 @ (2/3).
    l2 adjust:#centerLeft.

    l3 := Label label:'some other long label, with the default layout' in:top.
    l3 origin:0.0 @ (2/3) corner:1.0 @ 1.0.

    top open
</CODE></PRE>
</A>

here, the first two strings are centered as long as they fits the views bounds,
but displayed right/left adjusted if they do not.
<P>
As with other views, you can change the labels 3D appearance, border and viewBackground.
<P>
Additionally, you can change the foreground and background color
of the label.
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |top l|

    top := StandardSystemView extent:100@100.

    l := Label label:(Image fromFile:'libtool/bitmaps/SmalltalkX.xbm') in:top.
    l origin:0.2 @ 0.2 corner:0.8 @ 0.8.
    l foregroundColor:(Color green);
      backgroundColor:(Color grey:20).
    l level:-1.
    top open
</CODE></PRE>
</A>

Hint:
<BLOCKQUOTE>
To avoid confusing the user, you should not use positive levels for labels,
since they then look like buttons.
</BLOCKQUOTE>



<H3><A HREF="#I_LAYOUT_PANELS" NAME="LAYOUT_PANELS">Panels</A></H3>


Often, you need to arrange many little subviews (Buttons, Labels etc.) in a view,
and have them automatically rearrange, when the superview changes its size.

<H4><A HREF="#I_LAYOUT_HVPANELS" NAME="LAYOUT_HVPANELS">Horizontal and vertical panels </A></H4>

To do so, use one of <CODE>PanelView</CODE>,
<CODE>HorizontalPanelView</CODE> and <CODE>VerticalPanelView</CODE>.
<BR>
These layout views are preferrably used, if multiple fixed size elements
have to be arranged into a row or column, and the size of the panel
itself is no fixed (i.e. some rearrangement is required).
<P>
Panels differ in the arrangement preference:
<BR>
<CODE>VerticalPanelView</CODE> always arranges its elements
top-to-bottom.
<CODE>HorizontalPanelView</CODE>
always arranges left-to-right.
<BR>
Finally, the general <CODE>PanelView</CODE> arranges
from top-left to bottom-right.
<BR>
Try:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 300.

    panel := VerticalPanelView origin:(0.0 @ 0.0)
			       corner:(1.0 @ 1.0)
				   in:top.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

(I hope you already know some Smalltalk, to understand this ... :-)
<P>
By default, the panel centers its elements with some 1mm (millimeter)
spacing between the
elements (try resizing the view). If they do not fit, the spacing is reduced.
If they still do not fit, some elements may not be visible. Try resizing the
view to see how elements get (re)arranged.

<H5><A HREF="#I_LAYOUT_LAYOUT" NAME="LAYOUT_LAYOUT">Specifying how elements are arranged</A></H5>

  You can arrange elements different as in:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 400.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel verticalLayout:#top.  "not centered, but at top"

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

You can specify
<CODE>#top</CODE>,
<CODE>#topSpace</CODE>,
<CODE>#bottom</CODE>,
<CODE>#bottomSpace</CODE>,
<CODE>#center</CODE>,
<CODE>#spread</CODE>,
<CODE>#spreadSpace</CODE>,
<CODE>#fit</CODE>
or
<CODE>#fitSpace</CODE> as layout strategy.
<P>
<UL>
<LI><CODE>#top</CODE> arranges elements at the top;
<LI><CODE>#bottom</CODE> at the bottom;
<LI><CODE>#center</CODE> places elements centered;
<LI><CODE>#spread</CODE> spreads them equally;
<LI><CODE>#fit</CODE> resizes the elements to fill the panel completely.
</UL>

The additional <CODE>#xxxSpace</CODE> layouts
behave basically like their corresponding nonSpace layouts,
but start with a spacing (i.e. <CODE>#top</CODE> positions the first element
right at the top border, while <CODE>#topSpace</CODE> leaves some spacing
between the top border and the first element).
<P>
There are some more (obscure) layouts
(<CODE>#fixLeft</CODE> and <CODE>#leftFit</CODE>);
see the panel classes documentation for more info on these.
<P>
Try:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 300.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel verticalLayout:#fit.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

Try the above with <CODE>#fit</CODE> replaced by any other layout and
see the difference.
<P>
With the exception of the <CODE>#fit</CODE> layouts, a panel will leave
its elements extents unchanged - i.e. the elements should either provide a
reasonable preferredExtent or be sized correctly by the program.
<BR>
In contrast, the <CODE>#fit</CODE> layouts ignore the elements extent,
and force its size to fit the panel.
<P>
The twin of the <CODE>VerticalPanelView</CODE> is the
<CODE>HorizontalPanelView</CODE>, which offers the
same layout strategies, but does things horizontally.

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:550 @ 100.

    panel := HorizontalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalLayout:#spread.  "not centered, but at evenly distributed"

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

The layouts supported by <CODE>HorizontalPanelView</CODE> are
<CODE>#left</CODE>,
<CODE>#leftSpace</CODE>,
<CODE>#right</CODE>,
<CODE>#rightSpace</CODE>,
<CODE>#center</CODE>,
<CODE>#spread</CODE>,
<CODE>#fit</CODE>.
and
<CODE>#leftFit</CODE>.
<P>
The following gives a nice example of how powerful those settings
can be used and combined:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 500.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalLayout:#fitSpace.
    panel verticalLayout:#fitSpace.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	(Button label:thisLabel in:panel) adjust:#fit
    ].
    top open.
</CODE></PRE>
</A>

(However, notice that font scaling is a slow operation on most displays;
 therefore consider the above example a non realistic demo)

<P>
Finally, the general <CODE>PanelView</CODE> arranges multiple rows,
but is currently not able to have the layout specified as detailed as above.
It simply fills itself with the elements starting top-left to
bottom-right.:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 100.

    panel := PanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

<H5><A HREF="#I_LAYOUT_SPACING" NAME="LAYOUT_SPACING">Specifying the spacing between elements</A></H5>


For horizontal and vertical panels,
you can specify the horizontal layout to be different from the
vertical layout;
also, the spacing between elements can be changed
in both horizontal and vertical directions.
<P>
More examples.
<BR>
change the space between elements:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 100.

    panel := PanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalSpace:0.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

  or:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 100.

    panel := PanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalSpace:0.
    panel verticalSpace:0.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

  Of course, you can put any kind of view into a panel:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:160 @ 200.

    panel := PanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalSpace:5.
    panel verticalSpace:10.

    #('one' 'two' 'three' 'four' 'five')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].

    (Label label:'label1' in:panel) level:-1.
    (Label label:'label2' in:panel) level:1.
    Toggle label:'toggle1' in:panel.

    View extent:50@10 in:panel.    "just an empty view"

    #('six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

  Adding empty views allows grouping:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'buttons'.
    top extent:350 @ 100.

    panel := HorizontalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalSpace:0.

    #('one' 'two' 'three')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].

    View extent:30@10 in:panel.    "just a separator"

    #('four' 'five')
    do:[:thisLabel |
	Toggle label:thisLabel in:panel
    ].

    View extent:30@10 in:panel.    "just a separator"

    #('six' 'seven' 'eight')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

combining a layout of <CODE>#fit</CODE> with an empty spacing,
gives you dense packing:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 300.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel verticalLayout:#fit.
    panel verticalSpace:0.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	Button label:thisLabel in:panel
    ].
    top open.
</CODE></PRE>
</A>

in a vertical panel, you can still control horizontal sizes of the elements
(and vice versa). Try:

<A TYPE="example">
<PRE><CODE>
    |top panel|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 300.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel verticalLayout:#fit.
    panel verticalSpace:0.

    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	|button|

	button := Button label:thisLabel in:panel.
	button width:1.0.
    ].
    top open.
</CODE></PRE>
</A>

Usually, you would want to do something with those buttons later,
so better keep them around somewhere in a variable- as in:

<A TYPE="example">
<PRE><CODE>
    |top panel buttons|

    top := StandardSystemView label:'many buttons'.
    top extent:100 @ 300.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    buttons := OrderedCollection new.
    #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten')
    do:[:thisLabel |
	buttons add:(Button label:thisLabel in:panel)
    ].
    top open.

    (buttons at:5) disable.
    (buttons at:4) action:[(buttons at:5) enable].
    (buttons at:5) action:[(buttons at:5) disable].
</CODE></PRE>
</A>

Can you imagine, what this does ? (try to find out before starting it :-)
<P>

You will find more examples in the classes' example category.
<P>


<H5><A HREF="#I_LAYOUT_CONFLICTS" NAME="LAYOUT_CONFLICTS">Layout conflicts</A></H5>

There are some situations, in which a panels layout strategy fails.
One example is when you specify a <CODE>#fit</CODE> layout
(i.e. tell the panel to resize elements for tight packing)
AND specify a relative extent for
an element (i.e. tell the element to resize itself).
<BR>
In this setup, it is not defined which geometry will finally be taken,
since it depends on the order in which resizing operations are performed.
<BR>
Bad example:

<A TYPE="example">
<PRE><CODE>
    |top panel b|

    top := StandardSystemView label:'bad button '.
    top extent:200 @ 200.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalLayout:#fit.

    b := Button label:'hello' in:panel.
    b extent:(0.5 @ 40).

    top open.
</CODE></PRE>
</A>

In the above, the button will show up with a half size (as expected),
but will change its size to full when the topView is first resized.
<P>
another bad example:

<A TYPE="example">
<PRE><CODE>
    |top panel b|

    top := StandardSystemView label:'bad button '.
    top extent:200 @ 200.

    panel := VerticalPanelView
		origin:(0.0 @ 0.0)
		corner:(1.0 @ 1.0)
		in:top.

    panel horizontalLayout:#fit.
    panel verticalLayout:#fit.

    b := Button label:'hello' in:panel.
    b width:1.0.

    top open.
</CODE></PRE>
</A>

here the trouble is less obvious, since we only assign a new width,
which is 1.0 and should therefore not conflict with the panels decisions.
However, the <CODE>#width:</CODE> method (currently) also changes the height
back to the buttons preferred height.
Therefore, the button will show its default height when mapped the first time.
After resizing the topView, the panel correctly recomputes the height and
the button will be shown in full size (as expected).
<BR>
This seems to be a little bug in the <CODE>#width:</CODE> method
and may be fixed in future versions.
<P>
For now, do not set relative or computed extents in elements
if the panel has a resizing layout (such as <CODE>#fit</CODE>).


<H4><A HREF="#I_LAYOUT_VARPANELS" NAME="LAYOUT_VARPANELS">Variable panels</A></H4>


Finally, there are panels, which allow variable relative sizes:
the <CODE>VariableHorizontalPanel</CODE> and
  <CODE>VariableVerticalPanel</CODE>.
Most browsers use these to allow for a variable ratio between
their selection list and their codeview.
<BR>
Try:

<A TYPE="example">
<PRE><CODE>
    |top panel subview1 subview2|

    top := StandardSystemView label:'hello'.
    top extent:400@400.

    panel := VariableVerticalPanel origin:(0.0 @ 0.0)
				   corner:(1.0 @ 1.0)
				       in:top.

    subview1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:panel.
    subview2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:panel.

    subview1 viewBackground:Color red.
    subview2 viewBackground:(Image fromFile:'goodies/bitmaps/gifImages/garfield.gif').
    top open
</CODE></PRE>
</A>

  you may want to add some 3D effects, as in:

<A TYPE="example">
<PRE><CODE>
    |top panel subview1 subview2|

    top := StandardSystemView label:'hello'.
    top extent:400@400.

    panel := VariableVerticalPanel origin:(0.0 @ 0.0)
				   corner:(1.0 @ 1.0)
				       in:top.

    subview1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:panel.
    subview2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:panel.
    subview1 level:-1.
    subview2 level:-1.
    top open
</CODE></PRE>
</A>

  or (just a try):

<A TYPE="example">
<PRE><CODE>
    |top panel subview1 subview2|

    top := StandardSystemView label:'hello'.
    top extent:400@400.

    panel := VariableVerticalPanel origin:(10 @ 10)
				   corner:[(top width - 10) @ (top height - 10)]
				       in:top.

    subview1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:panel.
    subview2 := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:panel.
    panel level:3.
    subview1 level:-1.
    subview2 level:-1.
    top open
</CODE></PRE>
</A>

Although not being very beautiful, the above example shows how a views corner can also be given by a
<VAR>computation rule</VAR>.
Whenever the topView is resized, the subview will recompute its corner,
  by evaluating the corner-block. This also works for origin and extent.
Using blocks as rules provides a most powerful and flexible way to specify view
dimensions.
<P>
Variable panels require their subviews to have relative origins and
corners (or extends). If you want to add constant size subviews, you
have to use (currently) a helper view:
<BR>
See:

<A TYPE="example">
<PRE><CODE>
    |top panel helper subview1 subview2 subview3|

    top := StandardSystemView label:'hello'.
    top extent:400@400.

    panel := VariableVerticalPanel origin:(0.0 @ 0.0)
				   corner:(1.0 @ 1.0)
				       in:top.

    subview1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.5) in:panel.
    subview1 viewBackground:Color red.

    helper := View origin:(0.0 @ 0.5) corner:(1.0 @ 1.0) in:panel.
    subview2 := View origin:(0.0 @ 0.0) corner:(1.0 @ 20) in:helper.
    subview2 viewBackground:Color green.
    subview3 := View origin:(0.0 @ 20) corner:(1.0 @ 1.0) in:helper.
    subview3 viewBackground:Color blue.

    subview1 level:-1.
    helper level:-1.
    top open
</CODE></PRE>
</A>

to show a more complex example,
the following puts constant height button panels in between
the variable size views:

<A TYPE="example">
<PRE><CODE>
    |top panel helper1 subjectview helper2
     buttonPanel1 buttonPanel2 letterview b|

    top := StandardSystemView label:'Mail'.

    panel := VariableVerticalPanel
		origin:(0.0 @ 0.0) corner:(1.0 @ 1.0) in:top.

    helper1 := View origin:(0.0 @ 0.0) corner:(1.0 @ 0.4) in:panel.

    buttonPanel1 := HorizontalPanelView
			origin:(0.0 @ 0.0) corner:(1.0 @ 40) in:helper1.
    buttonPanel1 horizontalLayout:#leftSpace.

    b := Button label:'delete' in:buttonPanel1.
    b := Button label:'new mail' in:buttonPanel1.
    (View in:buttonPanel1) extent:30@1; borderWidth:0; level:0. "for spacing"
    b := Button label:'exit' in:buttonPanel1.
    b action:[top destroy].

    subjectview := ScrollableView for:SelectionInListView in:helper1.
    subjectview origin:(0.0 @ 40) corner:(1.0 @ 1.0).
    subjectview list:#('letter1' 'letter2' 'letter3' '...' 'last letter').

    helper2 := View origin:(0.0 @ 0.4) corner:(1.0 @ 1.0) in:panel.
    buttonPanel2 := HorizontalPanelView
			origin:(0.0 @ 0.0) corner:(1.0 @ 40) in:helper2.
    buttonPanel2 horizontalLayout:#leftSpace.
    b := Button label:'reply' in:buttonPanel2.
    b := Button label:'print' in:buttonPanel2.

    letterview := ScrollableView for:TextView in:helper2.
    letterview origin:(0.0 @ 40) corner:(1.0 @ 1.0).

    top open
</CODE></PRE>
</A>

<H3><A HREF="#I_LAYOUT_INVISIBLE" NAME="LAYOUT_INVISIBLE">Invisible views</A></H3>

If no special precaution is made, all of a views subviews are made visible
(<CITE>realized</CITE>) whenever that view is made visible.
This default behavior relieves you from the need to walk over all subcomponents
and realize them individually.
However, in some situations, it may be desirable,
to hide individual views; either initially or dynamically during interaction
with the application.
<BR>
A view can be hidden (at any time) by sending it <CODE>#beInvisible</CODE>
and made visible again by <CODE>#beVisible</CODE>.
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
     |top topFrame check list|

     top := StandardSystemView new.
     top extent:150@400.
     topFrame := VerticalPanelView origin:0.0@0.0 corner:1.0@0.4 in:top.
     topFrame horizontalLayout:#leftSpace.

     topFrame add:(check := CheckBox label:'hidden').
     check pressAction:[list beInvisible].
     check releaseAction:[list beVisible].

     list := ScrollableView for:SelectionInListView.
     list origin:0.0@0.4 corner:1.0@1.0.
     list list:#('foo' 'bar' 'baz').
     top add:list.

     check turnOn.
     list beInvisible.

     top open
</CODE></PRE>
</A>

Invisible views do not react to any user events; if you need response to
button or keyboard events in a hidden views display area,
you have to place an instance of InputView there. These special views are
transparent, and cannot be drawn into. However, all user events are processed
as usual; these are typically delegated to some other object.

Example:

<A TYPE="example">
<PRE><CODE>
     |top topFrame check list inputOnly eventReceiver|

     top := StandardSystemView new.
     top extent:150@400.
     topFrame := VerticalPanelView origin:0.0@0.0 corner:1.0@0.4 in:top.
     topFrame horizontalLayout:#leftSpace.

     topFrame add:(check := CheckBox label:'covered').
     check pressAction:[list lower].
     check releaseAction:[list raise].

     list := ScrollableView for:SelectionInListView.
     list origin:0.0@0.4 corner:1.0@1.0.
     list list:#('foo' 'bar' 'baz').
     top add:list.

     eventReceiver := Plug new.
     eventReceiver respondTo:#handlesButtonPress:inView:
			with:[:button :view | true].
     eventReceiver respondTo:#buttonPress:x:y:view:
			with:[:button :x :y :view | check turnOff. list raise].

     inputOnly := InputView origin:0.0@0.4 corner:1.0@1.0 in:top.
     inputOnly delegate:eventReceiver.
     check turnOn.

     top open
</CODE></PRE>
</A>

The above is an artificial example, InputViews main use is to cover complete
application views to catch all incoming events
(for example, in window builder like applications).


<H3><A HREF="#I_LAYOUT_HIDDEN" NAME="LAYOUT_HIDDEN">Stacked views</A></H3>

It is possible to stack muliple subviews views onto each other and, depending
on some external event, choose which one should be visible.
The easiest way to do this is to simply define each of them as having the
same origin/corner, and raise one of them to the front.
<P>
Example (this examples uses elements which will be explained later - simply
concentrate on the view creation and the raise-message sent
from the buttons):

<A TYPE="example">
<PRE><CODE>
    |top viewStack buttonPanel sub1 sub2|

    top := StandardSystemView label:'really two views'.
    top extent:300 @ 350.

    buttonPanel := HorizontalPanelView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 50)
			in:top.
    (Button label:'view1' action:[sub1 raise] in:buttonPanel).
    (Button label:'view2' action:[sub2 raise] in:buttonPanel).

    viewStack := View
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:top.
    viewStack topInset:(buttonPanel height).

    sub1 := TextView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:viewStack.
    sub1 contents:'Hello, I am the TextView (sub1)'.

    sub2 := ClockView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:viewStack.

    top open
</CODE></PRE>
</A>

Of course, the subviews dimensions and positions can be arbitrary
(however, except in noteStack-like applications, it does not make much
sense to NOT align the views).
<BR>
as in:

<A TYPE="example">
<PRE><CODE>
    |top viewStack buttonPanel sub1 sub2 sub3|

    top := StandardSystemView new.
    top extent:300 @ 350.

    buttonPanel := HorizontalPanelView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 50)
			in:top.
    (Button label:'view1' action:[sub1 raise] in:buttonPanel).
    (Button label:'view2' action:[sub2 raise] in:buttonPanel).
    (Button label:'view3' action:[sub3 raise] in:buttonPanel).

    viewStack := View
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:top.
    viewStack topInset:(buttonPanel height).

    sub1 := TextView
		    origin:(0.1 @ 0.1)
		    corner:(0.75 @ 0.75)
			in:viewStack.
    sub1 contents:'Hello, I am the TextView (sub1)'.
    sub1 level:0; borderWidth:1.

    sub2 := ClockView
		    origin:(0.25 @ 0.25)
		    corner:(0.9 @ 0.9)
			in:viewStack.
    sub2 level:0; borderWidth:1.

    sub3 := View
		    origin:(0.2 @ 0.2)
		    corner:(0.8 @ 0.8)
			in:viewStack.
    sub3 viewBackground:Color red.
    sub3 level:0; borderWidth:1.

    top open
</CODE></PRE>
</A>

If you want to implement noteStack-like applications, you can use the
event delegation mechanism, to catch events and raise when clicked-upon.
<P>

Since different view classes have different default-borders and 3D
levels, you may have to set these explicit in this kind of application.
The following example adds some
more fancy stuff to the above demo. (notice, that each subview comes with
its correct middleButtonMenu - and that you can modify the drawViews
elements as in the DrawTool).
<BR>
Try:
<!-- XXX:THIS DOES NOT WORK FOR BUTTON #3 -->

<A TYPE="example">
<PRE><CODE>
    |top viewStack buttonPanel l sub1 sub2 sub3 sub4|

    top := StandardSystemView new.
    top extent:300 @ 350.

    buttonPanel := HorizontalPanelView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 50)
			in:top.

    l := Label label:'4' in:buttonPanel.
    (View in:buttonPanel) width:10.
    (Button label:'view1' action:[l label:'1'. sub1 raise] in:buttonPanel).
    (Button label:'view2' action:[l label:'2'. sub2 raise] in:buttonPanel).
    (Button label:'view3' action:[l label:'3'. sub3 raise] in:buttonPanel).
    (Button label:'view4' action:[l label:'4'. sub4 raise] in:buttonPanel).

    viewStack := View
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:top.
    viewStack topInset:(buttonPanel height).
    viewStack level:0.

    sub1 := TextView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:viewStack.
    sub1 contents:'I am the TextView (sub1)'.
    sub1 level:-1; borderWidth:0.

    sub2 := ScrollableView for:EditTextView in:viewStack.
    sub2 origin:(0.0 @ 0.0)
	 corner:(1.0 @ 1.0).
    sub2 contents:'I am the EditTextView (sub2)'.
    sub2 level:0; borderWidth:0.

    sub3 := DrawView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:viewStack.
    sub3 level:-1; borderWidth:0.
    sub3 add:(DrawEllipse new
		    origin:(50 @ 50) corner:(250 @ 250);
		    foreground:(Color green);
		    background:(Color black);
		    fillPattern:(Image fromFile:'libtool/bitmaps/SmalltalkX.xbm')
	    ).
    sub3 add:(DrawRectangle new
		    origin:(50 @ 50) corner:(250 @ 250);
		    foreground:(Color green);
		    fillPattern:nil
	    ).

    sub4 := ClockView
		    origin:(0.0 @ 0.0)
		    corner:(1.0 @ 1.0)
			in:viewStack.
    sub4 level:-1; borderWidth:0.

    top open
</CODE></PRE>
</A>


<H3><A HREF="#I_LAYOUT_SCROLLING" NAME="LAYOUT_SCROLLING">Scrolling views</A></H3>

Every view can be wrapped into a ScrollableView or HVScrollableView, which add
vertical or vertical and horizontal scrollbars. (Currently, there is no horizontal-only
wrapper - this will be added soon).
<BR>
To be able to set the correct position and size of the scrollbars thumb, the view to be scrolled
must respond to the following messages:
<UL>
<LI><CODE>widthOfContents</CODE>
<BR>
should return the width of the contents in device coordinates (i.e. pixels).
<P>
<LI><CODE>heightOfContents</CODE>
<BR>
should return the height of the contents in device coordinates (i.e. pixels).
<P>
</UL>

Scrolling is done by changing the transformation of the scrolled view. Therefore,
scrolling is almost transparent to the scrolled view. However, for performance reasons,
the scrolled view may use the scroll origin and view dimensions to optimize redraw operations
by limiting them to the visible area.
<P>
Currently, due to historical reasons, the <CODE>ListView</CODE> class and its subclasses use a different
mechanism to implement scrolling (they keep track of the scroll origin themselves - not using
transformations). This implementation is a leftover from times when no transformation existed
and TextViews were the only views which supported scrolling.
The implementation of these will be changed in the next release, to have a consistent
implementation over all views.




<H2><A HREF="#I_INTER" NAME="INTER">Interactors </A></H2>

We call those views which allow interaction with the user
<VAR>interactors</VAR> in contrast to <VAR>layout views</VAR>.
In the browser, you will find these classes in the ``<VAR>Views-Interactors</VAR>''
class category.
<BR>




<H3><A HREF="#I_INTER_BUTTONS" NAME="INTER_BUTTONS">Buttons </A></H3>

We have already met Buttons in the previous examples.
Lets go into more detail here.
<BR>
Since <CODE>Button</CODE> is a superclass of <CODE>Toggle</CODE>,
<CODE>CheckToggle</CODE> and <CODE>RadioButton</CODE>, the following is
also valid for these subclasses which are described in more detail below.




<H4><A HREF="#I_BUTTONS_ACTION" NAME="BUTTONS_ACTION">Attaching an action to a button</A></H4>

Whenever pressed, a button performs some action. Beside the MVC operation,
in which a model is informed about the buttons state change, and
which is described in more detail below,
buttons also support actionBlocks. ActionBlocks are set by the application
which uses a button and are evaluated whenever the button is pressed.
<P>
(Note to experienced <CITE>ST-80</CITE> users: in many applications,
 a setup using actionBlocks can be done with less coding and is probably
 easier to understand  for beginners. You may of course continue to
 use buttons in the MVC way you are used to. Or, as we suggest,
 to use actionBlocks for simple setups and change messages in situations, where
 mutliple buttons operate on a common or complex model).

<P>
Action example:

<A TYPE="example">
<PRE><CODE>
    |top b|

    top := StandardSystemView label:'a button'.
    top extent:100@100.

    b := Button in:top.
    b label:'press me'.
    b origin:0.1@0.1 corner:0.9@0.9.
    b action:[Transcript showCR:'hello there'].
    top open
</CODE></PRE>
</A>

By default, buttons fire (i.e. perform their action) when the
mouse button is released. This behavior is usually better for the user,
since he/she can change her mind and leave the buttons screen area before
releasing the mouse button
(i.e. the ``<VAR>oops - I don't want this to be done</VAR>'' situation).
<BR>
In some situations you may want your button to fire immediately
(for example, the scrollbars arrow buttons do so).
Since user interaction is really done by another object (the buttons controller),
you have to tell this one when to fire:

<A TYPE="example">
<PRE><CODE>
    |top b|

    top := StandardSystemView label:'a button'.
    top extent:100@100.

    b := Button in:top.
    b label:'press me'.
    b origin:0.1@0.1 corner:0.9@0.9.
    b controller beTriggerOnDown.
    b action:[Transcript showCR:'hello there'].
    top open
</CODE></PRE>
</A>

Actually, buttons really support two actions: the <VAR>pressAction</VAR> and
the <VAR>releaseAction</VAR>.The <CODE>#beTriggerOnDown</CODE> message simply
arranges that further action settings are installed as pressAction,
while the default arranges them to be installed as releaseAction.
This implies,
that you have to set the action <STRONG>after</STRONG>
sending the <CODE>#beTriggerOnDown</CODE> message.
<P>
You can also specify both or explicit press- and releaseActions;
the one set with <CODE>action:</CODE> is the pressAction if its a triggerOnUp
button, or the releaseAction if its a triggerOnDown button.
<BR>
try:

<A TYPE="example">
<PRE><CODE>
    (Button label:'see the transcript') pressAction:[Transcript showCR:'pressed'; endEntry];
				      releaseAction:[Transcript showCR:'released'; endEntry];
					    open.
    Transcript topView raise
</CODE></PRE>
</A>

  or:

<A TYPE="example">
<PRE><CODE>
    |p|
    p := HorizontalPanelView new.

    (Button label:'up/down' in:p)
	pressAction:[Transcript topView raise];
	releaseAction:[Transcript topView lower].

    (Button label:'up on press' in:p)
	pressAction:[Transcript topView raise].

    (Button label:'up on release' in:p)
	releaseAction:[Transcript topView raise].

    p extent:p preferredExtent.
    p open
</CODE></PRE>
</A>






<H4><A HREF="#I_BUTTONS_APPEAR" NAME="BUTTONS_APPEAR">Fonts and images</A></H4>

<BLOCKQUOTE>
Hint (read before you start to change fonts in your buttons ;-):
<BR>
do not play around too much (if at all) with different font styles
 and/or font sizes -
it usually
makes a user interface worse and harder to use for others.
Do not use decorative fonts (such as gothic or old-english).
Finally, do not depend on the font being available on all machines.
<BR>
You can almost always assume that 'times', 'courier' and 'helvetica' are
available; other fonts may not be present in all windowing systems.
</BLOCKQUOTE>

Buttons (like all other views) have a font in which they draw text.
You can set the font to be used with the <CODE>#font:</CODE> message.
The default font to use for all buttons is defined in the styleSheet.

<A TYPE="example">
<PRE><CODE>
    |top panel b1 b2|

    top := StandardSystemView label:'two buttons'.
    top extent:200 @ 100.

    panel := HorizontalPanelView origin:(0.0 @ 0.0)
				 corner:(1.0 @ 1.0)
				     in:top.

    b1 := Button label:'one' in:panel.
    b1 font:(Font family:'helvetica' face:'bold' style:'roman' size:24).

    b2 := Button label:'two' in:panel.
    b2 font:(Font family:'helvetica' face:'bold' style:'roman' size:8).

    top open
</CODE></PRE>
</A>

  The <CITE>Smalltalk/X's</CITE> Font class is smart enough to detect
non existing fonts (and provide some default fall-back then):

<A TYPE="example">
<PRE><CODE>
    |top b|

    top := StandardSystemView label:'a button'.
    top extent:200@200.

    b := Button label:'one' in:top.
    b font:(Font family:'funnyFont' face:'bold' style:'roman' size:24).
    top open
</CODE></PRE>
</A>

  Buttons can have image-labels instead of textual labels:
<BR>
(you already know about panels, so the following example should be easy
to understand):

<A TYPE="example">
<PRE><CODE>
    |top panel b1 b2 b3 b4|

    top := StandardSystemView label:'many buttons'.
    top extent:200 @ 100.

    panel := HorizontalPanelView origin:(0.0 @ 0.0)
				 corner:(1.0 @ 1.0)
				     in:top.

    b1 := Button label:'one' in:panel.
    b2 := Button label:'two' in:panel.
    b3 := Button label:(Image fromFile:'libtool/bitmaps/Camera.xbm') in:panel.
    b4 := Button label:'bye bye' in:panel.
    b4 action:[top destroy].

    top open
</CODE></PRE>
</A>

<H4><A HREF="#I_BUTTONS_ENABLE" NAME="BUTTONS_ENABLE">Enabling &amp; disabling</A></H4>

Buttons can be enabled, disabled and also be turned on and off under
program control:

<A TYPE="example">
<PRE><CODE>
    |top panel b1 b2 b3 b4|

    top := StandardSystemView label:'many buttons'.
    top extent:250 @ 100.

    panel := HorizontalPanelView origin:(0.0 @ 0.0)
				 corner:(1.0 @ 1.0)
				     in:top.

    b1 := Button label:'one' in:panel.
    b2 := Button label:(Image fromFile:'goodies/bitmaps/xpmBitmaps/device_images/ljet3.xpm') in:panel.
    b3 := Button label:(Image fromFile:'libtool/bitmaps/Camera.xbm') in:panel.
    b4 := Button label:'bye bye' in:panel.

    b1 action:[b3 enable. b4 enable].
    b2 action:[b3 disable].
    b3 action:[b4 disable].
    b4 action:[top destroy].
    top open.
</CODE></PRE>
</A>

Notice that except for toggles and radioButtons,
explicit turning on/off of buttons is rarely required.
<P>
Beginners may ignore the following:
<BR>
Enabling can also be done via a so called enableChannel.
This is a valueHolder object, which automatically informs other
objects about any changes of its value. Especially in complex
applications, use of an enableChannel may simplify things, since you don't
have to enable/disable all buttons manually.
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |top panel ena t b1 b2 b3 check|

    top := StandardSystemView new.
    top extent:300@100.

    panel := HorizontalPanelView origin:0.0 @ 0.0 corner:1.0 @ 1.0 in:top.

    ena := false asValue.

    t := Toggle label:'enable' in:panel.
    t model:ena.

    b1 := Button label:'button1' in:panel.
    b1 controller enableChannel:ena.

    b2 := Button label:'button2' in:panel.
    b2 controller enableChannel:ena.

    b3 := Button label:'button3' in:panel.
    b3 controller enableChannel:ena.

    top open.

    check := CheckBox model:ena.
    check label:'also enable'.
    check extent:(check preferredExtent + (5@5)).
    check open
</CODE></PRE>
</A>

<P>
You can specify the foreground/background colors for the passive state,
the active state (i.e. when pressed) and the entered state (i.e. when the
mouse-pointer is in the button).
Usually, you should let buttons use their default values (which come
from the styleSheet). But, for special applications, it may be useful
to change those.
<BR>
Try:

<A TYPE="example">
<PRE><CODE>
    |top panel b1 b2 b3 b4|

    top := StandardSystemView label:'many buttons'.
    top extent:200 @ 100.

    panel := HorizontalPanelView origin:(0.0 @ 0.0)
				 corner:(1.0 @ 1.0)
				     in:top.

    b1 := Button label:'one' in:panel.
    b2 := Button label:'two' in:panel.
    b3 := Button label:(Image fromFile:'libtool/bitmaps/Camera.xbm') in:panel.
    b4 := Button label:'bye bye' in:panel.

    b1 action:[b3 turnOn.
	       b4 enable.
	       b4 backgroundColor:(Color red lightened).
	       b4 enteredBackgroundColor:(Color red).
	      ].
    b2 action:[b3 turnOff].
    b3 action:[b4 disable];
       foregroundColor:Color blue;
       backgroundColor:Color red.
    b4 action:[top destroy].

    top open.
</CODE></PRE>
</A>

Beside the buttons interface,
these examples gave us some more new information:
<UL>
<LI>- you really don't need a StandardSystemView all the time (in <CITE>ST/X</CITE>) as long as you
      do not care for icons, iconlabels etc.
      Thus, for quick tests &amp; demos, you can simply open your view directly.

<LI>- how to access any views topView

<LI>- how to bring views to the top
</UL>
(the reason you need the topview in the above example is, that
<CODE>Transcript</CODE> is actually the one
subview showing the text - not the StandardSystemView around it -
 try <CODE>Transcript inspect</CODE> and
follow the superView instance variables till you get to this topview.
Sending topView to a real topview does not hurt, it will return itself.)





<H4><A HREF="#I_BUTTONS_LOGOS" NAME="BUTTONS_LOGOS">Different active/passive logos</A></H4>

Normally, only the buttons level or (for 2D styles) its colors are affected
when activated.
However, it may be useful to specify different logos.
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |v b1 b2 winBitmapsPath|

    v := HorizontalPanelView new.
    v extent:200 @ 100.

    winBitmapsPath := 'goodies/bitmaps/winBitmaps'.

    b1 := Button in:v.
    b1 borderWidth:0; level:0; onLevel:0; offLevel:0.
    b1 activeLogo:((Image fromFile:winBitmapsPath , '/setup_down.bmp') onDevice:Display).
    b1 passiveLogo:((Image fromFile:winBitmapsPath , '/setup_up.bmp') onDevice:Display).

    b2 := Button in:v.
    b2 borderWidth:0; level:0; onLevel:0; offLevel:0.
    b2 activeLogo:((Image fromFile:winBitmapsPath , '/help_down.bmp') onDevice:Display).
    b2 passiveLogo:((Image fromFile:winBitmapsPath , '/help_up.bmp') onDevice:Display).

    v open
</CODE></PRE>
</A>

Note:
<BR>
in the example above the levels and borders are explicitely turned off,
since the bitmaps already include 3D effects.
This may not be the case for other bitmaps.
<P>
Note:
<BR>
By default, labels (and therefore buttons too), will inset the
logo by some pixels and draw themself in 3D depending on the style.
If the bitmaps already have the 3D style included (as in the above example),
you should setup the button accordingly.
This is done by:
<PRE><CODE>
    someButton
	borderWidth:0;
	onLevel:0;
	offLevel:0;
	orizontalSpace:0;
	verticalSpace:0.
</CODE></PRE>
or, for short:
<PRE><CODE>
    someButton beImageButton
</CODE></PRE>
So, the above example looks better if we write:

<A TYPE="example">
<PRE><CODE>
    |v b1 b2 winBitmapsPath|

    v := HorizontalPanelView new.
    v extent:200 @ 100.

    winBitmapsPath := 'goodies/bitmaps/winBitmaps'.

    b1 := Button in:v.
    b1 activeLogo:((Image fromFile:winBitmapsPath , '/setup_down.bmp') onDevice:Display).
    b1 passiveLogo:((Image fromFile:winBitmapsPath , '/setup_up.bmp') onDevice:Display).
    b1 beImageButton.

    b2 := Button in:v.
    b2 activeLogo:((Image fromFile:winBitmapsPath , '/help_down.bmp') onDevice:Display).
    b2 passiveLogo:((Image fromFile:winBitmapsPath , '/help_up.bmp') onDevice:Display).
    b2 beImageButton.

    v open
</CODE></PRE>
</A>

You can even define separate logos to us if the button is disabled
or has the focus (i.e. has been tabbed active):

<A TYPE="example">
<PRE><CODE>
    |v b1 b2 winBitmapsPath|

    v := HorizontalPanelView new.
    v extent:200 @ 100.

    b1 := Button in:v.
    b1 borderWidth:0; level:0; onLevel:0; offLevel:0.
    b1 horizontalSpace:0; verticalSpace:0.
    winBitmapsPath := 'goodies/bitmaps/winBitmaps'.
    b1 activeLogo:((Image fromFile:winBitmapsPath , '/prev_down.bmp') onDevice:Display).
    b1 passiveLogo:((Image fromFile:winBitmapsPath , '/prev_up.bmp') onDevice:Display).
    b1 disabledLogo:((Image fromFile:winBitmapsPath , '/prev_disabled.bmp') onDevice:Display).

    b2 := Button in:v.
    b2 borderWidth:0; level:0; onLevel:0; offLevel:0.
    b2 horizontalSpace:0; verticalSpace:0.
    b2 activeLogo:((Image fromFile:winBitmapsPath , '/next_down.bmp') onDevice:Display).
    b2 passiveLogo:((Image fromFile:winBitmapsPath , '/next_up.bmp') onDevice:Display).
    b2 disabledLogo:((Image fromFile:winBitmapsPath , '/next_disabled.bmp') onDevice:Display).

    v open.

    (Delay forSeconds:5) wait.
    b1 disable.
    (Delay forSeconds:5) wait.
    b1 enable.
    b2 disable
</CODE></PRE>
</A>

Another example; here, we extract the background color for the view from the button image:
<BR>
(this example expects a soundfile to be present in /usr/local/lib/sound, and a sound device
 to be present - this may not work on your system)

<A TYPE="example">
<PRE><CODE>
    |v b1 winBitmapsPath img|

    v := HorizontalPanelView new.
    v extent:200 @ 100.

    b1 := Button in:v.
    b1 borderWidth:0; level:0; onLevel:0; offLevel:0.
    b1 horizontalSpace:0; verticalSpace:0.
    winBitmapsPath := 'goodies/bitmaps/winBitmaps'.
    b1 activeLogo:(img := ((Image fromFile:winBitmapsPath , '/replay_down.bmp') onDevice:Display)).
    b1 passiveLogo:((Image fromFile:winBitmapsPath , '/replay_up.bmp') onDevice:Display).
    b1 focusLogo:((Image fromFile:winBitmapsPath , '/replay_focus.bmp') onDevice:Display).
    b1 controller beTriggerOnDown.
    v viewBackground:(img at:0@0).

    b1 action:[
	b1 withCursor:Cursor wait
	   do:[ SoundStream playSoundFile:'/usr/local/lib/sounds/laugh.snd']
	].
    v open.
</CODE></PRE>
</A>


The above also works with strings:

<A TYPE="example">
<PRE><CODE>
    |v b1 t ena|

    v := HorizontalPanelView new.
    v extent:200 @ 100.

    t := Toggle label:'enable' in:v.
    ena := true asValue.
    t model:ena.

    b1 := Button in:v.
    b1 activeLogo:'release me'.
    b1 passiveLogo:'press me'.
    b1 disabledLogo:'sorry '.

    b1 enableChannel:ena.
    v open
</CODE></PRE>
</A>

However, this shows a little problem: the button resizes itself, to make
the bigger logo fully visible.
<BR>
Especially, if your button is arranged in some panel, this is definitely
not what you want. Therefore, you should fix the buttons size.
<BR>
(Note: it is possible to tell the panel that its components change their size
 and have it rearrange things whenever that happens.)





<H4><A HREF="#I_BUTTONS_FIX" NAME="BUTTONS_FIX">Fix size vs. variable size</A></H4>

You can fix a buttons size by sending <CODE>sizeFixed:true</CODE> to it.
This method will freeze the current buttons size. You should do so
<STRONG>after</STRONG> you defined the largest logo that will ever
appear in it.
(actually, since all of this is defined in buttons superclass:
<CODE>Label</CODE>, all of this is also true for labels).
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |v b|

    v := HorizontalPanelView new.
    v extent:200 @ 100.

    b := Button in:v.
    "
     set to the largest logo - just for the fixing
    "
    b logo:'release me'.
    b sizeFixed:true.

    b activeLogo:'release me'.
    b passiveLogo:'press me'.

    v open
</CODE></PRE>
</A>

BTW:
<BR>
Labels (and therefore buttons, toggles and radioButtons too) offer
various logo adjustment schemes, which control where the logo is to be
placed within the view.
The default adjustment is <CODE>#center</CODE>.
But the above example may also look good with left adjusted logos.
<BR>
You can use any of <CODE>#left</CODE>, <CODE>#right</CODE>,
<CODE>#center</CODE>, <CODE>#centerLeft</CODE> or <CODE>#centerRight</CODE>.
<BR>
<CODE>#centerLeft</CODE> or <CODE>#centerRight</CODE> also center their
logo, but change the adjustment to left or right resp. if the logo does
not fit. (i.e. use these if your logo may become very long, to tell the
label/button which part should be shown in this case).
<BR>
Try:

<A TYPE="example">
<PRE><CODE>
    |v b|

    v := HorizontalPanelView new.
    v extent:200 @ 100.

    b := Button in:v.
    "
     set to the largest logo - just for the fixing
    "
    b logo:'release me'.
    b sizeFixed:true.
    b adjust:#left.

    b activeLogo:'release me'.
    b passiveLogo:'press me'.

    v open
</CODE></PRE>
</A>





<H3><A HREF="#I_INTER_TOGGLES" NAME="INTER_TOGGLES">Toggles and radio buttons</A></H3>

  A specialized button is the toggle - it will <VAR>toggle</VAR> its state whenever pressed.
The protocol for
toggles is the same as for buttons, with the exception, that a toggle defines both an
<VAR>onAction</VAR> and
an <VAR>offAction</VAR>.
<BR>
Lets modify one of the above examples to use a toggle:

<A TYPE="example">
<PRE><CODE>
    |top panel b1 b2 b3 b4|

    top := StandardSystemView label:'many buttons'.
    top extent:200 @ 100.

    panel := HorizontalPanelView origin:(0.0 @ 0.0)
				 corner:(1.0 @ 1.0)
				     in:top.

    b1 := Button label:'one' in:panel.
    b2 := Toggle label:'two' in:panel.
    b3 := Button label:(Image fromFile:'libtool/bitmaps/Camera.xbm') in:panel.
    b4 := Button label:'bye bye' in:panel.

    b1 action:[b3 turnOn.].
    b2 pressAction:[b4 enable].
    b2 releaseAction:[b4 disable].
    b4 action:[top destroy].

    b4 disable.
    top open.
</CODE></PRE>
</A>

Sometimes, you want to arrange toggles in a group, such that only one of them may be
on at any time. This is done by using radio buttons, and an instance of
its companion class, a RadioButtonGroup:

<A TYPE="example">
<PRE><CODE>
    |top panel b1 b2 b3 b4 b5 group|

    top := StandardSystemView label:'one only buttons'.
    top extent:200 @ 100.

    panel := HorizontalPanelView origin:(0.0 @ 0.0)
				 corner:(1.0 @ 1.0)
				     in:top.

    b1 := RadioButton label:'one' in:panel.
    b2 := RadioButton label:'two' in:panel.
    b3 := RadioButton label:'three' in:panel.
    b4 := RadioButton label:(Image fromFile:'libtool/bitmaps/Camera.xbm') in:panel.
    b5 := Button label:'exit' in:panel.

    group := RadioButtonGroup new.
    group add:b1;
	  add:b2;
	  add:b3;
	  add:b4.

    b5 action:[top destroy].
    top open.

</CODE></PRE>
</A>

  If you want one of those buttons to be ON initially, add a line such as:

<PRE><CODE>
    b3 turnOn.
</CODE></PRE>

to the above setup.

<H3><A HREF="#I_INTER_CTOGGLES" NAME="INTER_CTOGGLES">CheckToggle and CheckBox</A></H3>

A special toggle is the CheckToggle, which does not display a label (-string),
but instead displays itself either empty or with a check mark if turned on.
<BR>
CheckToggles can be used for multiple choice or multiple selection input;
often, checkToggles are placed into a radioButtonGroup.
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |top panel check1 check2 check3 grp|

    top := StandardSystemView new.
    top extent:200@200.

    panel := VerticalPanelView origin:0.0@0.0 corner:1.0@1.0 in:top.
    panel verticalLayout:#spreadSpace.

    check1 := CheckToggle in:panel.
    check2 := CheckToggle in:panel.
    check3 := CheckToggle in:panel.

    grp := RadioButtonGroup new.
    grp add:check1.
    grp add:check2.
    grp add:check3.

    top open
</CODE></PRE>
</A>

CheckToggles do not display a label - this is an intended limitation,
since there are uses for these toggles without a label:

<A TYPE="example">
<PRE><CODE>
    |top panel hpanel check1 check2 check3 grp
     readPermission writePermission executePermission|

    readPermission := false asValue.
    writePermission := false asValue.
    executePermission := false asValue.

    top := StandardSystemView new.
    top extent:200@200.

    panel := VerticalPanelView origin:0.0@0.0 corner:1.0@1.0 in:top.
    panel verticalLayout:#topSpace.

    hpanel := HorizontalPanelView new.
    hpanel add:(Label label:'read').
    hpanel add:(Label label:'write').
    hpanel add:(Label label:'execute').
    hpanel extent:1.0@(hpanel preferredExtent y); horizontalLayout:#fitSpace.
    panel add:hpanel.

    hpanel := HorizontalPanelView new.
    hpanel add:(CheckToggle on:readPermission).
    hpanel add:(CheckToggle on:writePermission).
    hpanel add:(CheckToggle on:executePermission).
    hpanel extent:1.0@(hpanel preferredExtent y); horizontalLayout:#spreadSpace.
    panel add:hpanel.

    top open
</CODE></PRE>
</A>

For the common case, where a label is to be displayed aside the checkmark,
use CheckBox instead; this wraps a checkToggle with a label and displays them
side by side. (Technically, this is a subclass of HorizontalPanel, so it responds
to all layout messages as described above).
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |top panel check1 check2 check3
     readPermission writePermission executePermission|

    readPermission := true asValue.
    writePermission := false asValue.
    executePermission := false asValue.

    top := StandardSystemView new.
    top extent:200@200.

    panel := VerticalPanelView origin:0.0@0.0 corner:1.0@1.0 in:top.
    panel verticalLayout:#spreadSpace.
    panel horizontalLayout:#leftSpace.

    check1 := CheckBox label:'read' in:panel.
    check2 := CheckBox label:'write' in:panel.
    check3 := CheckBox label:'execute' in:panel.

    check1 model:readPermission.
    check2 model:writePermission.
    check3 model:executePermission.

    top open
</CODE></PRE>
</A>

of course, these can also be used with radioButton behavior:

<A TYPE="example">
<PRE><CODE>
    |top panel check1 check2 check3 grp|

    top := StandardSystemView new.
    top extent:200@200.

    panel := VerticalPanelView origin:0.0@0.0 corner:1.0@1.0 in:top.
    panel verticalLayout:#spreadSpace.
    panel horizontalLayout:#leftSpace.

    check1 := CheckBox label:'pizza' in:panel.
    check2 := CheckBox label:'spaghetti' in:panel.
    check3 := CheckBox label:'lasagne' in:panel.

    grp := RadioButtonGroup new.
    grp add:check1 value:#pizza.
    grp add:check2 value:#spaghetti.
    grp add:check3 value:#lasagne.

    top openModal.
    Transcript showCR:grp value
</CODE></PRE>
</A>

As a side effect, the above example demonstrates how a radioButtonGroup
can operate on some model.
This may be more convenient than using actionBlocks in some applications.
<BR>
Of course, action blocks are also possible:

<A TYPE="example">
<PRE><CODE>
    |top panel check1 check2 check3 grp selection|

    top := StandardSystemView new.
    top extent:200@200.

    panel := VerticalPanelView origin:0.0@0.0 corner:1.0@1.0 in:top.
    panel verticalLayout:#spreadSpace.
    panel horizontalLayout:#leftSpace.

    check1 := CheckBox label:'pizza' in:panel.
    check1 action:[selection := #pizza].
    check2 := CheckBox label:'spaghetti' in:panel.
    check2 action:[selection := #spaghetti].
    check3 := CheckBox label:'lasagne' in:panel.
    check3 action:[selection := #lasagne].

    grp := RadioButtonGroup new.
    grp add:check1.
    grp add:check2.
    grp add:check3.

    top openModal.
    Transcript showCR:selection
</CODE></PRE>
</A>

Use whichever seems more natural to you, or fits easier into your concrete
application.









<H3><A HREF="#I_INTER_SLIDERS" NAME="INTER_SLIDERS">Sliders and Scrollers</A></H3>

Sliders and Scrollers are used much like Buttons,
in that either an action is defined to be evaluated
when the sliders/scrollers value changed, or a model is informed via
a change message.
<BR>
Sliders and scrollers offer basically the same protocol and act similar.
Bothe show a so called <VAR>thumb</VAR> which can be moved with the mouse.
The only differences is that a sliders thumb is fixed in its size,
while a scrollers thumb can change the size.
<P>
The thumbs position (in percent, 0..100) is passed as argument to the actionBlock
- therefore we need a block which expects one argument as the scrollAction:

<A TYPE="example">
<PRE><CODE>
    |sl|

    sl := Slider new.
    sl extent:20 @ 200.    "notice: some window managers ignore this"
    sl scrollAction:[:percent | Transcript showCR:('moved to ' , percent rounded printString) ].
    sl open.
</CODE></PRE>
</A>

Note:
<BR>
I should have called it "slideAction";
but Slider is inheriting most of its protocol
from Scroller; and thats where the whole show is actually performed.
<P>
Another Note:
<BR>
We won't go too deeply into Scrollers here - they need more information about the
size and position of the thing that is scrolled; if you want to try a standalone scroller,
try
and experiment by sending the scroller <CODE>thumbHeight:</CODE> and <CODE>thumbOrigin:</CODE> messages.
Pass numerical percentage-values as arguments.

<A TYPE="example">
<PRE><CODE>
    |s|

    s := Scroller extent:20 @ 200.
    s scrollAction:[:percent | Transcript showCR:('moved to ' , percent rounded printString) ].
    s thumbHeight:50.
    s thumbOrigin:10.
    s open.
</CODE></PRE>
</A>

A funny example:

<A TYPE="example">
<PRE><CODE>
    |sl sc|

    sl := Slider extent:20 @ 200.
    sc := HorizontalScroller extent:200 @ 20.
    sl scrollAction:[:percent | sc thumbHeight:percent].
    sc scrollAction:[:percent | sl thumbOrigin:percent].
    sl open.
    sc open.
</CODE></PRE>
</A>

You will notice, that a scroller decides to show nothing for a size of 100% -
that is also the behavior of Scrollbars in all of your textviews.

<P>
By default, a sliders (and scrollers) value range is 0 .. 100 (percent).
In some applications, it may be more convenient to change this and
let the slider report values which are already scaled to
your applications requirements.
The following sets this range to -50 .. +50:

<A TYPE="example">
<PRE><CODE>
    |sl|

    sl := Slider new.
    sl extent:20 @ 200.
    sl scrollAction:[:val | Transcript showCR:('moved to ' , val rounded printString) ].
    sl start:-50 stop:50.
    sl open.
</CODE></PRE>
</A>

Cousins of Sliders are the so called <VAR>SteppingSliders</VAR>;
these add two buttons, to increase/decrease the sliders value.
(they are like scrollBars, but use a slider instead of scroller for
their thumb component).
<BR>
For example:

<A TYPE="example">
<PRE><CODE>
    |top sl|

    top := StandardSystemView new.
    top extent:200@200.

    sl := HorizontalSteppingSlider in:top.
    sl width:1.0.
    sl start:-50 stop:50 step:2.
    sl thumbOrigin:0.
    sl scrollAction:[:val | Transcript showCR:('moved to ' , val rounded printString) ].
    top open.
</CODE></PRE>
</A>

if you prefer '+'/'-' as button labels (instead of the arrows),
change the buttons labels with:

<A TYPE="example">
<PRE><CODE>
    |top sl|

    top := StandardSystemView new.
    top extent:200@200.

    sl := HorizontalSteppingSlider in:top.
    sl upButton label:'+'.
    sl downButton label:'-'.
    sl setElementPositions.
    sl width:1.0.
    sl start:-50 stop:50 step:2.
    sl thumbOrigin:0.
    sl scrollAction:[:val | Transcript showCR:('moved to ' , val rounded printString) ].
    top open.
</CODE></PRE>
</A>

(Notice: the scrollBar is normally not prepared for the buttons to change their
size - therefore, we force a recomputation of the elements positions in the
above example).

<H3><A HREF="#I_INTER_SCROLLBARS" NAME="INTER_SCROLLBARS">Scrollbars</A></H3>

Scrollbars are seldom used on their own,
you normally do not care for the low-level details
(there are complex views, such as
 <CODE>ScrolledView</CODE>, which do all setup for you).
Anyway, it may be interesting to use a standalone scrollbar sometimes:

<A TYPE="example">
<PRE><CODE>
    |v s|

    v := View extent:100 @ 200.
    s := ScrollBar in:v.
    s height:1.0.             "only changing height - let width stay its default"
    s scrollAction:[:percent | Transcript showCR:('moved to ' , percent rounded printString) ].
    s scrollUpAction:[Transcript showCR:'one step up' ].
    s scrollDownAction:[Transcript showCR:'one step down' ].
    s thumbHeight:50.
    s thumbOrigin:10.
    v open.
</CODE></PRE>
</A>

In addition to the scrollers scrollAction,
a scrollbar defines two additional actions:
<VAR>scrollUpAction</VAR> which gets evaluated when the scrollup button is pressed;
and <VAR>scrollDownAction</VAR> which gets evaluated when the scrolldown button is pressed;
<P>
Of course, the scrollbar has no idea of "how much" one step is in this isolated example,
so the scroller is not updated when the step-up and step-down buttons are pressed.
<BR>
We have to tell it (in this example):

<A TYPE="example">
<PRE><CODE>
    |v s|

    v := View extent:100 @ 200.
    s := ScrollBar in:v.
    s height:1.0.
    s scrollAction:[:percent | Transcript showCR:('moved to ' , percent rounded printString) ].
    s scrollUpAction:[
			Transcript showCR:'one step up'.
			s thumbOrigin:(s thumbOrigin - 10)
		     ].
    s scrollDownAction:[
			Transcript showCR:'one step down'.
			s thumbOrigin:(s thumbOrigin + 10)
		     ].
    s thumbHeight:50.
    s thumbOrigin:10.
    v open.
</CODE></PRE>
</A>

But again, this is not the normal use of scrollbars - usually they are connected to some view
which calls:
<PRE><CODE>
    s setThumbFor:self
</CODE></PRE>

whenever some change takes place. Typically, this is an instance of <CODE>ScrollableView</CODE>,
doing so whenever its scrolled-view (which does not really know about being scrolled) sends a
<CODE>self contentsChanged</CODE> or <CODE>self originChanged</CODE>.
<BR>
More on this later ...



<H3><A HREF="#I_INTER_SCRVIEW" NAME="INTER_SCRVIEW">Scrolled views</A></H3>


Typically, scrollBars are not created as individual components - they are almost always
needed to control another views scrolling position.
<BR>
To make scrolling easy, <CITE>ST/X</CITE> provides a wrapperView class, called <VAR>ScrollableView</VAR>,
which handles all the geometry and interaction of some view (which is to be scrollable)
and the scrollbar(s).
<BR>
The setup for scrolling is (more details on textViews are found below):
<A TYPE="example">
<PRE><CODE>
    |v t|

    v := ScrollableView new.
    t := TextView new.
    v scrolledView:t.
    t contents:('/etc/hosts' asFilename readStream contents).
    v open
</CODE></PRE>
</A>

The scrollableView as created above, is the wrapper view, which
is able to scroll a single view. Any view can be placed into a
scrollableView, as long as it provides the <CODE>heightOfContents</CODE>,
<CODE>widthOfContents</CODE> and <CODE>scrollTo:</CODE> protocol
(which is inherited from <CODE>View</CODE> - thus understood by any
view).
<P>
Since the above sequence of creation messages is very common,
the <CODE>ScrollableView</CODE> class provides a more convenient
instance creation message; instead of:
<PRE><CODE>
    ...
    v := ScrollableView new.
    t := TextView new.
    v scrolledView:t.
    ...
</CODE></PRE>
you can also write:
<PRE><CODE>
    ...
    v := ScrollableView for:TextView.
    ...
</CODE></PRE>

A scrolledView forwards all unimplemented messages to its scrolledView,
therefore, you can often omit the access to its scrolledView, and write:

<A TYPE="example">
<PRE><CODE>
    |v|

    v := ScrollableView for:TextView.
    v contents:('/etc/hosts' asFilename readStream contents).
    v open
</CODE></PRE>
</A>

<P>
By the way: the following is probably the shortest code to set up an editor:
<BR>
(we will come to the Dialog class soon ...)

<A TYPE="example">
<PRE><CODE>
    |fileName v top|

    fileName := Dialog requestFileName:'edit which file'.
    (fileName notNil and:[fileName asFilename exists]) ifTrue:[
	top := StandardSystemView new.
	top label:'editing ' , fileName.
	v := ScrollableView for:EditTextView in:top.
	v origin:0.0 @ 0.0 corner:1.0 @ 1.0.
	v contents:(fileName asFilename readStream contents).
	top open
    ]
</CODE></PRE>
</A>

If you want to have your own view scrolled, use the following code:
<PRE><CODE>
    |top v myView|

    ....
    top := StandardSystemView new ....
    ...
    v := ScrollableView origin:0.0 @ 0.0
			corner:1.0 @ 1.0
			    in:top.
    ...
    myView := MyViewClass new.
    v scrolledView:myView
    ...
    top open
    ...
</CODE></PRE>

your view (an instance of 'MyViewClass') will be asked for the size and position of
the contents (so that the scroller can reflect this correctly) by the following
messages:
<UL>
<LI>heightOfContents
<BR>
your view should return the full height of the contents in device-pixels
<P>
<LI>widthOfContents
<BR>
the same for the width of the contents
</UL>
and set an instance variable (viewOrigin) in your view.
<P>
Whenever moved, the scrollbar will ask your view to scroll accordingly.
This is done by sending it messages like <CODE>scrollVerticalTo:</CODE>.
<BR>
However, since there is a reasonable default implementation of all these
scroll methods (in the <CODE>View</CODE> class),
there is normally no need to add code
for scrolling support in subclasses of view.

<P>
If you need your view to be scrollable both vertically and
horizontally, use <CODE>HVScrollableView</CODE> instead:

<A TYPE="example">
<PRE><CODE>
    |v|

    v := HVScrollableView for:TextView.
    v contents:('/etc/hosts' asFilename readStream contents).
    v extent:300@200.
    v open
</CODE></PRE>
</A>


<H4><A HREF="#I_MINISCROLLERS" NAME="MINISCROLLERS">Miniscrollers </A></H4>

In many applications, horizontal scrolling is a rather uncommon function
(for example, since most of the time everything is visible horizontally).
<BR>
To avoid wasting too much of your valuable screen space, <CITE>ST/X</CITE>
provides smaller cousins of the scrollers, called <VAR>MiniScrollers</VAR>.
Both <CODE>ScrollableView</CODE> and <CODE>HVScrollableView</CODE>
can be configured to use miniScrollers instead of full size scrollBars.
<BR>
This is done in the instance creation message:

<A TYPE="example">
<PRE><CODE>
    |v|

    v := HVScrollableView for:TextView miniScrollerH:true miniScrollerV:false.
    v contents:('/etc/hosts' asFilename readStream contents).
    v extent:300@200.
    v open
</CODE></PRE>
</A>
or, if vertical scrolling is the uncommon case (this really depends
on your application !), use:

<A TYPE="example">
<PRE><CODE>
    |v|

    v := HVScrollableView for:TextView miniScrollerH:false miniScrollerV:true.
    v contents:('/etc/hosts' asFilename readStream contents).
    v extent:300@200.
    v open
</CODE></PRE>
</A>
of course, it is also possible to use miniscrollers for both directions:

<A TYPE="example">
<PRE><CODE>
    |v|

    v := HVScrollableView for:TextView miniScrollerH:true miniScrollerV:true.
    v contents:('/etc/hosts' asFilename readStream contents).
    v extent:300@200.
    v open
</CODE></PRE>
</A>

As a concrete example, the current <CITE>ST/X</CITE> system uses miniscrollers
for the selectionInListViews of the systemBrowser -
since these are rarely scrolled horizontally.





<H2><A HREF="#I_TEXTVIEWS" NAME="TEXTVIEWS">Textviews </A></H2>

<H3><A HREF="#I_TEXT_LISTVIEW" NAME="TEXT_LISTVIEW">ListView - a view for simple lists</A></H3>

The simplest and most fundamental class to present text is the <CODE>ListView</CODE>.
This does not offer any editing or selection capabilities,
and is therefore normally not used directly in the system.
However, many subclasses inherit the functionality
directly or indirectly from <CODE>ListView</CODE>,
using this class as a framework.
<P>
<CODE>ListViews</CODE> main purpose is to handle all redrawing and scrolling;
while the subclasses add user interaction.
<P>
Despite that, it is useful to create a listView and set its contents
for didactic purposes -
the protocol of the other text view classes is either directly implemented
by <CODE>ListView</CODE>, or redefined.
<BR>
Therefore, learning more about listViews protocol is quite useful.
<P>


<H4>Setting the views text</H4>

Internally, a listView keeps its text as a collection of strings,
each representing a single line of the text. Nil entries are taken
as empty lines.
You can set a textViews contents with the <CODE>#list:</CODE> message,
passing a (sequenceable) collection of strings as argument.
<BR>
For your convenience, there is also a <CODE>#contents:</CODE> message,
which expects a string argument. This method will break the string
into lines (taking <CODE>cr</CODE> as separator), expand tabulators into
spaces and set the list from the resulting collection.
<BR>
Examples:

<A TYPE="example">
<PRE><CODE>
    |top listView|

    top := StandardSystemView label:'a simple listview'.
    top extent:200@200.

    listView := ListView in:top.
    listView origin:0.0 @ 0.0 corner:1.0 @ 1.0.

    listView list:#('one' 'two' 'three' nil 'five' 'six').
    top open
</CODE></PRE>
</A>

or, passing a string:

<A TYPE="example">
<PRE><CODE>
    |top listView|

    top := StandardSystemView label:'a simple listview'.
    top extent:200@200.

    listView := ListView in:top.
    listView origin:0.0 @ 0.0 corner:1.0 @ 1.0.

    listView contents:'one
two
three

five
six'.
    top open
</CODE></PRE>
</A>

or, reading the text from a file:

<A TYPE="example">
<PRE><CODE>
    |top listView|

    top := StandardSystemView label:'a simple listview'.
    top extent:200@200.

    listView := ListView in:top.
    listView origin:0.0 @ 0.0 corner:1.0 @ 1.0.

    listView contents:('/etc/hosts' asFilename contentsOfEntireFile).
    top open
</CODE></PRE>
</A>

Normally, you want to the listView to be scrollable.
Compare the non scrollable case:

<A TYPE="example">
<PRE><CODE>
    |top listView|

    top := StandardSystemView label:'a simple listview'.
    top extent:300@400.

    listView := ListView in:top.
    listView origin:0.0 @ 0.0 corner:1.0 @ 1.0.

    listView contents:('/etc/hosts' asFilename contentsOfEntireFile).
    top open
</CODE></PRE>
</A>

with the scrollable case:

<A TYPE="example">
<PRE><CODE>
    |top scrollView listView|

    top := StandardSystemView label:'a scrollable listview'.
    top extent:300@400.

    scrollView := ScrollableView for:ListView in:top.
    listView := scrollView scrolledView.
    scrollView origin:0.0 @ 0.0 corner:1.0 @ 1.0.

    listView contents:('/etc/hosts' asFilename contentsOfEntireFile).
    top open
</CODE></PRE>
</A>

or scrollable in both directions:

<A TYPE="example">
<PRE><CODE>
    |top scrollView listView|

    top := StandardSystemView label:'a scrollable listview'.
    top extent:300@400.

    scrollView := HVScrollableView for:ListView miniScrollerH:true in:top.
    listView := scrollView scrolledView.
    scrollView origin:0.0 @ 0.0 corner:1.0 @ 1.0.

    listView contents:('/etc/hosts' asFilename readStream contents).
    top open
</CODE></PRE>
</A>

As you will notice, listViews do not support selections, editing or even
a popup menu - we will see how this is done in the next section..
<BR>
However, the <KBD>"<B>PageUp</B>"</KBD> and <KBD>"<B>PageDown</B>"</KBD> keys
(if available on your keyboard)
are understood and can be used to scroll your text.

<P>
You can ask a listView about its contents, either via the <CODE>#contents</CODE>
message (which returns a string) or the <CODE>#list</CODE> message
(which returns the list). Be careful when changing the list - you will get
a reference to its internal list - not a copy. The string returned by
<CODE>#contents</CODE> is always constructed anew - changing it will not
affect the listViews contents.

<P>
To change the list AND have the listView redisplay the changed lines,
either
<UL>
<LI>send another <CODE>#list:</CODE> or <CODE>#contents:</CODE> message,
passing the modified text,
</UL>
or
<UL>
<LI>tell the listView to do those changes for
you
<BR>
(it implements a subset of the collection messages,
such as <CODE>#at:put:</CODE>, <CODE>#add:</CODE>, <CODE>#add:beforeIndex:</CODE>
and <CODE>#removeIndex:</CODE>).
</UL>
<P>
Using those access messages (instead of setting the complete list) has
the advantage that the listView can optimize its redraw operations;
therefore, these are typically a bit faster - especially, if your display
connection is a slow one - and avoid visible flicker.
<P>
If you set the complete list via <CODE>#list:</CODE>, the listView
changes the scroll position to the top of the text
- if this is not desired, use <CODE>#setList:</CODE>,
which lets the scroll position remain unchanged.
<BR>
(the fileBrowser uses this, to update the list when the list of files
in the directory has changed).
<P>
changing text example:

<A TYPE="example">
<PRE><CODE>
    |top scrollView listView|

    top := StandardSystemView label:'a scrollable listview'.
    top extent:300@400.

    scrollView := HVScrollableView for:ListView miniScrollerH:true in:top.
    listView := scrollView scrolledView.
    scrollView origin:0.0 @ 0.0 corner:1.0 @ 1.0.

    listView contents:('/etc/hosts' asFilename readStream contents).
    top open.

    "/ wait for a while

    Delay waitForSeconds:3.

    "/ remove at top

    1 to:5 do:[:index |
	listView removeIndex:1.
	Delay waitForSeconds:0.5.
    ].
    (Delay waitForSeconds:2).

    "/ remove somewhere in the middle of the visible area

    1 to:5 do:[:index |
	listView removeIndex:5.
	Delay waitForSeconds:0.5.
    ].
    (Delay waitForSeconds:2).

    "/ remove in invisible area - watch the scrollBar

    (listView size) to:30 by:-1 do:[:index |
	listView removeIndex:index.
	Delay waitForSeconds:0.03.
    ].
</CODE></PRE>
</A>

<P>
All of the above described the direct list access protocol,
using direct interaction of the changer with the listView.
This setup is convenient for simple setups, where a one-to-one
relation between the text and the view exists.

<P>
<CODE>ListView</CODE> can also be used with a model, which holds the
actual text. Here the interaction is indirect: the changes are performed
to the model, which informs the listView - or, possibly - multiple listViews.
<BR>
If a model is set in a listView, it should send out
change notifications (<CODE>"aModel changed:aspect"</CODE>) to
have the listView update its contents.
<BR>
To acquire a new text, the listView sends a <VAR>listMessage</VAR> back
to the model - which should return the new text.
<BR>
The <VAR>listMessage</VAR> defaults to the aspect selector, but it can
be changed with <CODE>listMessage:</CODE>
to any other message selector (independent of the aspect).
<P>
Example using a model:

<A TYPE="example">
<PRE><CODE>
    |top model l theModelsText|

    "/ the model is normally one of your classes ...

    model := Plug new.
    model respondTo:#modelsAspect
	       with:[ theModelsText ].


    top := StandardSystemView new.
    top extent:100@200.

    l := ListView origin:0.0 @ 0.0 corner:1.0 @ 1.0 in:top.
    l model:model.

    l listMessage:#modelsAspect.
    l aspect:#modelsAspect.

    top open.

    Delay waitForSeconds:3.
    theModelsText := #('foo' 'bar' 'baz').
    model changed:#modelsAspect.

    Delay waitForSeconds:1.
    theModelsText := #('foo' 'bar' 'baz' 'nice - isn''t it').
    model changed:#modelsAspect.
</CODE></PRE>
</A>

Although, the normal setup (listMessage == aspectMessage) is ok for
most applications, there are situations, where it makes sense to
have multiple listViews access the text via different messages from the
same model.
<P>
Example using two listViews on the same model, with different listMessages:

<A TYPE="example">
<PRE><CODE>
    |top model l plainText|

    plainText := #('').

    model := Plug new.
    model respondTo:#modelsUppercaseText
	       with:[ plainText asStringCollection
			  collect:[:l | l asUppercase]].
    model respondTo:#modelsLowercaseText
	       with:[ plainText asStringCollection
			  collect:[:l | l asLowercase]].

    top := StandardSystemView extent:200@200.

    l := ListView origin:0.0 @ 0.0 corner:1.0 @ 0.5 in:top.
    l bottomInset:5; level:-1.

    l model:model.
    l aspect:#modelsAspect.
    l listMessage:#modelsUppercaseText.

    l := ListView origin:0.0 @ 0.5 corner:1.0 @ 1.0 in:top.
    l topInset:5; level:-1.

    l model:model.
    l aspect:#modelsAspect.
    l listMessage:#modelsLowercaseText.

    top open.

    Delay waitForSeconds:3.
    plainText := #('foo' 'bar' 'baz').
    model changed:#modelsAspect.

    Delay waitForSeconds:2.
    plainText := (PipeStream readingFrom:'ls') contents.
    model changed:#modelsAspect.
</CODE></PRE>
</A>




<H4>Scrolling</H4>

You will seldom need to scroll a listView directly - typically, they are
wrapped into a <CODE>ScrollableView</CODE> which does things for you.
<P>
However, it is sometimes useful to scroll the text automatically
for the user's convenience. For example, in an error-log view, you
may want to scroll to the end, or in a fileList, it is useful to
scroll to the position of the previously selected file.
<P>
The low level entries to scrolling are:
<UL>
<LI><CODE>scrollUp</CODE> / <CODE>scrollDown</CODE>
<BR>scroll a single line
<P>

<LI><CODE>scrollUp:</CODE>n / <CODE>scrollDown:</CODE>n
<BR>scroll a number of lines
<P>

<LI><CODE>scrollLeft</CODE> / <CODE>scrollRight</CODE>
<BR>scroll a single col
<P>

<LI><CODE>scrollLeft:</CODE>n / <CODE>scrollRight:</CODE>n
<BR>scroll a number of columns
<P>

<LI><CODE>scrollToLine:</CODE>nr / <CODE>scrollToCol:</CODE>nr
<BR>scroll to a given line /col
<P>

<LI><CODE>scrollToTop</CODE> / <CODE>scrollToBottom</CODE>
<BR>scroll to the begin / end of the text
<P>

<LI><CODE>scrollToLeft</CODE>
<BR>scroll to the very left
<P>

<LI><CODE>scrollHorizontalToPercent:</CODE>p / <CODE>scrollVerticalToPercent:</CODE>p
<BR>scroll to a position given relative to the texts size
<P>

<LI><CODE>pageUp</CODE> / <CODE>pageDown</CODE>
<BR>one full page (height of view) up / down
<P>

<LI><CODE>halfPageUp</CODE> / <CODE>halfPageDown</CODE>
<BR>half a page up / down

</UL>


conditional scrolling is supported by:
<UL>
<LI><CODE>makeLineVisible:</CODE>nr
<BR>scroll to make a lineNr visible; do not scroll if it is alredy visible
<P>

<LI><CODE>makeColVisible:</CODE>nr
<BR>scroll to make a column visible; do not scroll if it is alredy visible
<P>

<LI><CODE>makeVisible:</CODE>string
<BR>find the string in the text, scroll to make it visible
</UL>

Finally, asking for the current scroll position is done with:
<UL>
<LI>firstLineShown
<BR>return the lineNr of the top-visible line
<P>

<LI>lastLineShown
<BR>return the lineNr of the bottom-visible line.
<P>

<LI>lineIsVisible:nr
<BR>return true if a line is fully or partially visible.
(i.e. If the line is only partial visible, true is returned.)
<P>

<LI>lineIsFullyVisible:nr
<BR>return true if a line is fully visible.
(i.e. If the line is only partial visible, false is returned.)
</UL>



<H3><A HREF="#I_TEXT_TEXTVIEW" NAME="TEXT_TEXTVIEW">TextView - a view for readonly text</A></H3>

Like a <CODE>ListView</CODE>, a <CODE>TextView</CODE> knows how to
deal with a collection of text lines. In addition, it supports
a text selection, and provides the required user interaction.
<br>
<CODE>TextView</CODE> do not support editing - thus, they are
only useful for readonly text. For red/write texts,
see the <CODE>EditTextView</CODE> description
below.
<P>
Programmatically, the selection can be changed with:
<UL>
<LI><CODE>selectAll</CODE>
<BR>select all of the text
<P>

<LI><CODE>selectLine:</CODE> <VAR>lineNr</VAR>
<BR>select a single line
<P>

<LI><CODE>selectFromLine:</CODE> <VAR>startLine</VAR> <CODE>toLine:</CODE> <VAR>endLine</VAR>
<BR>select a line range
<P>

<LI><CODE>selectFromLine:</CODE> <VAR>startLine</VAR> <CODE>col:</CODE> <VAR>startCol</VAR> <CODE>toLine:</CODE> <VAR>endLine</VAR> <CODE>col:</CODE> <VAR>endCol</VAR>
<BR>select a line range
<P>

<LI><CODE>selectWordAtLine:</CODE> <VAR>lineNr</VAR> <CODE>col:</CODE> <VAR>colNr</VAR>
<BR>find the word around that position and select it
<P>

<LI><CODE>selectWordAtLine:</CODE> <VAR>lineNr</VAR> <CODE>col:</CODE> <VAR>colNr</VAR>
<BR>find the word around that position and select it
<P>

<LI><CODE>unselect</CODE>
<BR>unselect
<P>

</UL>
and retrieved with:
<UL>

<LI><CODE>hasSelection</CODE>
<BR>returns true, if there is a selection.
<P>

<LI><CODE>selection</CODE>
<BR>return the selection as a collection of strings, or nil.
Typically you may want to send <CODE>#asString</CODE> to the returned
object ... (if it's nonNil).
<P>

<LI><CODE>selectionStartLine</CODE>
<LI><CODE>selectionEndLine</CODE>
<LI><CODE>selectionStartCol</CODE>
<LI><CODE>selectionEndCol</CODE>
<BR>return the selections position
</UL>

Example:
<A type="example">
<PRE><CODE>
    |top textView|

    top := StandardSystemView extent:400@300.
    textView := TextView origin:0.0@0.0 corner:1.0@1.0 in:top.

    textView contents:('/etc/hosts' asFilename contentsOfEntireFile).
    top open.
</CODE></PRE>
</A>
Example (scrollable):
<A type="example">
<PRE><CODE>
    |top textView|

    top := StandardSystemView extent:400@300.
    textView := ScrollableView for:TextView in:top.
    textView origin:0.0 @ 0.0 corner:1.0 @ 1.0.
    textView contents:('/etc/hosts' asFilename contentsOfEntireFile).
    top open.
</CODE></PRE>
</A>



<H3><A HREF="#I_TEXT_EDITTEXTVIEW" NAME="TEXT_EDITTEXTVIEW">EditTextView - Editable Text</A></H3>


An <CODE>EditTextView</CODE> is similar to <CODE>TextView</CODE>,
with additional support for editing operations and a textCursor.
<BR>
Since the text can be modified, <CODE>EditTextView</CODE> offers a callBack
for the accept operation - either as a block (the <VAR>acceptAction</VAR>) or,
by sending a change notification to the views model (if there is a non-nil model).
<BR>
The cursors shape is controlled by the styleSheet - it may be any of
a blockCursor, caret or I-beam.
Although there exists public protocol to move the cursor programmatically,
this is seldom needed except for:
<UL>

<LI><CODE>cursorLine:</CODE> <VAR>lineNr</VAR> <CODE>col:</CODE> <VAR>colNr</VAR>
<BR>move the cursor to line/col
- if required, scroll to make the cursor visible.
<P>

<LI><CODE>cursorHome</CODE>
<BR>move the cursor to the very beginning of the text
and scroll as required to make the cursor visible.
<P>

<LI><CODE>cursorToBottom</CODE>
<BR>move the cursor to column 1 of the last line in the text;
if required, scroll to make the cursor visible.
<P>
</UL>

The interesting new features are the acceptAction and the modified state:
<BR>
The acceptAction (if set via <CODE>#acceptAction:</CODE>) will be evaluated,
and gets the views contents (a collection of lines) as argument.
<BR>
The modified state keeps track of any changes made to the text:
with every modification, is set to true automatically.
The textview never clears this flag automatically - it should be cleared by the
application, whenever the text is saved, or otherwise considered to be
unmodified via the <CODE>#modified:</CODE> message.
<BR>
For example:
<A type="example">
<PRE><CODE>
    |top textView|

    top := StandardSystemView extent:400@300.
    textView := EditTextView origin:0.0@0.0 corner:1.0@1.0 in:top.

    textView acceptAction:[:contents |
				textView modified ifTrue:[
				    Transcript showCR:'*** saving:'.
				    Transcript cr.
				    Transcript showCR:contents asString.

				    textView modified:false
				] ifFalse:[
				    Transcript showCR:'*** no save - not modified since last save'
				]
			  ].
    top open.
</CODE></PRE>
</A>


<H3><A HREF="#I_TEXT_TEXTCOLL" NAME="TEXT_TEXTCOLL">TextCollector - Streaming into a TextView</A></H3>

<BR>
<!-- XXX:START OF DOCU BY D.Q. -->

An <CODE>TextCollector</CODE> is similar to <CODE>EditTextView</CODE>,
with additional support for streaming operations.
<BR>
Its main use is for the Transcript.
<BR>
For example, to create a new transcript stream,
which receives the output of the previous example instead of the transcript,
try the following.:
<A type="example">
<PRE><CODE>

    |top textView nooTop nooOutputStream|
    nooTop :=   StandardSystemView extent:400@400 label:'noo output stream'.
    nooOutputStream := TextCollector origin:0.0@0.0 corner:1.0@1.0 in:nooTop.
    nooTop open.

    top := StandardSystemView extent:400@300.
    textView := EditTextView origin:0.0@0.0 corner:1.0@1.0 in:top.

    textView acceptAction:[:contents |
				textView modified ifTrue:[
				    nooOutputStream showCR:'*** saving:'.
				    nooOutputStream cr.
				    nooOutputStream showCR:contents asString.

				    textView modified:false
				] ifFalse:[
				    nooOutputStream showCR:'*** no save - not modified since last save'
				]
			  ].
    top open.
</CODE></PRE>
</A>

<H3><A HREF="#I_TEXT_WORKSPACE" NAME="TEXT_WORKSPACE">Workspace - Editable Text plus doIt</A></H3>

A view for editable text which can evaluate expressions.
I.e. its basically a view for editable text, with added
'doIt', 'printIt' and 'inspectIt' functions on the popup-menu.

The action to be performed on doIt is defined by a block,
which can be defined by the owner of this view.
(thus you can put a workspace into more complex widgets, and
control what should happen on 'doIt').

A useful default action is setup, which simply evaluates the
selection as a smalltalk expression.
(but, a lisp or prolog view could define its own action ...)
<BR>
"Try this:"
<A type="example">
<PRE><CODE>

    |top textView nooTop nooOutputStream|
    nooTop :=   StandardSystemView extent:400@400 label:'noo output stream'.
    nooOutputStream := Workspace origin:0.0@0.0 corner:1.0@1.0 in:nooTop.
    nooTop open.

    nooOutputStream showCR:'    |top b|'.
    nooOutputStream showCR:'    top := StandardSystemView label:''a button''.'.
    nooOutputStream showCR:'    top extent:100@100.'.

    nooOutputStream showCR:'    b := Button in:top.'.
    nooOutputStream showCR:'    b label:''press me''.'.
    nooOutputStream showCR:'    b origin:0.1@0.1 corner:0.9@0.9.'.
    nooOutputStream showCR:'    b action:[Transcript showCR:''hello there''].'.
    nooOutputStream showCR:'    top open'.

</CODE></PRE>
</A>

<H3><A HREF="#I_TEXT_CODEVIEW" NAME="TEXT_CODEVIEW">CodeView - Editable Source Code</A></H3>

A view for text which is known to be smalltalk code.
It adds explain to the menu, and defines another action:
explainAction to be performed for explain.

This action is to be defined by the user of this view
(i.e. ususally the owning browser)

If used with a model, accept sends the changeMsg to it (as defined in EditTextView).
(however, it is possible to define both changeMsg and acceptAction)

<BR>
"Try this:"
<A type="example">
<PRE><CODE>

    |top textView nooTop nooOutputStream|
    nooTop :=   StandardSystemView extent:400@400 label:'noo output stream'.
    nooOutputStream := CodeView origin:0.0@0.0 corner:1.0@1.0 in:nooTop.
    nooTop open.

    nooOutputStream showCR:'    |top b|'.
    nooOutputStream showCR:'    top := StandardSystemView label:''a button''.'.
    nooOutputStream showCR:'    top extent:100@100.'.

    nooOutputStream showCR:'    b := Button in:top.'.
    nooOutputStream showCR:'    b label:''press me''.'.
    nooOutputStream showCR:'    b origin:0.1@0.1 corner:0.9@0.9.'.
    nooOutputStream showCR:'    b action:[Transcript showCR:''hello there''].'.
    nooOutputStream showCR:'    top open'.

</CODE></PRE>
</A>

<H2><A HREF="#I_SELECTION" NAME="SELECTION">Selection Views</A></H2>

<H3><A HREF="#I_SELECTION_SELECTIONINLISTVIEW" NAME="SELECTION_SELECTIONINLISTVIEW">SelectionInListView - Single Selection in a List</A></H3>

A <CODE>SelectionInListView </CODE> is a <CODE>ListView</CODE> with a selected line, which is shown highlighted.
<BR>
"Try this:"
<A type="example">
<PRE><CODE>
	|top slv|

	top := StandardSystemView new
		label:'select';
		minExtent:100@100;
		maxExtent:300@400;
		extent:200@200.

	slv := SelectionInListView new.
	slv list:#('one' 'two' 'three').
	slv action:[:index | Transcript showCr:'selected ' , index printString].

	top add:slv in:(0.0@0.0 corner:1.0@1.0).
	top open
</CODE></PRE>
</A>

If toggleSelect is true, clicking toggles the selection, i.e. click on a seleted item will deselect the item.
<BR>
<BR>
"Try it with toggling:"
<A type="example">
<PRE><CODE>
	|top slv|

	top := StandardSystemView new
		label:'select';
		minExtent:100@100;
		maxExtent:300@400;
		extent:200@200.

	slv := SelectionInListView new.
	slv toggleSelect:true.
	slv list:#('one' 'two' 'three').
	slv selectElement:'one'.
	slv action:[:index | Transcript showCr:'selected ' , index printString , ' ', slv selectionValue printString].
	top add:slv in:(0.0@0.0 corner:1.0@1.0).
	top open.
</CODE></PRE>
</A>
Note that the selectElement method selects an initial value.
Note also that index can also be used as in the following example.
<BR>
A scrollable view can also be added:
<BR>
"Also with a scrollbar:"
<A type="example">
<PRE><CODE>
	|top slv|

	top := StandardSystemView new
		label:'select';
		minExtent:100@100;
		maxExtent:300@400;
		extent:150@150.

	slv := SelectionInListView new.
	slv toggleSelect:true; useIndex:false.

	slv list:#('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten' 'eleven' 'twelve' 'thirteen').
	slv selection:6.
	slv action:[:element | Transcript showCr:'selected ' , element printString].

	top add:(ScrollableView forView:slv)  in:(0.0@0.0 corner:1.0@1.0).
	top open
</CODE></PRE>
</A>

Note that using the index is advantageous if there are multiple instances of the same element.

<H4><A HREF="#I_SELECTION_MULTISELECTIONINLIST" NAME="SELECTION_MULTISELECTIONINLIST">MultiSelectionInList - Multiple Selections in a List</A></H4>

If multipleSelectionsOk is true, it is also allowed to shift-click multiple entries.

<BR>
"For example:"
<A type="example">
<PRE><CODE>
	|top slv|

	top := StandardSystemView new
		label:'select';
		minExtent:100@100;
		maxExtent:300@400;
		extent:200@200.

	slv := SelectionInListView new.
	slv toggleSelect:true; useIndex:false; multipleSelectOk:true.
	slv list:#('one' 'two' 'three' 'four' 'five'
		   'six' 'seven' 'eight' 'nine' 'ten'
		   'eleven' 'twelve' 'thirteen').
	slv action:[:element |
			Transcript showCr:'selected ' , element printString
		   ].
	slv makeSelectionVisible.
	top add:(ScrollableView forView:slv) in:(0.0@0.0 corner:1.0@1.0).
	top open
</CODE></PRE>
</A>

<H3><A HREF="#I_SELECTION_FILESELECTIONLISTVIEW" NAME="SELECTION_FILESELECTIONLISTVIEW">FileSelectionList - File Selections</A></H3>

A <CODE>FileSelectionList </CODE> is a file selection list.
It is basically a  <CODE>SelectionInListView</CODE> with some extra touches for directory selections,
for example, a matching pattern for filtering out unwanted files, a arrow mark for indicating directories,
an action block for doing something with the chosen directory,
and other little tidbits to be seen in the following examples.
<BR>
"Try this simple example:"
<A type="example">
<PRE><CODE>
	|list|

	list := FileSelectionList new.
	list open

</CODE></PRE>
</A>
"That wasn't bad. But a scroll bar would be nice, and showing the chosen file in the
transcript would also be advantageous."
<BR>
"A nicer example:"
<A type="example">
<PRE><CODE>

	|top v list|

	top := StandardSystemView new.
	top extent:(300 @ 200).
	v := ScrollableView for:FileSelectionList in:top.
	v origin:(0.0 @ 0.0) corner:(1.0 @ 1.0).
	list := v scrolledView.
	list action:[:index |
			Transcript showCr:'you selected: ' , list selectionValue
		    ].
	top open
</CODE></PRE>
</A>
<BR>
"The directories aren't necessary, so let's get rid of them."
<BR>
"Without the directories:"
<A type="example">
<PRE><CODE>
	|top v list|

	top := StandardSystemView new.
	top extent:(300 @ 200).
	v := ScrollableView for:FileSelectionList in:top.
	v origin:(0.0 @ 0.0) corner:(1.0 @ 1.0).
	list := v scrolledView.
	list ignoreDirectories:true.
	top open
</CODE></PRE>
</A>
"Or instead, let's just not show the directories as such:"
<BR>
"Directories without arrows:"
<A type="example">
<PRE><CODE>
	|top v list|

	top := StandardSystemView new.
	top extent:(300 @ 200).
	v := ScrollableView for:FileSelectionList in:top.
	v origin:(0.0 @ 0.0) corner:(1.0 @ 1.0).
	list := v scrolledView.
	list markDirectories:false.
	top open
</CODE></PRE>
</A>
"Next a filter can be set using the pattern method:"
<BR>
"A filtered list:"
<A type="example">
<PRE><CODE>
	|top v list|

	top := StandardSystemView new.
	top extent:(300 @ 200).
	v := ScrollableView for:FileSelectionList in:top.
	v origin:(0.0 @ 0.0) corner:(1.0 @ 1.0).
	list := v scrolledView.
	list pattern:'*.st'.
	list action:[:index |
			Transcript showCr:'you selected: ' , list selectionValue
		    ].
	top open
</CODE></PRE>
</A>
<BR>
"And finally, a more complex filter can be set using the matchBlock method:"
<BR>
"A complex filter showing only writable file and directories:"
<A type="example">
<PRE><CODE>
	|top v list|

	top := StandardSystemView new.
	top extent:(300 @ 200).
	v := ScrollableView for:FileSelectionList in:top.
	v origin:(0.0 @ 0.0) corner:(1.0 @ 1.0).
	list := v scrolledView.
	list matchBlock:[:name |
			    |fileName|
			    fileName := name asFilename.
			    fileName isWritable or:[fileName isDirectory]
			].
	list action:[:index | Transcript showCr:'you selected: ' , list selectionValue].
	top open
</CODE></PRE>
</A>

<H2><A HREF="#I_DIALOGS" NAME="DIALOGS">Dialog boxes</A></H2>


  All of the above was about non-modal topviews or views to be used as components
  for more complex views.
  Often you need to perform some user dialog, which stops him/her from interacting
  with the original view. Examples are popup menus, the save-box, the
  font-selection box and many others.
<P>

<H3><A HREF="#I_DIALOG_STD" NAME="DIALOG_STD">Standard Dialogs</A></H3>

There is a number of common dialog boxes already available in the system,
new ones are easily created by subclassing ModalBox or any other DialogView.

<H4><A HREF="#I_DIALOG_INFO" NAME="DIALOG_INFO">InfoBox - Information Display</A></H4>


  The simplest of these DialogBoxes is the InfoBox. It is used to output some
  information to the user, and stops its caller until the user confirms by
  pressing a button.
  Try:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b title:'how about this ?'.
    b show
</CODE></PRE>
</A>

Notice:
<BLOCKQUOTE>
    it can also be opened using <CODE>#open</CODE> or <CODE>#openModal</CODE>
(even <CODE>#openModeless</CODE> if you
    like).
    However, <CODE>#show</CODE> has been added to allow easier search on DialogBoxes using the
    browser - if all your DialogBoxes are opened with <CODE>#show</CODE>, you will find
    all places where modal boxes are used, by looking for senders of 'show*'.
    If you used <CODE>#open</CODE>, you still have to look at the code to decide if its a
    modalBox or regular view.)
</BLOCKQUOTE>
<P>
   Using <CODE>#show</CODE>, the box will open-up at some unspecified place on the screen.
<BR>
   Actually, it is either its default position, or the position where it
   was opened previously. This is almost always not the place, where you want
   the box to appear.
<P>
   Thus, you should either set its origin, as in:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b title:'how about this ?'.
    b origin:0@0.
    b show
</CODE></PRE>
</A>

   or:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b title:'how about this ?'.
    b origin:(Display extent - b extent).
    b show
</CODE></PRE>
</A>

   or, more convenient for the user, with:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b title:'how about this ?'.
    b showAtPointer
</CODE></PRE>
</A>

   here, the box will showup whereever the mouse-pointer is currently located.
   You should always use this to open your boxes, since it is more convenient
   for the person behind the glass (no mouse movement is needed for confirmation).
<P>
   If there is some other view, which you do not want to cover (usually the
   view which launched the box), you should use:
<PRE><CODE>
	b showAtPointerNotCovering:anotherView
</CODE></PRE>

   (where anotherView is typically 'self' in your program).
   Using this, the box will show itself either to the right or left of the
   specified view.
<P>
   The following example looks more complicated than needed, since in this
   immediate doit-evaluation, there is no self available:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b title:'how about this ?'.
    b showAtPointerNotCovering:(WindowGroup activeGroup topViews first)
</CODE></PRE>
</A>

   Finally, for very urgent information, use:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b title:'water in disk !!!!'.
    b showAtCenter
</CODE></PRE>
</A>

   This will open the box at the center of the screen.
<P>
   By the way: there is a shortcut available for creating AND setting the title
   of the box:

<A TYPE="example">
<PRE><CODE>
    (InfoBox title:'wow !') showAtPointer
</CODE></PRE>
</A>

   Also, every object understands another shortcut message: <CODE>#information:</CODE>.
   Which takes the argument as a titletext and opens an info box for it.
   Thus you can use:

<A TYPE="example">
<PRE><CODE>
    self information:'this''s simple'
</CODE></PRE>
</A>

   everywhere in your program.
<P>
   The reason for telling you about all the individual messages is that they
   allow more customized boxes to be set up. The easy-to-use box shown with
   the <CODE>#information</CODE> message is only a very general box.
<BR>
   For example:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b title:'this operation will flood your harddisk ?'.
    b okText:'are you certain ?'.
    b okButton enteredForegroundColor:(Color red).
    b formLabel foregroundColor:(Color red).
    b textLabel foregroundColor:(Color blue).
    b showAtPointer
</CODE></PRE>
</A>

   or:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := InfoBox new.
    b okText:'ok, refilled '.
    b okButton enteredBackgroundColor:(Color red lightened).
    b title:'Your printer is out of paper !\\please refill before continuing' withCRs.
    b image:(Image fromFile:'goodies/bitmaps/xpmBitmaps/device_images/ljet.xpm').
    b formLabel level:1.
    b textLabel foregroundColor:(Color red).
    b showAtPointer
</CODE></PRE>
</A>

   If you plan to use customized boxes as the above, it may be a good idea to
   create a subclass of WarnBox (say 'OutOfPaperBox') for the above - this makes
   certain, that all boxes look alike, saves code by not replicating this setup
   everywhere, and finally makes your program easier to maintain, since there is
   only one place you have to modify, in case changes have to be made.
<BR>
   i.e. (suggestion):
<PRE><CODE>

   InfoBox subclass:#OutOfPaperBox
	    instanceVariableNames:''
	    classVariableNames:''
	    poolDictionaries:''
	    category:'MyViews-DialogBoxes'

   !OutOfPaperBox class methodsFor:'instance creation'!

   new
       |b|

       b := super new.
       b okText:'ok, refilled '.
       b okButton enteredBackgroundColor:(Color red lightened).
       b title:'Your printer is out of paper !!\\please refill before continuing' withCRs.
       b image:(Image fromFile:'goodies/bitmaps/xpmBitmaps/device_images/ljet.xpm').
       b formLabel level:1.
       b textLabel foregroundColor:(Color red).
       ^ b
   ! !
</CODE></PRE>

   you can then show those boxes with:
<PRE><CODE>
    OutOfPaperBox new showAtPointer
</CODE></PRE>


<H4><A HREF="#I_DIALOG_WARN" NAME="DIALOG_WARN">WarningBox - Warnings</A></H4>


   A WarningBox is almost the same as an InfoBox; it simply uses a
   different (default) icon.  See the difference between:

<A TYPE="example">
<PRE><CODE>
    (InfoBox title:'wow !') showAtPointer
</CODE></PRE>
</A>

   and:

<A TYPE="example">
<PRE><CODE>
    (WarningBox title:'wow !') showAtPointer
</CODE></PRE>
</A>

   Also, WarningBoxes beep when coming up, while InfoBoxes are silent.
   Since warnings are also very common, there is a convenient message to create
   these:

<A TYPE="example">
<PRE><CODE>
    self warn:'something is wierd'
</CODE></PRE>
</A>

   WarningBoxes inherit from InfoBox.  Therefore all messages in InfoBox to access
   or modify their appearance can also be applied to them.


<H4><A HREF="#I_DIALOG_YESNO" NAME="DIALOG_YESNO">YesNoBox - yes/no Confirmations</A></H4>

  YesNoBoxes are for simple yes/no questions; they provide two buttons and have
  actions associated with both of them:

<A TYPE="example">
<PRE><CODE>
    |b result|

    b := YesNoBox new.
    b title:'do you like ST/X ?'.
    b yesAction:[result := true].
    b noAction:[result := false].
    b showAtPointer.

    self information:('the result was: ' , result printString).
</CODE></PRE>
</A>

    There are all kinds of things you can change in the look of the box. We will
    only look at a few things that are possible. For further information look into
    the box-classes with the browser.

<A TYPE="example">
<PRE><CODE>
    |b|

    b := YesNoBox new.
    b title:'something else'.
    b textLabel font:(Font family:'times' face:'bold' style:'roman' size:18).
    b okText:'wow great'.
    b noText:'mhmh'.
    b yesButton foregroundColor:(Color green).
    b image:(Image fromFile:'libtool/bitmaps/SmalltalkX.xbm').
    b yesAction:[Transcript showCR:'yes was pressed'].
    b noAction:[Transcript showCR:'no was pressed'].
    b showAtPointer
</CODE></PRE>
</A>

Also, if you are simply interested in the result of a simple yes/no question,
you can open the box with the confirm-message instead of defining the
action blocks:

<A TYPE="example">
<PRE><CODE>
    |b result|

    b := YesNoBox new.
    result := b confirm:'are you sure ?'.
    Transcript showCR:('the answer is ' , result printString)
</CODE></PRE>
</A>

In the above example, you really do not need the temporary variable 'b'.
Thus, the same can be done more condensed with:

<A TYPE="example">
<PRE><CODE>
    |result|

    result := YesNoBox new confirm:'are you sure ?'.
    Transcript showCR:('the answer is ' , result printString)
</CODE></PRE>
</A>

if you are asking multiple questions, the box can be reused, as in:

<A TYPE="example">
<PRE><CODE>
    |b result|

    b := YesNoBox new.
    result := b confirm:'are you sure ?'.
    result ifTrue:[
	result := b confirm:'definitely ?'.
	result ifTrue:[
	    result := b confirm:'absolutely certain ?'.
	    result ifTrue:[
		Transcript showCR:'ok'
	    ]
	]
    ]
</CODE></PRE>
</A>

  Since this kind of confirmation is also very common, there is a convenient
  shortcut too:

<A TYPE="example">
<PRE><CODE>
    |result|

    result := self confirm:'answer yes or no'
</CODE></PRE>
</A>

  This returns either true or false, depending on which button the user has pressed.
<P>
Since <CODE>#confirm:</CODE> is defined in <CODE>Object</CODE>, every receiver can be used for the #confirm:
message above (it works for every <VAR>self</VAR>).


<H4><A HREF="#I_DIALOG_ENTER" NAME="DIALOG_ENTER">EnterBox - Entry of a String</A></H4>


EnterBoxes allow the inputting of a string.
They will evaluate an actionBlock with the entered string as argument.

<A TYPE="example">
<PRE><CODE>
    |b|

    b := EnterBox new.
    b title:'enter your name, please'.
    b initialText:(OperatingSystem getLoginName).
    b action:[:theString | Transcript showCR:'the name is ' , theString].
    b showAtPointer.
</CODE></PRE>
</A>

The box does not evaluate the action-block if cancel is pressed.
Therefore you should be prepared for this, in your program:

<A TYPE="example">
<PRE><CODE>
    |b value|

    value := nil.
    b := EnterBox new.
    b title:'enter your name, please'.
    b initialText:(OperatingSystem getLoginName).
    b action:[:theString |  value := theString].
    b showAtPointer.

    value isNil ifTrue:[
	Transcript showCR:'operation cancelled'
    ] ifFalse:[
	Transcript showCR:'operation to be performed with ' , value
    ]
</CODE></PRE>
</A>

Since it is sometimes a bit inconvenient, to setup a box and define
all those actions, there are some standard messages prepared for the
most common queries. These are defined as class-messages of <CODE>EnterBox</CODE> and
<CODE>YesNoBox</CODE> (for compatibility with <CITE>ST-80</CITE>,
there are additional classes called
<CODE>DialogBox</CODE> and <CODE>Dialog</CODE> which also understand these).
<BR>
The above can also be written as:

<A TYPE="example">
<PRE><CODE>
    |b value|

    b := EnterBox new.
    b title:'enter your name, please'.
    b initialText:(OperatingSystem getLoginName).
    value := b request:'enter your name, please'.

    value isNil ifTrue:[
	Transcript showCR:'operation cancelled'
    ] ifFalse:[
	Transcript showCR:'operation to be performed with ' , value
    ]
</CODE></PRE>
</A>

Even more compact code is possible using class messages:

<A TYPE="example">
<PRE><CODE>
    |result|

    result := EnterBox request:'enter some string'.
    Transcript showCR:result.
</CODE></PRE>
</A>

or use the <CITE>ST-80</CITE> compatible:

<A TYPE="example">
<PRE><CODE>
    |result|

    result := Dialog request:'enter some string'.
    Transcript showCR:result.
</CODE></PRE>
</A>

Have a look at <CODE>DialogView</CODE> for more on this.


<H4><A HREF="#I_DIALOG_ENTER2" NAME="DIALOG_ENTER2">EnterBox2</A></H4>

This is like an EnterBox, but it adds a third button.
For example, the search box is of this type.
<BR>
This box adds another actionBlock, which is evaluated for the additional
button, and provides a protocol to set this and the additional buttons label.
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |b|

    b := EnterBox2 new.
    b title:'enter a fileName, please'.
    b initialText:'newFile'.
    b okText:'append'.
    b action:[:name | Transcript showCR:'you want to append to ' , name].
    b okText2:'save'.
    b action2:[:name | Transcript showCR:'you want to save to ' , name].
    b showAtPointer
</CODE></PRE>
</A>



<H4><A HREF="#I_DIALOG_OPTION" NAME="DIALOG_OPTION">OptionBox</A></H4>

An OptionBox is similar to an EnterBox, with an arbitrary number of option-buttons. This is a bit
more complicated to set up, which is why <CODE>EnterBox</CODE> and
<CODE>EnterBox2</CODE> have been
provided.
<BR>
See the optionBox's documentation protocol for examples.
<P>
A convenient interface (which sets up the box to return a value)
is:

<A TYPE="example">
<PRE><CODE>
    |what|

    what := OptionBox
		  request:'what do you want to do ?'
		  label:'Attention'
		  image:(WarningBox iconBitmap)
		  buttonLabels:#('abort' 'accept' 'continue')
		  values:#(#abort #accept #continue).
    Transcript showCR:'you selected: ' , what.
</CODE></PRE>
</A>

The returned value could be used with #perform for some real action.


<H4><A HREF="#I_DIALOG_TEXTBOX" NAME="DIALOG_TEXTBOX">TextBox</A></H4>

A TestBox is similar to an Enterbox, but allows input of more than one line of text.
<BR>
Actually, this is a tiny little text editor box!



<H4><A HREF="#I_DIALOG_LISTSELECTIONBOX" NAME="DIALOG_LISTSELECTIONBOX">ListSelectionBox</A></H4>

A ListSelectionBox is similar to an enterbox, but offers a list to choose from.

<A TYPE="example">
<PRE><CODE>
    |box|

    box := ListSelectionBox new.
    box title:'which color'.
    box list:#('red' 'green' 'blue' 'white' 'black').
    box action:[:aString | Transcript showCR:'selected: ' , aString].
    box showAtPointer
</CODE></PRE>
</A>

  You can also preset an initial string:

<A TYPE="example">
<PRE><CODE>
    |box|

    box := ListSelectionBox new.
    box title:'which color'.
    box list:#('red' 'green' 'blue' 'white' 'black').
    box action:[:aString | Transcript showCR:'selected: ' , aString].
    box initialText:'fooBar'.
    box showAtPointer
</CODE></PRE>
</A>


<H4><A HREF="#I_DIALOG_FILESELECTION" NAME="DIALOG_FILESELECTION">File Open &amp; Save Dialogs</A></H4>

<H5><A HREF="#I_DIALOG_FILESELECTIONBOX" NAME="DIALOG_FILESELECTIONBOX">FileSelectionBox - File Open Dialog</A></H5>

A <CODE>FileSelectionBox</CODE> looks like a <CODE>ListSelectionBox</CODE>,
but the list consists of the file names in a directory.
<BR>
For example:

<A TYPE="example">
<PRE><CODE>
    |box|

    box := FileSelectionBox new.
    box title:'which file ?'.
    box action:[:aString | Transcript showCR:'selected: ' , aString].
    box showAtPointer
</CODE></PRE>
</A>

  You can also specify the directory:

<A TYPE="example">
<PRE><CODE>
    |box|

    box := FileSelectionBox new.
    box directory:'/usr'.
    box title:'which file ?'.
    box action:[:aString | Transcript showCR:'selected: ' , aString].
    box showAtPointer
</CODE></PRE>
</A>

  and/or a filename-pattern:

<A TYPE="example">
<PRE><CODE>
    |box|

    box := FileSelectionBox new.
    box pattern:'*.st'.
    box directory:'../../libbasic'.
    box title:'which file ?'.
    box action:[:aString | Transcript showCR:'selected: ' , aString].
    box showAtPointer
</CODE></PRE>
</A>

  and/or a filterBlock to select which filenames are shown:

<A TYPE="example">
<PRE><CODE>
    |box|

    box := FileSelectionBox new.
    box pattern:'*.st'.
    box matchBlock:[:fileName | fileName first between:$A and:$F].
    box directory:'../../libbasic'.
    box title:'which file ?'.
    box action:[:aString | Transcript showCR:'selected: ' , aString].
    box showAtPointer
</CODE></PRE>
</A>

the box remembers its last directory and filename. Therefore, you may
reuse the old box in your application instead of recreating new ones.
<BR>
This makes certain, that the user gets some convenient default directory
when the box shows up, i.e. the last directory.
<P>
To see how this works, evaluate the following code, then change the
directory in the first box and press ok.
<BR>
The second box will show up with the last directory:

<A TYPE="example">
<PRE><CODE>
    |box|

    box := FileSelectionBox new.
    box title:'which file ?'.
    box action:[:aString | Transcript showCR:'selected: ' , aString].
    box showAtPointer.

    box title:'again - which file ?'.
    box action:[:aString | Transcript showCR:'selected2: ' , aString].
    box showAtPointer
</CODE></PRE>
</A>

The FileSelectionBox uses an instance of <CODE>FileSelectionList</CODE>
to show the fileNames and handle selection.
That class offers alot of options to control which files are shown
(matchBlocks &amp; name patterns). Also, it is possible to disable
a change into other directories or to hide either regular files
or directories completely.
<P>
For most standard queries, convenient class methods are available
(for compatibility: in the <CODE>Dialog</CODE> class.
<BR>
If you simply want to query for a fileName, use something such as:

<A TYPE="example">
<PRE><CODE>
    |fileName|

    fileName := Dialog requestFileName:'which file ?'.
    Transcript showCR:'the name is: ' , fileName.
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    |fileName|

    fileName := Dialog requestFileName:'which file ?' default:'foo'.
    Transcript showCR:'the name is: ' , fileName.
</CODE></PRE>
</A>

To ask for a directory name, use:

<A TYPE="example">
<PRE><CODE>
    |fileName|

    fileName := Dialog requestDirectoryName:'which directory ?'.
    Transcript showCR:'the name is: ' , fileName.
</CODE></PRE>
</A>

There are a few more of these request methods available - see
the <CODE>DialogBoxes</CODE> class protocol.


<H5><A HREF="#I_DIALOG_FILESAVEBOX" NAME="DIALOG_FILESAVEBOX">FileSaveBox - File Save Dialog</A></H5>

A FileSaveBox is similar to a FileSelectionBox, with 2 buttons labeled <VAR>append</VAR> and <VAR>save</VAR>.
The action of the new button is defined with <CODE>appendAction:</CODE>
<BR>
as in:

<A TYPE="example">
<PRE><CODE>
    |box|

    box := FileSaveBox new.
    box title:'which file ?'.
    box action:[:aString | Transcript showCR:'save to: ' , aString].
    box appendAction:[:aString | Transcript showCR:'append to: ' , aString].
    box showAtPointer
</CODE></PRE>
</A>


<H4><A HREF="#I_DIALOG_FONTPANEL" NAME="DIALOG_FONTPANEL">FontPanel - Choosing a Font</A></H4>

This dialog allows the choosing of a font.
The box will evaluate its actionBlock, passing the chosen font as an argument.

<A TYPE="example">
<PRE><CODE>
    |box|

    box := FontPanel new.
    box action:[:aFont | Transcript showCR:'font is: ' , aFont].
    box showAtPointer
</CODE></PRE>
</A>


<H3><A HREF="#I_DIALOG_COMPATIBILITY" NAME="DIALOG_COMPATIBILITY">Dialog Compatibility Protocol</A></H3>

Some of the above dialogs are (for historical) reasons implemented by
separate subclasses of <CODE>DialogBox</CODE>.
However, for compatibility with <CITE>ST-80</CITE>,
dialogBox offers class methods which create and show these dialogs.
<BR>
You should use messages to <CODE>Dialog</CODE> for compatibility with future versions
and with other smalltalk systems.
<BR>
The corresponding messages are
<BR>
for notifications:

<A TYPE="example">
<PRE><CODE>
    Dialog information:'hello there'.
</CODE></PRE>
</A>

for warnings:

<A TYPE="example">
<PRE><CODE>
    Dialog warn:'oops - something happened'.
</CODE></PRE>
</A>

for simple boolean questions (returns true or false):

<A TYPE="example">
<PRE><CODE>
    |answer|

    answer :=  Dialog confirm:'yes or no ?'.
</CODE></PRE>
</A>

with cancel (if cancelled, the returned value is nil):

<A TYPE="example">
<PRE><CODE>
    |answer|

    answer :=  Dialog confirmWithCancel:'yes or no ?'.
</CODE></PRE>
</A>

multiple choice entry (returns corresponding entry from values arg):

<A TYPE="example">
<PRE><CODE>
    |answer|

    answer :=  Dialog
		    choose:'choose any'
		    labels:#('one' 'two' 'three' 'four')
		    values:#(1 2 3 4)
		    default:2
</CODE></PRE>
</A>

to ask for a string (returns nil, if cancelled):

<A TYPE="example">
<PRE><CODE>
    |answer|

    answer :=  Dialog request:'enter your name here:'.
</CODE></PRE>
</A>

as above, with an initial string:

<A TYPE="example">
<PRE><CODE>
    |answer|

    answer :=  Dialog request:'enter your name here:'
		      initialAnswer:'foo-user'.
</CODE></PRE>
</A>

for password entry, the typed input is invisible in:

<A TYPE="example">
<PRE><CODE>
    |answer|

    answer :=  Dialog requestPassword:'enter secret code:'
</CODE></PRE>
</A>

to enter a fileName (returns nil if cancelled):

<A TYPE="example">
<PRE><CODE>
    |answer|

    answer :=  Dialog requestFileName:'enter a filename here:'
		      default:'newFile'.
</CODE></PRE>
</A>










<H3><A HREF="#I_DIALOG_CUSTOM" NAME="DIALOG_CUSTOM">Custom Dialogs</A></H3>

<PRE>
 Text about how custom dialogs are created using the Dialog class
 to be added here.

 For now, see examples in DialogBox's documentation category.
</PRE>

<H2><A HREF="#I_POPUPS" NAME="POPUPS">Popup Menus</A></H2>


  PopUpMenus are typically defined with an array of label-strings and an array of selectors.
  When activated, a message with a selector corresponding to the selected entry will be sent
  to some object.
<BR>
  The simplest way of defining a popupmenu is:
<PRE><CODE>
    |aMenu|

    aMenu := PopUpMenu
		    labels:#('foo' 'bar')
		    selectors:#(doFoo doBar)
		    receiver:someObject
</CODE></PRE>

  the menu is shown with:
<PRE><CODE>
    aMenu showAtPointer
</CODE></PRE>
When activated, the menu will send a <CODE>#doFoo</CODE> or <CODE>#doBar</CODE>
message to <VAR>someObject</VAR>.
<P>
In some situations, it is more convenient to use the same selector
for all menu entries and provide different arguments.
<BR>
This can be done by creating the menu via:
<PRE><CODE>
    |aMenu|

    aMenu := PopUpMenu
		    labels:#('foo' 'bar')
		    selector:#someSelector:
		    args:#( 'argForFoo' 'argForBar')
		    receiver:someObject
</CODE></PRE>
When activated, the menu will send <CODE>#someSelector:'argForFoo'</CODE>
and <CODE>#someSelector:'argForBar'</CODE> respectively.
<P>
Finally, the most general setup is by defining individual selector/argument
combinations for every menu entry:
<PRE><CODE>
    |aMenu|

    aMenu := PopUpMenu
		    labels:#('foo' 'bar' 'baz')
		    selectors:#(doFoo: doBar doBaz:)
		    args:#( 'argForFoo' nil 'argForBaz')
		    receiver:someObject
</CODE></PRE>


<H3><A HREF="#I_POPUPS_MIDDLE" NAME="POPUPS_MIDDLE">Defining a Middle Button Menu </A></H3>

Usually, popUpMenus are associated with the middle-mouse button.
The handling of this is done in some superclass of all views,
so you normally do not have to care about the details of opening and closing
these menus.
<BR>
There are two principle ways to define a views menu:
<UL>
<LI>as a <VAR>static</VAR> menu
<BR>
Every view can get a popupMenu by sending it the
<CODE>#middleButtonMenu:</CODE> message with the menu as an argument.
<BR>
The view remembers this menu and shows it whenever the middle Button is pressed.
<BR>
Menus are typically defined as static menus if
you have to define a views menu from the outside.

(For example, to give a menu to some view, which does not provide
a menu or, if you want to overwrite the views builtin menu)
or if the menu remains the same over the whole lifetime of its view.

<P>
<LI>as a <VAR>dynamic</VAR> menu
<BR>
Views which have no static menu, will be asked to provide
an appropriate menu when the middle button is pressed.
This menu will be used for that single popUp only, and not reused.
<BR>
Menus are typically defined as dynamic menus if
the menus entries should depend on some other conditions, such as
the current selection. Or, if totally different menus are to be shown
as appropriate.
</UL>
The next examples use static menus, since these are easier to handle
in these isolated examples.
We will learn how dynamic menus are handled in a minute ...

<P>
Try the following:

<A TYPE="example">
<PRE><CODE>
    |myView myMenu|

    myView := View new.
    myMenu := PopUpMenu
		    labels:#('foo' 'bar')
		    selectors:#(doFoo doBar)
		    receiver:myView.
    myView middleButtonMenu:myMenu.
    myView open
</CODE></PRE>
</A>

(if you try this example, be prepared to have a debugger come up - the view
will of course not understand any foo-bar messages.
<BR>
Simply press 'continue' or 'abort' to leave the debugger)
<P>
    For a working example, try:

<A TYPE="example">
<PRE><CODE>
    |v m|

    v := View new.
    m := PopUpMenu
	    labels:#('lower'
		     'raise'
		     '-'
		     'destroy')
	    selectors:#(#lower #raise nil #destroy)
	    receiver:v.
    v middleButtonMenu:m.
    v open
</CODE></PRE>
</A>

This example also shows how grouping lines are added to a menu.
The item labels <CODE>'-'</CODE> and <CODE>'='</CODE> are
drawn as single and double separating lines respectively.
If (which is unlikely) you need these item labels, use <CODE>'\-'</CODE>
and <CODE>'\='</CODE> respectively.

<BR>
(For ST-80 compatibility, menus can also be created by passing the line
information in an extra argument, as described below.)
<P>
Sometimes, you want to specify both selectors and arguments
to be sent; this is done by:

<A TYPE="example">
<PRE><CODE>
    |v m|

    v := View new.
    m := PopUpMenu
	    labels:#('foo' 'bar' 'baz')
	    selectors:#(#foo: #bar: #foo:)
	    args:#(1 2 3)
	    receiver:nil.
    v middleButtonMenu:m.
    v open.
</CODE></PRE>
</A>

   you may mix selectors for methods with and without arguments;
   but only 0 (zero) or 1 (one) argument selectors are allowed:

<A TYPE="example">
<PRE><CODE>
    |v m|

    v := View new.
    m := PopUpMenu
	    labels:#('foo' 'bar' 'baz')
	    selectors:#(#foo: #bar #foo:)
	    args:#(1 'ignored' 3)
	    receiver:nil.
    v middleButtonMenu:m.
    v open.
</CODE></PRE>
</A>

    or, have the menu send the same selector but pass different arguments:

<A TYPE="example">
<PRE><CODE>
    |v m|

    v := View new.
    m := PopUpMenu
	    labels:#('foo' 'bar' 'baz')
	    selectors:#foo:
	    args:#(1 2 3)
	    receiver:nil.
    v middleButtonMenu:m.
    v open.
</CODE></PRE>
</A>


<H3><A HREF="#I_POPUPS_CHECK" NAME="POPUPS_CHECK">Check-Mark Entries </A></H3>


    It is also possible, to add check-mark entries, with an entry string
    starting with the special sequence <CODE>'\c'</CODE> (for check-mark).
    The value passed with the items message will be the truth state of the
    check-mark (i.e. true or false).

<A TYPE="example">
<PRE><CODE>
    |m v|

    v := View new.
    m := PopUpMenu
	    labels:#('\c foo'
		     '\c bar')
	    selectors:#(#value: #value:)
	    receiver:[:v | Transcript show:'arg: '; showCR:v].
    v middleButtonMenu:m.
    v open
</CODE></PRE>
</A>

Currently, three different types of checkmarks are supported,
choosen by different special sequences:
<UL>
<LI><CODE>'\c'</CODE> - simple check mark
<LI><CODE>'\b'</CODE> - a check box
<LI><CODE>'\t'</CODE> - a thumbsUp/thumbsDown check mark
</UL>
as demonstrated in the following menu:

<A TYPE="example">
<PRE><CODE>
    |m v|

    v := View new.
    m := PopUpMenu
	    labels:#('\c foo'
		     '\c bar'
		     '-'
		     '\b more foo'
		     '\b more bar'
		     '='
		     '\t all right'
		    )
	    selectors:#value:
	    receiver:[:v | Transcript show:'arg: '; showCR:v].
    v middleButtonMenu:m.
    v open
</CODE></PRE>
</A>


The current scheme is somewhat limited, in only providing
3 different (and hardcoded) check mark types.
Future versions may provide more flexible checkmarks.
<BR>
Currently, these special sequences cannot be used as plain item labels
(you have to add a space or any other character to trick the menu)


<H3><A HREF="#I_POPUPS_WRAP" NAME="POPUPS_WRAP">Wrapping Arbitrary Views as Popups </A></H3>

    You can wrap any other view into a popup menu
    (for example, to implement menus with icons or other components).
    The wrapped view should respond to some messages sent from popupmenu
    (for example: <CODE>#hideSubmenus</CODE>, <CODE>#deselectWithoutRedraw</CODE>
    and others), see
    the <CODE>MenuView</CODE> classes protocol or have a look at the
    implementation of the <CODE>PatternMenu</CODE> class,
    or just try and see where you reach the debugger ;-).
<P>
    For the curious: this wrappability is the reason for the somewhat complicated
    separation of menus into a <CODE>PopUpMenu</CODE> class which
    handles the basic popping and a <CODE>MenuView</CODE> class, which
    actually displays the menu.
<P>
    Currently there is only one class in the system,
    which is prepared and can be used
    this way (<CODE>PatternMenu</CODE> in the DrawTool demo).
<BR>
    <CODE>PatternMenu</CODE> has been declared
    as subclass of <CODE>MenuView</CODE> - so it automatically understands all these messages.

<A TYPE="example">
<PRE><CODE>
    |v p|

    v := View new.
    p := PatternMenu new.
    p patterns:(Array with:Color red
		      with:Color green
		      with:Color blue).
    v middleButtonMenu:(PopUpMenu forMenu:p).
    v open
</CODE></PRE>
</A>

    or try:
    (have a careful look at the receiver of the menu-message ;-)

<A TYPE="example">
<PRE><CODE>
    |v p|

    v := View new.
    p := PatternMenu new.
    p patterns:(Array with:Color red
		      with:Color green
		      with:Color blue).
    p selectors:#value:.
    p receiver:[:val | v viewBackground:val. v clear].
    p args:(Array with:Color red
		  with:Color green
		  with:Color blue).
    v middleButtonMenu:(PopUpMenu forMenu:p).
    v open
</CODE></PRE>
</A>

    or even (see below for more on submenus):

<A TYPE="example">
<PRE><CODE>
    |v pMain pRed pGreen pBlue colors|

    v := View new.
    pMain := PatternMenu new.
    pMain patterns:(Array with:Color red
			  with:Color green
			  with:Color blue).
    pMain selectors:#(red green blue).

    pRed := PatternMenu new.
    colors := (Array with:(Color red:100 green:0 blue:0)
		     with:(Color red:75 green:0 blue:0)
		     with:(Color red:50 green:0 blue:0)
		     with:(Color red:25 green:0 blue:0)).

    pRed patterns:colors.
    pRed selectors:#value:.
    pRed args:colors.
    pRed receiver:[:val | v viewBackground:val. v clear].
    pRed windowRatio:(4 @ 1).
    pMain subMenuAt:#red put:(PopUpMenu forMenu:pRed).

    pGreen := PatternMenu new.
    colors := (Array with:(Color red:0 green:100 blue:0)
		     with:(Color red:0 green:75 blue:0)
		     with:(Color red:0 green:50 blue:0)
		     with:(Color red:0 green:25 blue:0)).

    pGreen patterns:colors.
    pGreen selectors:#value:.
    pGreen args:colors.
    pGreen receiver:[:val | v viewBackground:val. v clear].
    pGreen windowRatio:(2 @ 2).
    pMain subMenuAt:#green put:(PopUpMenu forMenu:pGreen).

    pBlue := PatternMenu new.
    colors := (Array with:(Color red:0 green:0 blue:100)
		     with:(Color red:0 green:0 blue:75)
		     with:(Color red:0 green:0 blue:50)
		     with:(Color red:0 green:0 blue:25)).

    pBlue patterns:colors.
    pBlue selectors:#value:.
    pBlue args:colors.
    pBlue receiver:[:val | v viewBackground:val. v clear].
    pBlue windowRatio:(1 @ 4).
    pMain subMenuAt:#blue put:(PopUpMenu forMenu:pBlue).

    v middleButtonMenu:(PopUpMenu forMenu:pMain).

    v open
</CODE></PRE>
</A>

  You will find some more examples in the PatternMenus class documentation.

<P>

  Static menus can be used with any other view
  - the following adds one to a button:

<A TYPE="example">
<PRE><CODE>
    |top b|

    top := StandardSystemView label:'a button'.
    top extent:100@100.

    b := Button in:top.
    b label:'press me'.
    b origin:0.1@0.1 corner:0.9@0.9.
    b  middleButtonMenu:(PopUpMenu labels:#('foo' 'bar')).
    top open

</CODE></PRE>
</A>

  The buttons left-mouse-button functionality is not affected by the
  added middle-button menu.
<P>
  BTW: this is how PopUpList is implemented.





<H3><A HREF="#I_POPUPS_ST80" NAME="POPUPS_ST80">ST-80 Style Menus </A></H3>

    The above menus all did some message send on selection; it is
    also possible, to use <CITE>Smalltalk-80</CITE> style menus (which return some value
    from their startup method):

<A TYPE="example">
<PRE><CODE>
    |m selection|

    m := PopUpMenu
	    labels:#('one' 'two' 'three').
    selection := m startUp.
    Transcript show:'the selection was: '; showCR:selection
</CODE></PRE>
</A>

    startUp will return the entries index, or 0 if there was no selection.
    You can also specify an array of values to be returned instead of the
    index:

<A TYPE="example">
<PRE><CODE>
    |m selection|

    m := PopUpMenu
	    labels:#('one' 'two' 'three')
	    values:#(10 20 30).
    selection := m startUp.
    Transcript show:'the value was: '; showCR:selection
</CODE></PRE>
</A>

    In <CITE>ST/X</CITE> style menus, separating lines between entries are created
    by a <CODE>'-'</CODE>-string as its label text (and corresponding nil-entries in the
    selectors- and args-arrays).
    In <CITE>ST-80</CITE>, you have to pass the indices of the lines in an extra array:

<A TYPE="example">
<PRE><CODE>
    |m selection|

    m := PopUpMenu
	    labels:#('one' 'two' 'three' 'four' 'five')
	    lines:#(2 4).
    selection := m startUp.
    Transcript show:'the value was: '; showCR:selection
</CODE></PRE>
</A>

    or:

<A TYPE="example">
<PRE><CODE>
    |m selection|

    m := PopUpMenu
	    labels:#('one' 'two' 'three')
	    lines:#(2)
	    values:#(10 20 30).
    selection := m startUp.
    Transcript show:'the value was: '; showCR:selection
</CODE></PRE>
</A>

    Use whichever interface (<CITE>ST-80</CITE> or <CITE>ST/X</CITE>) you prefer.






<H3><A HREF="#I_POPUPS_SUBMENU" NAME="POPUPS_SUBMENU">Defining Submenus</A></H3>

    Submenus are created by changing an entry using <CODE>#subMenuAt:put:</CODE>.
<BR>
    For example:

<A TYPE="example">
<PRE><CODE>
    |v main sub|

    v := View new.
    main := PopUpMenu
	    labels:#('foo' 'bar' '-' 'more')
	    selectors:#(#foo #bar nil #more)
	    receiver:nil.

    sub := PopUpMenu
	    labels:#('more foo' 'more bar')
	    selectors:#(moreFoo moreBar)
	    receiver:nil.

    main subMenuAt:#more put:sub.

    v middleButtonMenu:main.
    v open.
</CODE></PRE>
</A>

    The index (first argument) to the <CODE>subMenuAt:put:</CODE> message may
    be either an entry label-text, a numeric index starting at 1,
    or the selector. Please use the selector, since the string could
    be different for national variants.
    Also the numeric index may change as your menu gets more indices.
    (see below on how to dynamically add/remove entries).






<H3><A HREF="#I_POPUPS_ADDREMOVE" NAME="POPUPS_ADDREMOVE">Dynamically adding/removing Menu Entries</A></H3>

    You can get the index of an existing entry with:
<PRE><CODE>
	aMenu indexOf:someKey
</CODE></PRE>

    where key can be a selector or an entries text (again use the selector).
<BR>
    Then, add new entries with:
<PRE><CODE>
	aMenu addLabel:'something' selector:#foo after:anIndex
</CODE></PRE>

    or, to add a submenu:
<PRE><CODE>
	aMenu addLabel:'something' selector:#foo after:anIndex
	aMenu subMenuAt:(anIndex + 1) put:aNewSubmenu.
</CODE></PRE>

    In analogy, entries are removed with:
<PRE><CODE>
	aMenu remove:someIndex
</CODE></PRE>

    where index is again, either numeric, a selector or an entries text.
<P>
    Finally, you can change both label and selector of entries:
<PRE><CODE>
	aMenu labelAt:index put:'newLabel'
</CODE></PRE>

    and:
<PRE><CODE>
	aMenu selectorAt:index put:#fooBar
</CODE></PRE>

    Lets wrap all this into an example:
    (I use a block as the receiver here since in this doIt-example,
     there is no class to implement the messages sent from the menu.
     In real programs, the receiver is either some view or model.
     The message sent is then some action-methods message, instead of <CODE>#value:</CODE>)

<A TYPE="example">
<PRE><CODE>
    |v menu action|

    action := [:action |
	    action == #add ifTrue:[
		    menu addLabel:'newLabel'
			 selector:#newFunction
			 after:2
	    ].
	    action == #remove ifTrue:[
		    menu remove:#newFunction
	    ]
    ].

    v := View new.
    menu := PopUpMenu
	    labels:#('add' 'remove')
	    selectors:#(#value: #value:)
	    args:#(add remove)
	    receiver:action.

    v middleButtonMenu:menu.
    v open.
</CODE></PRE>
</A>






<H3><A HREF="#I_POPUPS_DYNAMIC" NAME="POPUPS_DYNAMIC">Dynamic Menus</A></H3>

In most of the previous examples, menus were statically set via the
<CODE>#middleButtonMenu:</CODE> message.
<BR>
In contrast, dynamic menus are created on demand - actually they are created
at button press time, and can therefore be easier adapted to
the current state of the view (often: on the current selection).
<BR>
To do this, there must be some instance which provides the menu - this
is called the <VAR>menuHolder</VAR>.
By default (if not set otherwise), a views menuHolder is its model,
or, if it has no model, its the view itself.
<BR>
(however, a subclass of <CODE>View</CODE>
 may redefine the <CODE>#menuHolder</CODE> message, and return something else).
<P>
The menuHolder (i.e. either the model or the view itself) is asked for
the menu by being sent a <VAR>menuMessage</VAR>.
This selector can be defined for any view via
'<CODE>menuMessage:<VAR>aSelector</VAR></CODE>'.
All views which can operate both with and without a model
preset the menuMessage to something they understand and
respond with an appropriate menu
- you do not have to care for this if no model is involved.
<BR>
However, if you set a views model, it must respond to the menuMessage
and return either nil or an appropriate popupMenu.
<P>
Lets put this theory into a more concrete example;

<A TYPE="example">
<PRE><CODE>
    |model view|

    model := Plug new.
    model respondTo:#modelsMenu with:[PopUpMenu labels:#('foo' 'bar')
					     selectors:#(foo bar)].

    view := View on:model.
    view menuMessage:#modelsMenu.

    view open
</CODE></PRE>
</A>

of course, the model should respond to <CODE>#foo</CODE> and <CODE>#bar</CODE>;
to make things more interesting, lets make the models menu response dependent
on some internal models state:

<A TYPE="example">
<PRE><CODE>
    |model state view|

    state := #fooState.

    model := Plug new.
    model respondTo:#modelsMenu with:[
			    state == #fooState ifTrue:[
				PopUpMenu
				    labels:#('foo' 'bar')
				    selectors:#(foo bar)
			    ] ifFalse:[
				PopUpMenu
				    labels:#('jabbadabbadooo')
				    selectors:#(jabberwoky)
			    ]].
    model respondTo:#jabberwoky with:[state := #fooState].
    model respondTo:#foo        with:[state := nil].
    model respondTo:#bar        with:[state := nil].


    view := View on:model.
    view menuMessage:#modelsMenu.

    view open
</CODE></PRE>
</A>

The above was a somewhat simple example,
in that the view has no builtin default menu.
<BR>
For views which offer their own menu (all text views do),
there is a slight complication introduced by the fact that
you may want to have the view operate on the model,
but do not want to redefine its menu.
(i.e. you would like to keep the views default menu)
<BR>
To allow for this setup (i.e. having a non-nil model <STRONG>and</STRONG>
use the views menu), and provide a useful default setup,
all view classes which operate on text and have a builtin menu,
allow for redefinition of the menuHolder and menuPerformer.
<BR>
Setting an explicit menuHolder defines the instance which shall provide the menu
(it defaults to the model). Setting the menuPerformer defines the instance which
shall get the menu messages (this defaults to the view).
<BR>
First a (half working) example:

<A TYPE="example">
<PRE><CODE>
    |model modelsText view|

    modelsText := 'hello world'.

    model := Plug new.
    model respondTo:#modelsText
	       with:[modelsText].
    model respondTo:#modelsText:
	       with:[:arg |
			modelsText := arg.
			Transcript showCR:'new text: ' , arg
		    ].

    model respondTo:#modelsMenu
	       with:[PopUpMenu
			labels:#('copy' 'cut' 'paste' -
				 'accept' '-' 'foo' 'bar')
			selectors:#(copySelection cut paste nil
				    accept nil foo bar)
		    ].

    view := EditTextView on:model.
    view aspect:#text; listMessage:#modelsText; changeMessage:#modelsText:.
    view menuMessage:#modelsMenu.

    view open
</CODE></PRE>
</A>

in the above, the model provides the menu, but menu messages are still sent to the view
- which does of course not respond to the #foo message.
(however, editing works)
<BR>
Setting the menuPerformer, we get:

<A TYPE="example">
<PRE><CODE>
    |model modelsText view|

    modelsText := 'hello world'.

    model := Plug new.
    model respondTo:#foo
	       with:[Transcript showCR:'the foo action'].
    model respondTo:#modelsText
	       with:[modelsText].
    model respondTo:#modelsText:
	       with:[:arg |
			modelsText := arg.
			Transcript showCR:'new text: ' , arg
		    ].

    model respondTo:#modelsMenu
	       with:[PopUpMenu
			labels:#('copy' 'cut' 'paste' -
				 'accept' '-' 'foo' 'bar')
			selectors:#(copySelection cut paste nil
				    accept nil foo bar)
		    ].

    view := EditTextView on:model.
    view aspect:#text; listMessage:#modelsText; changeMessage:#modelsText:.
    view menuMessage:#modelsMenu.
    view menuPerformer:model.

    view open
</CODE></PRE>
</A>

But now, you may ask yourself, what happens with the copy-cut-paste messages
which are to be performed by the view (not the model).
<BR>
This is already handled, with a little trick: if the menuPerformer does not respond to
a menu message, it is retried for the view.
Thus in the above example, copy-cut-paste are performed by the
view while the other messages are sent to the model.
<BR>
You may even have some of the views messages be sent in the model
(because it comes first in the try-sequence):

<A TYPE="example">
<PRE><CODE>
    |model modelsText view|

    modelsText := 'hello world'.

    model := Plug new.
    model respondTo:#foo
	       with:[Transcript showCR:'the foo action'].
    model respondTo:#cut
	       with:[Transcript showCR:'no menu cut allowed'].
    model respondTo:#modelsText
	       with:[modelsText].
    model respondTo:#modelsText:
	       with:[:arg |
			modelsText := arg.
			Transcript showCR:'new text: ' , arg
		    ].

    model respondTo:#modelsMenu
	       with:[PopUpMenu
			labels:#('copy' 'cut' 'paste' -
				 'accept' '-' 'foo' 'bar')
			selectors:#(copySelection cut paste nil
				    accept nil foo bar)
		    ].

    view := EditTextView on:model.
    view aspect:#text;
	 listMessage:#modelsText;
	 changeMessage:#modelsText:.
    view menuMessage:#modelsMenu.
    view menuPerformer:model.

    view open
</CODE></PRE>
</A>


<H2><A HREF="#I_PULLDOWN" NAME="PULLDOWN">Pulldown Menus </A></H2>

PullDownMenus are created as a subview (typically) in a StandardSystem view:

<A TYPE="example">
<PRE><CODE>
    |topView menu|

    topView := StandardSystemView new.
    menu := PullDownMenu in:topView.

    topView open
</CODE></PRE>
</A>

it sets its origin and extend to some useful default (full width);
<BR>
however, modifications are possible, as in:

<A TYPE="example">
<PRE><CODE>
    |topView menu|

    topView := StandardSystemView new.
    menu := PullDownMenu in:topView.
    menu origin:0.0 @ 0.0 corner:(0.5 @ menu height).

    topView open
</CODE></PRE>
</A>

notice, that in the above example, the menus current height is used - this is
its default height, which it computed from the fonts height.
<P>
its items are defined with the <CODE>#labels:</CODE> message, passing
a collection of string labels:

<A TYPE="example">
<PRE><CODE>
    |topView menu|

    topView := StandardSystemView new.
    topView extent:400@400.

    menu := PullDownMenu in:topView.
    menu origin:0.0 @ 0.0 corner:(0.5 @ menu height).

    menu labels:#('about' 'file' 'help').
    topView open
</CODE></PRE>
</A>

to access the items further, each one should be associated with some
key; this is done with the <CODE>selectors:</CODE> message:

<A TYPE="example">
<PRE><CODE>
    |topView menu|

    topView := StandardSystemView new.
    topView extent:400@400.

    menu := PullDownMenu in:topView.
    menu origin:0.0 @ 0.0 corner:(0.5 @ menu height).

    menu labels:#('about' 'file' 'help').
    menu selectors:#(#about #file #help).
    topView open
</CODE></PRE>
</A>

finally, submenus can be defined for each item as in:

<A TYPE="example">
<PRE><CODE>
    |topView menu|

    topView := StandardSystemView new.
    topView extent:400@400.

    menu := PullDownMenu in:topView.
    menu origin:0.0 @ 0.0 corner:(0.5 @ menu height).

    menu labels:#('about' 'file' 'help').
    menu selectors:#(#about #file #help).

    menu at:#about
	 putLabels:#('about menus ...')
	 selectors:#(#about)
	 receiver:nil.    "/ typically some applicationModel here

    menu at:#file
	 putLabels:#('new' 'open ...' nil 'quit')
	 selectors:#(#new #open nil #quit)
	 receiver:nil.    "/ typically some applicationModel here

    topView open
</CODE></PRE>
</A>

the individual submenus are instances of <CODE>MenuView</CODE>; therefore,
these support various different mechanisms. For example, instead of sending
messages to some receiver, a model can be notified or blocks be evaluated:

<A TYPE="example">
<PRE><CODE>
    |topView menu|

    topView := StandardSystemView new.
    topView extent:400@400.

    menu := PullDownMenu in:topView.
    menu origin:0.0 @ 0.0 corner:(0.5 @ menu height).

    menu labels:#('about' 'file' 'help').
    menu selectors:#(#aboutMenu #fileMenu #help).

    menu at:#aboutMenu
	 putLabels:#('about menus ...')
	 selectors:#(#about)
	 receiver:nil.    "/ typically some applicationModel here

    (menu subMenuAt:#aboutMenu)
	 actionAt:#about put:[AboutBox open].

    menu at:#fileMenu
	 putLabels:#('new' 'open ...' nil 'quit')
	 selectors:#(#new #open nil #quit)
	 receiver:nil.    "/ typically some applicationModel here

    (menu subMenuAt:#fileMenu)
	 actionAt:#new put:[Transcript showCR:'new is not yet implemented'].
    (menu subMenuAt:#fileMenu)
	 actionAt:#open put:[Transcript showCR:'open is not yet implemented'].
    (menu subMenuAt:#fileMenu)
	 actionAt:#quit put:[topView destroy].

    menu actionAt:#help put:[Transcript showCR:'help is not yet implemented'].

    topView open
</CODE></PRE>
</A>

<H2><A HREF="#I_SPECIAL" NAME="SPECIAL">Special views</A></H2>

<H3><A HREF="#I_SPECIAL_SHADOW" NAME="SPECIAL_SHADOW">ShadowView - shadows under views</A></H3>

this section is to be written

<H3><A HREF="#I_SPECIAL_INPUTVIEW" NAME="SPECIAL_INPUTVIEW">InputView - a transparent (input-only) view</A></H3>

Instances of InputView are transparent, and can be used over another view to catch
its events. InputViews are typically used as a plugged view;
i.e. they are usually configured to forward events to some other view.
<BR>
An example use can be seen in the GUI Painter, which uses an inputView over the construction (drawing) area,
to keep the widgets shown there from getting events.
<P>
The following example demonstrates this:
<A TYPE="example">
<PRE><CODE>
      |v1 v2|

      v1 := View new extent:200@200.
      v2 := InputView in:v1.
      v2 origin:10@10 corner:50@50.
      v2 cursor:(Cursor thumbsUp).
      v1 openAndWait.
      v1 displayLineFrom:0@0 to:100@100.
</CODE></PRE>
</A>


<H3><A HREF="#I_SPECIAL_SHAPES" NAME="SPECIAL_SHAPES">Arbitrary shaped views</A></H3>

You can give your views arbitrary (non rectanglular) shapes
if your graphic system supports this (i.e. if your X-server supports the
<VAR>Shape Extension</VAR>). The use of this feature is tranparent: on systems
which do not support arbitrary borders, the views will be rectangular, and the
shape definition is silently ignored.
<P>
To do so, create a bitmap in which 1-bits represent pixels which are to be
included as view-pixels and 0-bits stand for pixels which are not.
<BR>
Then define this bitmap as the views shape and (optional) border forms.
The bits need not be connected.
<BR>
Example:

<A TYPE="example">
<PRE><CODE>
    |v viewForm borderForm|

    v := View new.

    "
     create two bitmaps which are first cleared to zero,
     then filled with a circle.
     The borderShape is somewhat (2-pixels on each side)
     wider than the viewShape, which defines the inside of the view.
    "
    borderForm := Form width:50 height:50.
    borderForm clear.
    viewForm := Form width:50 height:50.
    viewForm clear.

    borderForm fillArcX:0 y:0
		  width:50
		 height:50
		   from:0
		  angle:360.

    viewForm fillArcX:1 y:1
		 width:48
		height:48
		   from:0
		  angle:360.

    "
     finally set the views border- and view-Shape
    "
    v borderShape:borderForm.
    v viewShape:viewForm.

    v open
</CODE></PRE>
</A>

For portable applications, you should not use viewShapes, since not
all X servers support this.
<BR>
On other than X systems, it may not be supported at all.
To make your program portable across display systems, you should ask the
Display if it supports arbitrary view shapes. This is done by:
<PRE><CODE>
    Display hasShapes
</CODE></PRE>
which returns true, if arbitrary shapes are supported.
Write your application to be usable with regular (rectangular) views as well.






<H3><A HREF="#I_SPECIAL_ROOT" NAME="SPECIAL_ROOT">The root view</A></H3>

this section is to be written

<H3><A HREF="#I_SPECIAL_DISPLAY" NAME="SPECIAL_DISPLAY">The Display</A></H3>

this section is to be written

<H3><A HREF="#I_SPECIAL_MODALNONMODAL" NAME="SPECIAL_MODALNONMODAL">Using modal boxes non-modal and vice versa</A></H3>


  It is possible to startup any view as a modal box, and to open
  dialogs in non-modal mode:
<A TYPE="example">
<PRE><CODE>
	FileBrowser new openModal
</CODE></PRE>
</A>

  will block this view until you are finished with the fileBrowser.
  And:

<A TYPE="example">
<PRE><CODE>
	|b|

	b := FileSelectionBox new.
	b origin:0@0.
	b openModeless
</CODE></PRE>
</A>

  allows the file box to stay around.




<H2><A HREF="#I_OTHER" NAME="OTHER">Other views </A></H2>

this chapter is to be written

<H3><A HREF="#I_OTHER_RULER" NAME="OTHER_RULER">Rulers </A></H3>

this section is to be written

<H3><A HREF="#I_OTHER_OBJVIEW" NAME="OTHER_OBJVIEW">ObjectView - for structured graphics </A></H3>

The <CODE>ObjectView</CODE> class provides a framework for structured graphics.
Normally it is used as an abstract superclass, but has built in enough functionality
to be used directly as well.
<BR>
<CODE>ObjectView</CODE> displays and manipulates graphical objects which should be derived
from <CODE>DisplayObject</CODE> or understand a similar protocol.
<BR>
The whole graph usually consists of multiple (possibly overlapping) such elements,
and <CODE>ObjectView</CODE> knows how to correctly redraw such a graph, how to select and highlight
elements, to scroll and zoom-in/out.
<BR>
In addition, it provides hooks for actions (keyboard input, button press or doublePress) to be
forwarded to elements.
<P>
Lets start with a very simple example; lets assume, we have to display a number
of icons, which represent computers in a local network.
Each element is represented by an instance of the <CODE>HostIcon</CODE> class, which defines
how instances compute their bounding box and how to redraw themself in a graphics context.
<FORM ACTION="../misc/onlyInSTX.html"
      METHOD="DOIT |
	(Smalltalk fileIn:'clients/Demos/HostIcon.st') ifFalse:[
	    self error:'cannot load ''HostIcon.st'''
	] ifTrue:[
	    Smalltalk browseClass:(Smalltalk at:#'Demos::HostIcon')
	]
      ">

To load this class and open a browser on it, press:<INPUT TYPE="submit" VALUE="load &amp; see HostIcon">

</FORM>


this section is to be written



<H2><A HREF="#I_NEWWIDGETS" NAME="NEWWIDGETS">Creating your own views </A></H2>

this chapter is to be written

<H2><A HREF="#I_MVC2" NAME="MVC2">Model-View-Controller operation again</A></H2>

this section is not yet finished - please use the browser to
see more details.
<P>

In <CITE>ST/X</CITE>, most views can be operated either with or without
a true model. If used without a model, they typically inform others of
actions and/or changes by performing so called <CITE>action blocks</CITE>.
This is similar to <CITE>callback functions</CITE> in other GUI environments.
<P>
For example, a button can be told to perform some action by setting its
pressaction as in:
<PRE><CODE>
    |b|

    b := Button new.
    b label:'press me'.
    b action:[Transcript showCR:'here I am'].
    ...
</CODE></PRE>

To make porting of MVC-based applications easier, many views also
support the well known MVC operation, in which the interaction is not
by using action blocks, but by sending messages to and receiving changes from
a model. Although this behavior can easily be simulated using action blocks,
some more support has been built into those classes to hide all those action-block
internals for those who prefer to use the model-view setup.
<P>
It is not meant that <CITE>ST/X</CITE> widgets are completely protocol
compatible to corresponding <CITE>ST-80</CITE> classes, there is no quarantee
whatsoever, that applications are portable without code changes.
<P>
It should be clear, that
action blocks are very flexible and
allow other behavior to be easily simulated.
For example, to have a button
send a change-notification to some model, a block such as:
<PRE><CODE>
	b action:[someModel change:#foo]
</CODE></PRE>
could be used.
Since most views have a model instance variable (and corresponding access
methods), the standard MVC Button is thus simulated by:
<PRE><CODE>
	b pressAction:[b model value:true].
	b releaseAction:[b model value:false].
</CODE></PRE>



<H3><A HREF="#I_MVC2_BUTTONS" NAME="MVC2_BUTTONS">Buttons, Toggles etc. with a model</A></H3>

To have a button operate on a model, you have to
<UL>
<LI>set the buttons model
<P>
<LI>optionally define a different changeMessage.
The changeMessage is the selector of a
message to be send to the model when the button changes its state.
<BR>
By default, the changeSelector is <CODE>#value:</CODE>, which is
backward compatible with <CITE>ST-80</CITE> applications,
and also allows for a simple valueHolder to be used as model
(which will hold the buttons truth-value then).
</UL>
Example:
<PRE><CODE>
    |b m|

    m := MyModelClass new.
    ...

    b := Button new.
    b label:'press me'.
    b model:m.
    ...
</CODE></PRE>
this default setup arranges,
that the model gets a <CODE>#value:</CODE> message
sent whenever the button is pressed.
<BR>
Example:
<PRE><CODE>
    |b m|

    m := MyModelClass new.
    ...
    b := Button new.
    b label:'press me'.
    b model:m.
    b change:#buttonPressed.
    ...
</CODE></PRE>
this arranges, that the model gets a <CODE>#buttonPressed</CODE> message
sent whenever the button is pressed.
<BR>
If you set the changeSeletor to a one-argument selector, the button
will pass the current state as additional argument (for buttons, this will
always be true, but for toggles or radioButtons, this might be false as well).
<BR>
Example:
<PRE><CODE>
    |b m|

    m := MyModelClass new.
      " -> m is supposed to respond to foo:
	-> with a boolean argument
      "
    b := Button new.
    b label:'press me'.

    b model:m.
    b change:#foo:.
    ...
</CODE></PRE>
Finally, passing a selector for a 2-argument message will arrange for the
button to pass itself as second argument in the change message.
<BR>
Example:

<PRE><CODE>
    |v b1 b2 m|

    m := MyModelClass new.

    v := HorizontalPanelView new.

    b1 := Button in:v.
    b1 label:'press me'.
    b1 model:m.
    b1 change:#buttonPressed:from:.

    b2 := Button in:v.
    b2 label:'or me'.
    b2 model:m.
    b2 change:#buttonPressed:from:.

    v open
</CODE></PRE>

the models <CODE>#buttonPressed:from:</CODE> method will get the button
as the <CODE>from:</CODE> argument.
<P>
The following concrete example creates a Toggle operating
on a valueHolder. ValueHolders are very simple models which do not provide much
more functionality than holding some value (in this case: the toggles state)
and informing others of changes. The valueHolders value is accessed via
<CODE>#value</CODE> and <CODE>#value:</CODE> messages.

<A TYPE="example">
<PRE><CODE>
    |t m|

    m := ValueHolder with:false.

    t := Toggle on:m.
    t label:'press me'.

    t open.
    m inspect
</CODE></PRE>
</A>

the last statement opens an inspector on the valueHolder;
see the field named <VAR>value</VAR> and how it changes when the toggle
changes state.
<P>
Notice the similarity with the actionBlock setup; telling the
toggle to NOT acquire the boolean state (via the aspect-message),
and replacing the model by a block, gives the callback setup:

<A TYPE="example">
<PRE><CODE>
    |t m|

    m := [:val | Transcript showCR:('toggled to: ' , val printString)].

    t := Toggle new.
    t label:'press me'.
    t aspectMessage:nil.
    t model:m.
    t open.
</CODE></PRE>
</A>
Notice, that in the previous example, the model must be set AFTER we change
the toggles aspecMessage - the reason is that the toggle tries to acquire the
model-value when the model is assigned. If this is done first, the default
aspect selector (#value) would be used, which is not the correct message for
the block.

<P>
Example: creating two toggles on different valueHolders

<A TYPE="example">
<PRE><CODE>
    |v b1 b2 m1 m2|

    m1 := ValueHolder newBoolean.  "/ this is a short for ... with:false.
    m2 := ValueHolder newBoolean.

    v := HorizontalPanelView new.

    b1 := Toggle in:v.
    b1 label:'press me'.
    b1 model:m1.

    b2 := Toggle in:v.
    b2 label:'or me'.
    b2 model:m2.

    v extent:(v preferredExtent); open.
    m1 inspect.   "/ have a look at the <VAR>value</VAR> instance variable
    m2 inspect.   "/ have a look at the <VAR>value</VAR> instance variable
</CODE></PRE>
</A>

Models inform their dependents about value changes;
valueHolders send a "<CODE>self changed:#value</CODE>", which is the default
aspect of most views (and therefore, the changeSymbol on which they update
their view).
<BR>
Toggles (like all others) monitor their models value, and update
themself when receiving a change notification.
If multiple views operate on the same model, all of them
will correctly show the current value.
<BR>
The following opens two independent toggles on the same valueHolder model:

<A TYPE="example">
<PRE><CODE>
    |v b1 b2 m|

    m := ValueHolder with:true.

    b1 := Toggle on:m.
    b1 label:'press me'.

    b2 := Toggle on:m.
    b2 label:'or me'.

    b1 open.
    b2 open.
    m inspect.   "/ have a look at the <VAR>value</VAR> instance variable
</CODE></PRE>
</A>


<H3><A HREF="#I_MVC2_EDITFIELD" NAME="MVC2_EDITFIELD">EditFields with a model</A></H3>

Having an editField operate on a model is very similar to the above
button examples:

<A TYPE="example">
<PRE><CODE>
    |v f m|

    m := ValueHolder with:'hello'.

    f := EditField on:m.

    f open.
    m inspect.   "/ have a look at the <VAR>value</VAR> instance variable
</CODE></PRE>
</A>

however, the editField operates on a copy of the original string,
until its contents is <VAR>accepted</VAR>.
Only when <VAR>accepted</VAR>, will the editFIeld send <CODE>#value:</CODE>
(or any other changeMessage) to its model to change the actual value,
passing the changed string as argument.
<BR>
The value is <VAR>accepted</VAR>, if any of the following occurs:
<UL>
<LI>the <VAR>accept</VAR> function from its popup menu is performed
<P>
<LI>the <CODE>Return</CODE> key is pressed in the editField
<BR>
(unless this has been disabled by <CODE>#acceptOnReturn:false</CODE>)
<P>
<LI>any if the so called <VAR>leaveKeys</VAR> is pressed
(and this has been enabled by <CODE>#acceptOnLeave:true</CODE>)
<BR>
The set of leave-keys is <CODE>CursorUp</CODE>, <CODE>CursorDown</CODE>,
<CODE>PreviousField</CODE>, <CODE>PreviousField</CODE> and <CODE>Tab</CODE>
by default; The editFields leaveKeys can be changed.
<P>
<LI>any change was made to the text and the field was programmed to
track changes immediately with <CODE>alwaysAccept:true</CODE>.
</UL>
The following is a typical setup for an enterField in a dialogBox:

<A TYPE="example">
<PRE><CODE>
    |box field model|

    model := ValueHolder with:'hello'.

    box := DialogBox new.
    box addTextLabel:'Enter some string, please:'.
    box addInputFieldOn:model.
    box addAbortButton; addOkButton.
    box open.
    box accepted ifTrue:[
	Transcript showCR:'exit with ok'
    ] ifFalse:[
	Transcript showCR:'exit with abort'
    ].
    Transcript showCR:'Model is: ' , model value
</CODE></PRE>
</A>

The <CODE>DialogBox</CODE>, <CODE>EditField</CODE> and <CODE>EnterFieldGroup</CODE>
classes include more examples in their documentation protocol.


<H3><A HREF="#I_MVC2_TEXTV" NAME="MVC2_TEXTV">TextViews with a model</A></H3>

The model has to provide a method which returns the text to be displayed;
this is called the listMessage. The TextView will automatically (re)fetch
the text via above message, whenever it gets a change notification about
a change of the aspectSymbol.
<BR>
If the text is editable (i.e. the view is an editTextView or subclass),
you also have to define the selector of a message which is sent whenever the
text is accepted (the changeMessage).
<BR>
Example (non editable):
<BR>
(Notice, using a plug here for demonstration only;
 in real world applications you would use an instance of a 'real' model)

<A TYPE="example">
<PRE><CODE>
    |t myModel|

    myModel := Plug new.
    myModel respondTo:#getText with:['hello world'].

    t := TextView new on:myModel aspect:#aspect; listMessage:#getText.
    t open.
</CODE></PRE>
</A>

whenever the model sends a change of <CODE>#aspect</CODE>, the textview will
acquire its new contents by sending <CODE>#gettext</CODE> to the model.
<BR>
Example (editable text):

<A TYPE="example">
<PRE><CODE>
    |t myModel|

    myModel := Plug new.
    myModel respondTo:#getText with:['hello world'].
    myModel respondTo:#accept: with:[:newString | Transcript showCR:newString].

    t := (EditTextView on:myModel)
	    aspect:#aspect;
	    listMessage:#getText;
	    change:#accept:.
    t open
</CODE></PRE>
</A>

the textView will acquire the text to be shown via the <CODE>#aspect</CODE> message,
whenever the aspect changes.
An accept will lead to the <CODE>#accept:</CODE> message being sent to the model,
with the new text as argument.

<H3><A HREF="#I_MVC2_SELLISTV" NAME="MVC2_SELLISTV">SelectionInListViews with a model</A></H3>

The setup is:
<PRE><CODE>
    |l myModel|

    myModel := MyModelClass new.

    l := SelectionInListView
	    on:myModel
	    printItems:true
	    oneItem:true
	    aspect:#aspect
	    change:#selectionChanged:
	    list:#getList
	    menu:#getMenu
	    initialSelection:#initialSelection
	    useIndex:true

    l open
</CODE></PRE>

In the above, the selectionInListView will ask the model for the list to be
displayed whenever the aspect defined by <CODE>#aspect</CODE> changes.
This change is signalled by the model in doing a <CODE>self changed:#aspect</CODE>.
Since the selectionInListView installs itself as dependent of the model,
it will get an update notification whenever that happens.
<BR>
To acquire the list of selectable entries, the selectionInListView will send
<CODE>#getList</CODE> to the model. The model should return an appropriate
collection entries. If printItems was set to true (as in the above case),
these entries are not taken directly, but instead, #printString is applied to
each to get the strings which are actually displayed.
<BR>
Whenever the selection changes, the selectionInListView will send the change-message
to the model. As in the above button example, this may be a zero, one or 2-arg
selector. If its a one or 2-arg selector, the selected entries value will be passed
as first argument. The passed value will be the entry from te list which was
optained via the <CODE>#getList</CODE> message
- except, if useIndex was true (as in the above);
in this case, the numeric index in the list is passed instead.
<BR>
Finally, <CODE>#initialSelection</CODE> should return an index or nil
- which defines if and which initial entry should be highlighted.
<P>
The discussion of the <CODE>#menu</CODE> message will follow.
<P>

Most applications do not require the above generic model, but are
perfectly happy with a simpler setup, where the selections list is
kept together with its selection in an instance of <CODE>SelectionInList</CODE>.
<BR>
This selectionInList keeps track of the item list and the selection, and
tell its dependents about changes. If multiple views are hooked to the
same, all of them will update as appropriate.
<BR>
Example:
<PRE><CODE>
    |l myList|

    myList := SelectionInList new.
    myList list:#('one' 'two' 'three' 'four').

    l := SelectionInListView on:myList.

    l open
</CODE></PRE>
Multiple views operating on the same list:
<PRE><CODE>
    |l1 l2 myList|

    myList := SelectionInList new.
    myList list:#('one' 'two' 'three' 'four').

    l1 := SelectionInListView on:myList.
    l1 open.

    l2 := SelectionInListView on:myList.
    l2 open.
</CODE></PRE>
this also works if the presentation is different, as in:
<PRE><CODE>
    |l1 l2 myList|

    myList := SelectionInList new.
    myList list:#('one' 'two' 'three' 'four').

    l1 := SelectionInListView on:myList.
    l1 open.

    l2 := PopUpList on:myList.
    l2 open.
</CODE></PRE>

in you application, to get informed about selection changes, try:

<PRE><CODE>
    |l myList myApp|

    myApp := Plug new.
    myApp respondTo:#theSelectionHasChanged
	       with:[Transcript showCR:'wow, it has changed'].

    myList := SelectionInList new.
    myList list:#('one' 'two' 'three' 'four').
    myList onChangeSend:#theSelectionHasChanged to:myApp.

    l := SelectionInListView on:myList.
    l open
</CODE></PRE>

<P>

<H3><A HREF="#I_MVC2_COMPLEX_MODELS" NAME="MVC2_COMPLEX_MODELS">Complex models</A></H3>

The above examples mostly used ValueHolders as simple models.
In real life applications, models are often more complex, consisting
of many fields.
<BR>
Consider the case of a personal record, with fields
for <VAR>firstName</VAR>, <VAR>lastName</VAR>, <VAR>date of birth</VAR> and
so on.
<BR>
If you used the above valueHolders for all fields, you had to extract all
fields values from your person object, put them into value holders,
open a dialog on those value holders, and store back the fields from
the valueholders back into the person object.
<BR>
This can be avoided by two different mechanisms:
<UL>
<LI>use adaptors, which extract the values.
<BR>
this is also the preferred method in the <CITE>ST80</CITE> environment
<P>
<LI>program the fields to use different aspect and change messages to access
their values directly from the complex model
</UL>
choose whichever you prefer; the following shows examples for both:
<BR>
(notice: since we do not have a Person class in the system, we use a Plug
 for the demonstration. Plugs implement messages by evaluating a corresponding
 block - thereby allowing easy simulation of other objects protocol.
 In your real application, you would have an instance of a Person class, of course)
<BR>
Using adaptors:

<A TYPE="example">
<PRE><CODE>
    |person firstName lastName dateOfBirth
     box field|

    person := Plug new.
    firstName := 'John'.
    lastName := 'Sampleman'.
    dateOfBirth := Date day:1 month:6 year:1955.
    person respondTo:#firstName with:[firstName].
    person respondTo:#firstName: with:[:arg | firstName := arg].
    person respondTo:#lastName with:[lastName].
    person respondTo:#lastName: with:[:arg | lastName := arg].
    person respondTo:#dateOfBirth with:[dateOfBirth].
    person respondTo:#dateOfBirth: with:[:arg | dateOfBirth := arg].

    box := DialogBox new.
    box addTextLabel:'Person data:'.
    field := box addInputFieldOn:(ProtocolAdaptor subject:person
						  accessPath:#(firstName)).
    box addVerticalSpace.
    field := box addInputFieldOn:(ProtocolAdaptor subject:person
						  accessPath:#(lastName)).
    box addVerticalSpace.
    field := box addInputFieldOn:(ProtocolAdaptor subject:person
						  accessPath:#(dateOfBirth)).
    field converter:(PrintConverter new initForDate).
    box addVerticalSpace.
    box addAbortButton; addOkButton.
    box open.

    Transcript showCR:'Name: ' , firstName , ' ' , lastName.
    Transcript showCR:' DOB: ' , dateOfBirth printString.
</CODE></PRE>
</A>

Using different aspect and change messages:

<A TYPE="example">
<PRE><CODE>
    |person firstName lastName dateOfBirth
     box field|

    person := Plug new.
    firstName := 'John'.
    lastName := 'Sampleman'.
    dateOfBirth := Date day:1 month:6 year:1955.
    person respondTo:#firstName with:[firstName].
    person respondTo:#firstName: with:[:arg | firstName := arg].
    person respondTo:#lastName with:[lastName].
    person respondTo:#lastName: with:[:arg | lastName := arg].
    person respondTo:#dateOfBirth with:[dateOfBirth].
    person respondTo:#dateOfBirth: with:[:arg | dateOfBirth := arg].

    box := DialogBox new.
    box addTextLabel:'Person data:'.
    field := box addInputFieldOn:person.
    field aspect:#firstName; change:#firstName:.
    box addVerticalSpace.
    field := box addInputFieldOn:person.
    field aspect:#lastName; change:#lastName:.
    box addVerticalSpace.
    field := box addInputFieldOn:person.
    field aspect:#dateOfBirth; change:#dateOfBirth:.
    field converter:(PrintConverter new initForDate).
    box addVerticalSpace.
    box addAbortButton; addOkButton.
    box open.

    Transcript showCR:'Name: ' , firstName , ' ' , lastName.
    Transcript showCR:' DOB: ' , dateOfBirth printString.
</CODE></PRE>
</A>

Please expect more information and examples to be added here ....


<H2><A HREF="#I_APPS" NAME="APPS">Applications and TopView Control</A></H2>

<H3><A HREF="#I_APPS_WINDOWMODES" NAME="APPS_WINDOWMODES">Window Modes</A></H3>

Windows can be opened basically in two modes:
<UL>
<LI>modeless<br>Operating independent from the caller
<LI>modal<br>blocking the caller while open
</UL>

<H4>Modeless Windows</H4>
The modeless mode is the normal mode. For example, if you open a new workspace in the launcher,
that window (actually: that windowGroup) will be operated in modeless mode: a new windowGroup
is created, which contains the topView and all of its child views, and a separate window
process is started to serve its events. Basically, such applications/windows are started like:
<PRE><CODE>
    |app|

    app := WorkspaceApplication new.
    app open.
</CODE></PRE>
Notice, that when you evaluate this in a workspace, your workspace regains control after the
new window has opened.

<H4>Modal Windows</H4>
The modal mode is used for dialogs and popup windows, which behave similar with regard
to how the control is taken from the caller while being shown, but are different in their
window decoration (popups do not have a window decoration with label and
resize, close and maximize controls).
<P>
Any application can be opened as a dialog using the <CODE>openModal</CODE> message.
For example, the same workspace application from the previous example is opened as
a modal window with:
<A TYPE="example"><PRE><CODE>
    |app|

    app := WorkspaceApplication new.
    app openModal.
</CODE></PRE>
</A>
Notice, that the caller is blocked until the window is closed.

<H4>Modeless without Decoration</H4>
Use <CODE>openAs:</CODE> with a symbolic parameter for even more combinations.
The following gives a modal window without any decoration:
<A TYPE="example"><PRE><CODE>
    |app|

    app := WorkspaceApplication new.
    app openAs:#popUp.
</CODE></PRE>
</A>

To get a modeless window without decoration, use:
<A TYPE="example"><PRE><CODE>
    |app|

    app := WorkspaceApplication new.
    app openAs:#popUpNotModal.
</CODE></PRE>
</A>

Finally, there is a modal window with a smaller decoration:
<A TYPE="example"><PRE><CODE>
    |app|

    app := WorkspaceApplication new.
    app openAs:#toolDialog.
</CODE></PRE>
</A>


<H3><A HREF="#I_APPS_MULTIPLETOP" NAME="APPS_MULTIPLETOP">Controlling Multiple TopViews</A></H3>

Often, applications consist of multiple topViews, which are to be controlled
as a unit by the window manager with respect to iconification and closing.
With the help of the windowGroup object, multiple views can be connected to form a unit.
<P>

As described in a previous chapter, each topView and all of its subviews
are put into a common windowGroup and get their events via a single
event queue in their common windowSensor. Also, a single thread of control (process)
handles all events for all windows within one windowgroup.
<P>
The normal situation is to have one single windowGroup per topView,
however, in <CITE>ST/X</CITE>, it is also possible to put multiple topViews into the
same windowGroup.
All views within one windowGroup will then be served by a single (lightWeight) process within smalltalk.
Thus, applications which require synchronization among actions performed in multiple
views can use this without a need for semaphores and critical regions.
<P>
Also, views within a windowGroup can be setup to control each other with respect
to iconification, deiconification and window closing.
<BR>
To setup a master-slave relationShip between two views
(in which the slave gets destroyed/iconified automatically,
whenever the master is destroyed/iconified), use a setup as:

<A TYPE="example">
<PRE><CODE>
    |masterView slaveView|

    masterView := StandardSystemView new.
    masterView label:'master'.
    masterView extent:300@300.
    <U>masterView beMaster</U>.
    masterView open.
    masterView waitUntilVisible.

    slaveView := StandardSystemView new.
    slaveView label:'slave'.
    slaveView extent:300@300.
    <U>slaveView beSlave</U>.
    slaveView openInGroup:(masterView windowGroup).
</CODE></PRE>
</A>

In the above, the slaveView is automatically closed when the master is closed.
However, the master is not affected by the slave being closed.
<BR>
For a mutual partnership, use <CODE>#bePartner</CODE>, as in:

<A TYPE="example">
<PRE><CODE>
    |partnerView1 partnerView2|

    partnerView1 := StandardSystemView new.
    partnerView1 label:'partner1'.
    partnerView1 extent:300@300.
    <U>partnerView1 bePartner</U>.
    partnerView1 open.
    partnerView1 waitUntilVisible.

    partnerView2 := StandardSystemView new.
    partnerView2 label:'partner2'.
    partnerView2 extent:300@300.
    <U>partnerView2 bePartner</U>.
    partnerView2 openInGroup:(partnerView1 windowGroup).
</CODE></PRE>
</A>

Since partners all collapse into one common icon, you should give
all of them the same icon bitmap and icon label (to avoid confusing the user):

<A TYPE="example">
<PRE><CODE>
    |partnerView1 partnerView2|

    partnerView1 := StandardSystemView new.
    partnerView1 label:'partner1'.
    partnerView1 iconLabel:'myApp'.
    partnerView1 extent:300@300.
    <U>partnerView1 bePartner</U>.
    partnerView1 open.
    partnerView1 waitUntilVisible.

    partnerView2 := StandardSystemView new.
    partnerView2 label:'partner2'.
    partnerView2 iconLabel:'myApp'.
    partnerView2 extent:300@300.
    <U>partnerView2 bePartner</U>.
    partnerView2 openInGroup:(partnerView1 windowGroup).
</CODE></PRE>
</A>

You can of course have multiple master-slave or partner relations.
In general, a slave view will be closed, whenever any master or partner
is closed. A partner is closed, whenever another partner is closed.
<P>
In the next example, the slave is closed whenever any of its masters
is closed - but those do not affect each other:

<A TYPE="example">
<PRE><CODE>
    |masterView1 masterView2 slaveView|

    masterView1 := StandardSystemView new.
    masterView1 label:'master1'.
    masterView1 extent:300@300.
    <U>masterView1 beMaster</U>.
    masterView1 open.
    masterView1 waitUntilVisible.

    masterView2 := StandardSystemView new.
    masterView2 label:'master2'.
    masterView2 extent:300@300.
    <U>masterView2 beMaster</U>.
    masterView2 openInGroup:(masterView1 windowGroup).
    masterView2 waitUntilVisible.

    slaveView := StandardSystemView new.
    slaveView label:'slave of both'.
    slaveView extent:300@300.
    <U>slaveView beSlave</U>.
    slaveView openInGroup:(masterView1 windowGroup).
</CODE></PRE>
</A>

The following closes the slave with any of the two masters,
which are partners (i.e. control each other):

<A TYPE="example">
<PRE><CODE>
    |partnerView1 partnerView2 slaveView|

    partnerView1 := StandardSystemView new.
    partnerView1 label:'partner1'.
    partnerView1 extent:300@300.
    <U>partnerView1 bePartner</U>.
    partnerView1 open.
    partnerView1 waitUntilVisible.

    partnerView2 := StandardSystemView new.
    partnerView2 label:'partner2'.
    partnerView2 extent:300@300.
    <U>partnerView2 bePartner</U>.
    partnerView2 openInGroup:(partnerView1 windowGroup).

    slaveView := StandardSystemView new.
    slaveView label:'slave of both'.
    slaveView extent:300@300.
    <U>slaveView beSlave</U>.
    slaveView openInGroup:(partnerView1 windowGroup).
</CODE></PRE>
</A>

Since modalBoxes can also be opened modeless,
controlPanels for applications can be created with this mechanism:

<A TYPE="example">
<PRE><CODE>
    |panel slaveView1 slaveView2 thisGroup|

    panel := Dialog new.
    panel addComponent:(Button new
			    label:'showSlave1';
			    action:[slaveView1 beVisible; raise]).
    panel addComponent:(Button new
			    label:'hideSlave1';
			    action:[slaveView1 beInvisible]).
    panel addComponent:(Button new
			    label:'showSlave2';
			    action:[slaveView2 beVisible; raise]).
    panel addComponent:(Button new
			    label:'hideSlave2';
			    action:[slaveView2 beInvisible]).
    <U>panel beMaster</U>.
    panel label:'master'.
    panel openModeless.
    panel waitUntilVisible.

    thisGroup := panel windowGroup.

    slaveView1 := StandardSystemView new.
    slaveView1 label:'slave1'.
    slaveView1 extent:300@300.
    <U>slaveView1 beSlave</U>.
    slaveView1 openInGroup:thisGroup.

    slaveView2 := StandardSystemView new.
    slaveView2 label:'slave2'.
    slaveView2 extent:300@300.
    <U>slaveView2 beSlave</U>.
    slaveView2 openInGroup:thisGroup.
</CODE></PRE>
</A>

Notice:
<BR>
In the above examples, we use <CODE>#waitUntilVisible</CODE>
as a workaround for a somewhat strange effect: whenever a topView is mapped
(i.e. made visible), it will look for partners or slaves to map as well.
Since <CODE>#open</CODE> returns immediately (i.e. creates a new
asynchronous process for the view), the slave or partner view gets created
<STRONG>before</STRONG> (but not mapped) the first view becomes mapped.
Therefore it would immediately map the slave/partner and not give you
a chance to position the view with the window managers ghostline mechanism.
<P>
If you remove the <CODE>#waitUntilVisible</CODE> messages, the slave/partner
views come up immediately. However, in some applications, this effect may
be desired (so we do not call it a bug here ;-)
<BR>
I.e. to bring the slave view up immediately at some fix position,
try:

<A TYPE="example">
<PRE><CODE>
    |masterView slaveView|

    slaveView := StandardSystemView new.
    slaveView label:'slave'.
    slaveView origin:(Screen current extent - (300@300)).
    slaveView extent:300@300.
    <U>slaveView beSlave</U>.
    slaveView beInvisible.
    slaveView open.

    masterView := StandardSystemView new.
    masterView label:'master'.
    masterView extent:300@300.
    <U>masterView beMaster</U>.
    masterView openInGroup:(slaveView windowGroup).
</CODE></PRE>
</A>

the same using partners:

<A TYPE="example">
<PRE><CODE>
    |partnerView1 partnerView2 partnerView3|

    partnerView1 := StandardSystemView new.
    partnerView1 label:'partner1'.
    partnerView1 origin:(Screen current extent - (300@300)).
    partnerView1 extent:300@300.
    <U>partnerView1 bePartner</U>.
    partnerView1 beInvisible.
    partnerView1 open.

    partnerView2 := StandardSystemView new.
    partnerView2 label:'partner2'.
    partnerView2 origin:0@0.
    partnerView2 extent:300@300.
    <U>partnerView2 bePartner</U>.
    partnerView2 beInvisible.
    partnerView2 openInGroup:(partnerView1 windowGroup).

    partnerView3 := StandardSystemView new.
    partnerView3 label:'partner3'.
    partnerView3 extent:300@300.
    <U>partnerView3 bePartner</U>.
    partnerView3 openInGroup:(partnerView1 windowGroup).
</CODE></PRE>
</A>


<H3><A HREF="#I_APPS_EVENTFLUSHING" NAME="APPS_EVENTFLUSHING">Flushing events for an application</A></H3>

You can flush (or otherwise manipulate) events for an application, since
all of its views get their events via a single instance of <CODE>WindowSensor</CODE>.
For example, the following lets the sensor forget all typeAhead key presses
(for all views of a group):
<BR>
<PRE><CODE>
	...
	aView windowGroup sensor flushKeyboard
	...
</CODE></PRE>
For other methods which do selective or overall flushing, see the WindowSensors protocol
in the browser or read the event section below.

<P>

Please expect more information and examples to be added here ....


<H2><A HREF="#I_DRAWING" NAME="DRAWING">Smalltalk/X's drawing model</A></H2>

The following chapter tells you how the low level drawing is done.
If you use the above widgets, you do not need to know these details;
they do all the drawing for you.

<P>
<H3><A HREF="#I_GEOMETRICOBJECTS" NAME="GEOMETRICOBJECTS">Geometry Objects &amp; Wrappers</A></H3>
<P>

Before going into the low-level details, have a look at the geometric objects
and corresponding wrappers, which provide an intermediate level interface
for drawing.
<BR>
For many mathematical geometric objects, there exist geometric classes
and corresponding wrappers, which know
how to draw them.
Consider using those in your applications, instead of drawing things on the low
level.
<P>
For example, instead of drawing a polygon manually:
<PRE><CODE>
    aGC displayPolygon:aCollectionOfPoints.
</CODE></PRE>
you can also (should ?) use an instance of <CODE>Polygon</CODE>,
and a drawing wrapper:
<PRE><CODE>
    p := Polygon vertices:aCollectionOfPoints.
    pDrawer := StrokingWrapper on:p.
    ...
    pDrawer displayOn:aGC
</CODE></PRE>
These objects have the added advantage, that they can be used as components
of a view (much like subviews), and therefore are redrawn automatically by
the event mechanism:
<PRE><CODE>
    ...
    myView := View new ....
    ...

    p := Polygon vertices:aCollectionOfPoints.
    myView addComponent:(StrokingWrapper on:p).
    ...
</CODE></PRE>
We recommend using those - they are easy to use and handle all the redrawing
stuff for you.
<BR>
Geometric classes are provided for lineSegments, polygons, splines, curves,
arcs, ellipses, circles and arrows. Wrappers are available to draw those
either filled or unfilled (stroked).

<P>
<H3><A HREF="#I_LOWLEVELDRAWING" NAME="LOWLEVELDRAWING">Low level drawing</A></H3>
<P>


<P>
Even if you use geometric objects and wrappers,
it is useful to know the details of the underlying low level operations.
The following paragraphs describe various details, some of which also
affects the higher level interfaces (lineWidth, lineStyle, paint colors etc.)
<P>
All drawing in graphic contexts is done by sending it a <CODE>displayXXX</CODE> message
(usually via <CODE>self</CODE> from a subclasses method).
<BR>
For example, there are methods to display lines (<CODE>displayLine:</CODE>),
rectangles (<CODE>displayRectangle:</CODE>), strings (<CODE>displayString:</CODE>)
and so on.
<P>

All of the drawing protocol is inherited from the <CODE>GraphicsContext</CODE>
class, which defines all drawing in an abstract way. Beside views, there are
other classes which are graphicsContexts; for example, <CODE>Form</CODE> (which
represents bitmap images on the display), <CODE>PSGraphicsContext</CODE> (which represents
a printers page).
<P>

For most drawing operations, a single <A HREF="DRAWING_PAINT">paint color</A> is needed,
which is defined
by:

<PRE><CODE>
	aGC paint:someColor
</CODE></PRE>

where <VAR>someColor</VAR> is an instance of a color.

<BR>
Therefore,
<PRE><CODE>
	aGC paint:(Color red).
	aGC displayLineFrom:(10@10) to:(50@50).
</CODE></PRE>
will draw a red line.
<BR>

<P>
<H3><A HREF="#I_DEMOVIEW_SETUP" NAME="DEMOVIEW_SETUP">Demo View Setup</A></H3>
<P>

For all examples that follow, we will (re)use the same view.
To allow access to this view in the future, we have to create it first
and define a new global variable which will keep a reference to it.
<BR>
Execute:

<A TYPE="example">
<PRE><CODE>
    |v top panel frame|

    top := StandardSystemView extent:350@150.
    top label:'DemoView'.

    panel := HorizontalPanelView origin:0.0@0.0 corner:(1.0@30) in:top.
    panel horizontalLayout:#left.

    Button label:'clear'
	   action:[DemoView clear]
	   in:panel.
    Button label:'black bg'
	   action:[DemoView viewBackground:Color black; clear]
	   in:panel.
    Button label:'white bg'
	   action:[DemoView viewBackground:Color white; clear]
	   in:panel.
    Button label:'grey bg'
	   action:[DemoView viewBackground:Color grey; clear]
	   in:panel.

    frame := View origin:0.0@0.0 corner:1.0@1.0 in:top.
    frame inset:5; topInset:50; level:-1.

    v := View origin:0.0@0.0 corner:1.0@1.0 in:frame.
    top open.

    Smalltalk at:#DemoView put:v.
</CODE></PRE>
</A>

then draw into it with:

<A TYPE="example">
<PRE><CODE>
    DemoView paint:(Color black).
    DemoView displayLineFrom:(0@0) to:(50@50).
</CODE></PRE>
</A>

to clear the view, use:

<A TYPE="example">
<PRE><CODE>
    DemoView clear
</CODE></PRE>
</A>

Once you are finished with these examples, close the view, and remove the
global variable with:

<A TYPE="example">
<PRE><CODE>
    Smalltalk removeKey:#DemoView
</CODE></PRE>
</A>

<P>

Lets start with the <A NAME="DRAWING_VIEWBG">views background</A>.
This is not the drawing background, but
instead the default color with which the view is filled when exposed.
This filling is done automatically by the window system.
<BR>
To change the views background execute:

<A TYPE="example">
<PRE><CODE>
    DemoView viewBackground:(Color yellow).
</CODE></PRE>
</A>

the views appearance will not change immediately.
However, this color is used to fill exposed regions.
Try iconifying and deiconifying (or covering/uncovering) the view to
see this.
<BR>
If you want to make the new viewBackground immediately visible,
you have to use:

<A TYPE="example">
<PRE><CODE>
    DemoView viewBackground:(Color blue).
    DemoView clear.
</CODE></PRE>
</A>

You can use either a color or an image as viewBackground:

<A TYPE="example">
<PRE><CODE>
    DemoView viewBackground:(Image fromFile:'goodies/bitmaps/gifImages/garfield.gif').
    DemoView clear.
</CODE></PRE>
</A>

<P>
<A HREF="#I_COORDINATES" NAME="COORDINATES">Coordinates</A>
<P>
By default, all coordinates are in pixels, starting with 0/0 in the
upper left, advancing to the lower-right.
This can be changed using a <VAR>transformation</VAR>. See the section
below for more about this.
<P>

<A HREF="#I_DRAWING_PAINT" NAME="DRAWING_PAINT">The paint color</A>
<P>
All operations described below use a paint when drawing;
this paint may be a color or a bitmap image, which is used for
pattern drawing. This paint color is kept in every graphics context
(and therefore also in views) as an instance variable.
You have to set it before doing the drawing operation,
and it will be used for all successive drawing unless changed.
<BR>
The paint value is set with:
<PRE><CODE>
	...
	someDrawable paint:aPaint.
	...
</CODE></PRE>
in our concrete example, you would write:

<A TYPE="example">
<PRE><CODE>
    DemoView paint:Color yellow.
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView paint:(Image fromFile:'goodies/bitmaps/gifImages/garfield.gif').
</CODE></PRE>
</A>

<P>
A few operations require two colors to be set for drawing;
these are the so called <VAR>opaque</VAR> drawing operations.
For example, when displaying a dashed line or an opaque
bitmap image, separate paint values have to be specified for
on/off dashes or on/off pixels respectively.
<BR>
The two paint values are set with:
<PRE><CODE>
    ...
    someDrawable paint:fgPaint on:bgPaint.
    ...
</CODE></PRE>
or, in our concrete example, you would write:

<A TYPE="example">
<PRE><CODE>
    DemoView paint:(Color yellow) on:(Color red).
</CODE></PRE>
</A>

now, having enough background information,
lets draw some geometric shapes:
<P>

Sometimes, it is useful to specify pixel values instead of logical colors;
for example, if some area has to be inverted on the screen, you would like
to draw with a ``color'' where all pixels are turned on with a drawing
function which exclusive-or's the pixels (and not caring which color is
actually represented by these pixels).
<BR>
Those colors are created by special instance creation messages to the
<CODE>Color</CODE> class: <CODE>#noColor</CODE>, <CODE>#allColor</CODE>
and <CODE>#colorId:</CODE>. For more details, read the section on colors below.





<P>
<H4><A HREF="#I_DRAWING_LINES" NAME="DRAWING_LINES">Drawing lines:</A></H4>
<P>

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color white).
    DemoView displayLineFrom:(0@0) to:(50@50).
</CODE></PRE>
</A>

or (if you have x/y coordinates available,
and want to avoid the creation of temporary points):

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color white).
    DemoView displayLineFromX:50 y:0 toX:0 y:50.
</CODE></PRE>
</A>

also, vector representation (polar coordinates) is sometimes handy:
<br>
(but see also polygons below)

<A TYPE="example">
<PRE><CODE>
    |p1 p2 p3 p4|

    DemoView clear.
    DemoView paint:(Color white).
    p1 := 50 @ 50.
    p2 := p1 + (Point r:50 angle:60).
    p3 := p2 + (Point r:50 angle:120).
    p4 := p3 + (Point r:50 angle:60).
    DemoView displayLineFrom:p1 to:p2.
    DemoView displayLineFrom:p2 to:p3.
    DemoView displayLineFrom:p3 to:p4.
</CODE></PRE>
</A>


<P>
<H4><A HREF="#I_DRAWING_RECTANGLES" NAME="DRAWING_RECTANGLES">Drawing rectangles:</A></H4>

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView displayRectangle:(1@1 corner:50@50).
</CODE></PRE>
</A>

there are also methods which expect the rectangles values as separate arguments:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView displayRectangleOrigin:20@20 corner:50@50
</CODE></PRE>
</A>
or:
<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView displayRectangleX:10 y:10 width:20 height:20
</CODE></PRE>
</A>



<P>
<H4><A HREF="#I_DRAWING_ARCS" NAME="DRAWING_ARCS">Arcs, ellipses &amp; circles:</A></H4>

<P>
Arcs can be drawn -
<BR>
    by specifying a bounding box:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color green).
    DemoView displayArcX:0 y:0
		   width:50 height:50
		    from:0 angle:180
</CODE></PRE>
</A>

    or a center-point and radius:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color white).
    DemoView displayArc:(25@25)
		 radius:25
		   from:180 angle:180
</CODE></PRE>
</A>


    if the bounding box is not square, you get (part of) an ellipse:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color green).
    DemoView displayArcX:0 y:0
		   width:75 height:25
		    from:0 angle:180
</CODE></PRE>
</A>

of course, 360 degrees make a full ellipse or circle; as in:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color green).
    DemoView displayArcX:0 y:0
		   width:75 height:25
		    from:0 angle:360
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color green).
    DemoView displayArcX:0 y:0
		   width:50 height:50
		    from:0 angle:360
</CODE></PRE>
</A>
    for full circles, there is a shorter method available:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView displayCircleX:25 y:25 radius:25
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView displayCircle:(50@50) radius:25
</CODE></PRE>
</A>

<H4><A HREF="#I_DRAWING_POLYGONS" NAME="DRAWING_POLYGONS">Polygons:</A></H4>

<A TYPE="example">
<PRE><CODE>
    |p|

    p := Array with:(10@10)
	       with:(75@20)
	       with:(20@75)
	       with:(10@10).
    DemoView clear.
    DemoView paint:(Color magenta).
    DemoView displayPolygon:p
</CODE></PRE>
</A>


<H4><A HREF="#I_DRAWING_STRINGS" NAME="DRAWING_STRINGS">Strings:</A> </H4>

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color cyan).
    DemoView font:(Font family:'courier'
			  face:'medium'
			 style:'roman'
			  size:12).
    DemoView displayString:'hello' x:20 y:50
</CODE></PRE>
</A>

notice, that the y coordinate defines the position where the baseline of the characters
is drawn. You may have to ask the font for the <VAR>ascent</VAR> (the number
of pixels above the baseline), its <VAR>descent</VAR> (the number of pixels below)
or its <VAR>height</VAR> (the sum of both).
<BR>
the current font is accessed via <CODE>aView font</CODE>.
<BR>
Therefore, multiline text is drawn with:

<A TYPE="example">
<PRE><CODE>
    |h ascent font|

    DemoView clear.
    DemoView paint:(Color white).
    font := Font family:'courier'
		   face:'medium'
		  style:'roman'
		   size:12.
    font := font onDevice:(DemoView device).
    DemoView font:font.

    h := font height.
    ascent := font ascent.

    DemoView displayString:'hello' x:20 y:ascent.
    DemoView displayString:'there' x:20 y:(ascent + h)
</CODE></PRE>
</A>

For now, ignore the <CODE>"font onDevice:"</CODE> stuff - this will be explained below.
<P>

<CITE>Smalltalk/X</CITE> supports drawing of strings along an arbitrary
line; you may pass an angle (in degrees, clockwise from horizontal),
which is treated as a baseline on which characters are drawn:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView font:(Font family:'courier'
			  face:'medium'
			 style:'roman'
			  size:12).
    DemoView displayString:'hello' x:20 y:10 angle:90
</CODE></PRE>
</A>

of course, the angle is not limited to multiples of 90:
<P>
for a demonstration, resize the demoView:
<A TYPE="example">
<PRE><CODE>
    DemoView topView extent:400@480.
</CODE></PRE>
</A>
then draw strings with:
<A TYPE="example">
<PRE><CODE>
    |p1 p2|

    DemoView clear.

    DemoView paint:(Color red).
    0 to:359 by:22.5 do:[:angle |
	p1 := 200@200.
	p2 := p1 + (Point r:200 angle:angle).
	DemoView displayLineFrom:p1 to:p2.
    ].

    DemoView paint:(Color blue).
    DemoView font:(Font family:'courier'
			  face:'medium'
			 style:'roman'
			  size:12).

    0 to:359 by:22.5 do:[:angle |
	DemoView
	    displayString:('      ' , angle printString , ' degrees')
	    x:200 y:200
	    angle:angle
    ]
</CODE></PRE>
</A>
(the lines are drawn to show the baselines of the strings.)


<H4><A HREF="#I_DRAWING_BITMAPS" NAME="DRAWING_BITMAPS">Bitmaps:</A></H4>

<A TYPE="example">
<PRE><CODE>
    |i|

    i := Image fromFile:'libtool/bitmaps/SBrowser.xbm'.
    DemoView clear.
    DemoView paint:(Color cyan).
    DemoView displayForm:i x:20 y:50
</CODE></PRE>
</A>



there are also filling versions of the above:
<P>
<A HREF="#I_FILLING_RECTANGLES" NAME="FILLING_RECTANGLES">Filled rectangles:</A>

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView fillRectangle:(1@1 corner:50@50).
</CODE></PRE>
</A>

<A HREF="#I_FILLING_ARCS" NAME="FILLING_ARCS">Filled arcs, ellipses &amp; circles:</A>

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color green).
    DemoView fillArcX:0 y:0
		width:50 height:50
		 from:0 angle:90
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color white).
    DemoView fillArc:(25@25)
	      radius:25
		from:180 angle:180
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).
    DemoView fillArc:(25@25)
	      radius:25
		from:180 angle:180
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color green).
    DemoView fillArcX:0 y:0
		width:50 height:50
		 from:0 angle:360
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red).
    DemoView fillArcX:0 y:0
		width:75 height:25
		 from:0 angle:360
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color green).
    DemoView fillCircleX:25 y:25 radius:25
</CODE></PRE>
</A>

<A HREF="#I_FILLING_POLYGONS" NAME="FILLING_POLYGONS">Filled polygons:</A>

<A TYPE="example">
<PRE><CODE>
    |p|

    p := Array with:(10@10)
	       with:(75@20)
	       with:(20@75).
    DemoView clear.
    DemoView paint:(Color magenta).
    DemoView fillPolygon:p
</CODE></PRE>
</A>

  Have a look at the GraphicsContext-class for even more drawing
  methods.
<P>
<H4><A HREF="#I_DRAWING_OPQ" NAME="DRAWING_OPQ">Opaque drawing</A></H4>
<P>
  Forms and strings can also be drawn with both foreground and
  background colors. This is done by the <CODE>displayOpaqueString:</CODE>
  and <CODE>displayOpaqueForm:</CODE> methods.
<BR>
  These will draw 1-bits using the current paint color, and 0-bits
  using the background-paint color. The background color can be either
 defined
together with the paint color in the <CODE>paint:on:</CODE> message,
or separate with the <CODE>bgPaint:</CODE> message.
<BR>
  Examples:
<P>

<H5><A HREF="#I_DRAWING_OPQ_STRINGS" NAME="DRAWING_OPQ_STRINGS">Drawing opaque strings:</A></H5>

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color red) on:(Color yellow).
    DemoView font:(Font family:'courier'
			  face:'medium'
			 style:'roman'
			  size:12).
    DemoView displayOpaqueString:'hello' x:20 y:50
</CODE></PRE>
</A>

<H5><A HREF="#I_DRAWING_OPQ_BITMAPS" NAME="DRAWING_OPQ_BITMAPS">Drawing opaque bitmaps:</A></H5>

<A TYPE="example">
<PRE><CODE>
    |f|

    f := Image fromFile:'libtool/bitmaps/SBrowser.xbm'.
    DemoView clear.
    DemoView paint:(Color red) on:(Color yellow).
    DemoView displayOpaqueForm:f x:20 y:50
</CODE></PRE>
</A>

  going back to the non-opaque versions, these do NOT modify the
  pixels where 0-bits are in the image/string.
<BR>
  Thus, you can create transparency effects as in:

<A TYPE="example">
<PRE><CODE>
    |bits|

    DemoView clear.
    DemoView paint:(Color red) on:(Color yellow).
    "
     draw a string using both foreground and background colors
    "
    DemoView font:(Font family:'courier'
			  face:'medium'
			 style:'roman'
			  size:12).
    DemoView displayOpaqueString:'hello' x:0 y:15.

    bits := Image
	    width:16
	    height:16
	    fromArray:#[
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000

		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111].

    DemoView paint:(Color green).
    "
     draw 1-bits only
    "
    DemoView displayForm:bits x:0 y:0
</CODE></PRE>
</A>

<A HREF="#I_IMAGEPAINT" NAME="DRAWING_IMAGEPAINT">Using bitmaps as paint:</A>
<P>
  <CITE>Smalltalk/X</CITE> not only supports colors as paint/bgPaint -
  you can also specify bitmaps to draw with.
<BR>
  example:

<A TYPE="example">
<PRE><CODE>
    |pattern|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.

    DemoView clear.
    "
     draw a wide line using that 'pattern'-color
    "
    DemoView paint:pattern.
    DemoView lineWidth:10.
    DemoView displayLineFromX:10 y:10 toX:80 y:40.
</CODE></PRE>
</A>

  or:

<A TYPE="example">
<PRE><CODE>
    |pattern poly|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.

    DemoView clear.
    "
     draw a wide line using that 'pattern'-color
    "
    DemoView paint:pattern.
    DemoView lineWidth:10.
    DemoView joinStyle:#round.
    poly := Array with:(50 @ 10)
		  with:(90 @ 90)
		  with:(10 @ 90)
		  with:(50 @ 10).
    DemoView displayPolygon:poly.
</CODE></PRE>
</A>

(see a more detailed description of joinStyle below).
<P>
  of course, filling works too:

<A TYPE="example">
<PRE><CODE>
    |pattern|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.

    DemoView clear.
    DemoView paint:pattern.
    DemoView fillCircle:(50@50) radius:25.
</CODE></PRE>
</A>

  the same is true for strings:

<A TYPE="example">
<PRE><CODE>
    |pattern|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.

    DemoView clear.
    DemoView paint:pattern.
    DemoView font:(Font family:'helvetica'
			  face:'bold'
			 style:'roman'
			  size:24).
    DemoView displayString:'Wow !' x:10 y:50
</CODE></PRE>
</A>

  opaque strings:

<A TYPE="example">
<PRE><CODE>
    |pattern|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.

    DemoView clear.
    DemoView paint:pattern on:(Color yellow).
    DemoView font:(Font family:'helvetica'
			  face:'bold'
			 style:'roman'
			  size:24).
    DemoView displayOpaqueString:'Wow !' x:10 y:50
</CODE></PRE>
</A>


  another opaque string:

<A TYPE="example">
<PRE><CODE>
    |pattern|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.

    DemoView clear.
    DemoView paint:(Color yellow) on:pattern.
    DemoView font:(Font family:'helvetica'
			  face:'bold'
			 style:'roman'
			  size:24).
    DemoView displayOpaqueString:'Wow !' x:10 y:50
</CODE></PRE>
</A>

  finally, an opaque string with both fg and bg being patterns:

<A TYPE="example">
<PRE><CODE>
    |pattern1 pattern2|

    pattern1 := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.
    pattern2 := Image fromFile:'libwidg3/bitmaps/granite.tiff'.

    DemoView clear.
    DemoView paint:pattern1 on:pattern2.
    DemoView font:(Font family:'helvetica'
			  face:'bold'
			 style:'roman'
			  size:24).
    DemoView displayOpaqueString:'Wow !' x:10 y:50
</CODE></PRE>
</A>

  and bitmaps:

<A TYPE="example">
<PRE><CODE>
    |pattern bits|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.
    DemoView clear.
    DemoView paint:pattern.
    bits := Image fromFile:'libtool/bitmaps/SBrowser.xbm'.
    bits := bits magnifiedBy:(2 @ 2).

    DemoView displayForm:bits x:5 y:5
</CODE></PRE>
</A>

  or:

<A TYPE="example">
<PRE><CODE>
    |bits pattern|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.
    bits := Image
	    width:16
	    height:16
	    fromArray:#[
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000
		2r11111111 2r00000000

		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111
		2r00000000 2r11111111].

    DemoView clear.
    DemoView paint:pattern.
    DemoView displayForm:bits x:0 y:0
</CODE></PRE>
</A>

  opaque bitmaps (foreground is a pattern, background a color):

<A TYPE="example">
<PRE><CODE>
    |pattern bits|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.
    bits := Image fromFile:'libtool/bitmaps/SBrowser.xbm'.
    bits := bits magnifiedBy:(2 @ 2).

    DemoView clear.
    DemoView paint:pattern on:Color yellow.
    DemoView displayOpaqueForm:bits x:0 y:0
</CODE></PRE>
</A>

  or (foreground is a color, background a pattern):

<A TYPE="example">
<PRE><CODE>
    |pattern bits|

    pattern := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.
    bits := Image fromFile:'libtool/bitmaps/SBrowser.xbm'.
    bits := bits magnifiedBy:(2 @ 2).

    DemoView clear.
    DemoView paint:Color yellow on:pattern.
    DemoView displayOpaqueForm:bits x:0 y:0
</CODE></PRE>
</A>

  or even (both foreground and background are patterns):

<A TYPE="example">
<PRE><CODE>
    |pattern1 pattern2 bits|

    pattern1 := Image fromFile:'libwidg3/bitmaps/woodH.tiff'.
    pattern2 := Image fromFile:'libwidg3/bitmaps/granite.tiff'.
    bits := Image fromFile:'libtool/bitmaps/SBrowser.xbm'.
    bits := bits magnifiedBy:(2 @ 2).

    DemoView clear.
    DemoView paint:pattern1 on:pattern2.
    DemoView displayOpaqueForm:bits x:0 y:0
</CODE></PRE>
</A>

<H4><A HREF="#I_DRAWING_LINESTYLE" NAME="DRAWING_LINESTYLE">Line styles</A></H4>
<P>
In the above line, rectangle, polygon and arc examples, we were drawing solid
lines. You can also draw dashed lines:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView lineStyle:#dashed.
    DemoView displayLineFromX:10 y:10 toX:80 y:10.
    DemoView displayLineFromX:10 y:10 toX:80 y:80.
    DemoView displayLineFromX:10 y:10 toX:10 y:80.
</CODE></PRE>
</A>

the above lineStyle only draws every second dash with the current paint
color. The doubleDash mode draws every dash, with alternating paint and
backgroundPaint colors (like opaque drawing).

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView lineStyle:#doubleDashed.

    DemoView paint:(Color red) on:(Color yellow).
    DemoView displayLineFromX:10 y:10 toX:80 y:10.
    DemoView displayLineFromX:10 y:10 toX:80 y:80.
    DemoView displayLineFromX:10 y:10 toX:10 y:80.
</CODE></PRE>
</A>

the default (if not specified otherwise) is solid:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView lineStyle:#solid.
    DemoView displayLineFromX:10 y:10 toX:80 y:10.
    DemoView displayLineFromX:10 y:10 toX:80 y:80.
    DemoView displayLineFromX:10 y:10 toX:10 y:80.
</CODE></PRE>
</A>

<H5><A HREF="#I_DRAWING_LINEWIDTH" NAME="DRAWING_LINEWIDTH">Line width</A></H5>
<P>
You can set the lineWidth with <CODE>#lineWidth:</CODE>. The argument
is width of the line in pixels.

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView lineWidth:5.
    DemoView displayLineFromX:10 y:10 toX:80 y:10.

    DemoView lineWidth:10.
    DemoView displayLineFromX:20 y:20 toX:80 y:80.

    DemoView lineWidth:1.
    DemoView displayLineFromX:10 y:30 toX:10 y:80.
</CODE></PRE>
</A>
a special lineWidth of 0 (zero) means: the fastest possible thin line.
This is actually a speciality of the X11 protocol. On non X11 systems,
zero-width lines are drawn as regular one-pixel lines.
<BR>
Zero width lines are the default - they are usually much faster than
one-pixel lines, since a faster algorithm is often used in the X11 server.
<P>



<H5><A HREF="#I_DRAWING_JOINSTYLE" NAME="DRAWING_JOINSTYLE">Join style </A></H5>
<P>
When drawing wide lines, you may want to control how the endpoints look
and how line segments of polygons and rectangles are joined.
These are called <VAR>capStyle</VAR> and <VAR>joinStyle</VAR>.
For thin lines, different settings may not make any visible difference.
<P>
The joinStyle controls how the lines of a rectangle or polygon are
to be connected;
<BR>
The following examples show various joinStyles:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView joinStyle:#miter.   "/ thats the default anyway
    DemoView lineWidth:10.
    DemoView displayRectangleX:10 y:10 width:80 height:80.
</CODE></PRE>
</A>

and:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView joinStyle:#round.
    DemoView lineWidth:10.
    DemoView displayRectangleX:10 y:10 width:80 height:80.
</CODE></PRE>
</A>

it makes more of a difference with non 90-degrees angles as in:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView joinStyle:#miter.   "/ thats the default anyway
    DemoView lineWidth:10.
    DemoView displayPolygon:(Array with:10@10
				   with:80@10
				   with:45@80
				   with:10@10)
</CODE></PRE>
</A>

compare to:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView joinStyle:#round.
    DemoView lineWidth:10.
    DemoView displayPolygon:(Array with:10@10
				   with:80@10
				   with:45@80
				   with:10@10)
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView joinStyle:#bevel.
    DemoView lineWidth:10.
    DemoView displayPolygon:(Array with:10@10
				   with:80@10
				   with:45@80
				   with:10@10)
</CODE></PRE>
</A>


<H5><A HREF="#I_DRAWING_CAPSTYLE" NAME="DRAWING_CAPSTYLE">Cap style</A></H5>

<P>
The capStyle controls how the endPoints of individual lines
are to be drawn:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView capStyle:#butt.   "/ thats the default anyway
    DemoView lineWidth:10.
    DemoView displayLineFromX:10 y:10 toX:80 y:10.
    DemoView displayLineFromX:10 y:30 toX:80 y:80.
</CODE></PRE>
</A>

or:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).

    DemoView capStyle:#round.
    DemoView lineWidth:10.
    DemoView displayLineFromX:10 y:10 toX:80 y:10.
    DemoView displayLineFromX:10 y:30 toX:80 y:80.
</CODE></PRE>
</A>

a special capStyle is <CODE>#notLast</CODE> which suppresses drawing of
the endPoint. This is useful if lines are drawing in xor-mode (i.e. inverting),
to avoid inverting the connecting points of a polygon twice.
<P>
(Notice: you need a pixel magnifier (<VAR>xmag</VAR>) to see the differences
of the next two examples.)
<BR>
This inverts the endPoints twice - leaving a one pixel hole:
<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color allColor).

    DemoView capStyle:#butt.
    DemoView lineWidth:0.
    DemoView function:#xor.
    DemoView displayLineFromX:10 y:10 toX:80 y:10.
    DemoView displayLineFromX:80 y:10 toX:80 y:80.
    DemoView displayLineFromX:80 y:80 toX:10 y:10.
    DemoView function:#copy.
    DemoView paint:(Color yellow).
</CODE></PRE>
</A>
This inverts triangle correctly:
<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color allColor).

    DemoView capStyle:#notLast.
    DemoView lineWidth:0.
    DemoView function:#xor.
    DemoView displayLineFromX:10 y:10 toX:80 y:10.
    DemoView displayLineFromX:80 y:10 toX:80 y:80.
    DemoView displayLineFromX:80 y:80 toX:10 y:10.
    DemoView function:#copy.
    DemoView paint:(Color yellow).
</CODE></PRE>
</A>
<DL><DT>Notice:<DD>
Some displays have problems with wide lines (lineWidth > 1),
and either ignore the cap-not-last setting, or display a wrong
picture.
<BR>
You should only use this for thin lines (or blame it on the display vendor ;-).
</DL>


<H4><A HREF="#I_DRAWING_TRANSFORMATION" NAME="DRAWING_TRANSFORMATION">Transformations </A></H4>

<P>
Every drawable supports coordinate transformations. In all of the
above examples, we have been drawing using device coordinates

(actually, we should
say: <VAR>"we have been drawing using an identity transformation"</VAR>).
<P>
Each drawable contains a <VAR>transformation</VAR> object which must be
an instance of <CODE>WindowingTransformation</CODE> and can be set up
to both scale and translate coordinates of the drawable.
If the transformation is set to nil, this is equivalent to the identity
transformation (i.e. scale of 1 and translation of 0).
<P>
In <CITE>Smalltalk/X</CITE> this transformation also affects clipping and
event coordinates - thus, once you defined your logical coordinates, your
view will receive button, keyboard and redraw events in logical coordinates too.
<P>
As a first, simple example, lets scale all drawing by a factor of 2:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).
    DemoView lineWidth:1.

    DemoView transformation:nil.
    DemoView displayLineFromX:10 y:10 toX:40 y:10.

    (Delay forSeconds:1) wait.
    DemoView transformation:(WindowingTransformation
				    scale:2@2 translation:0@0).

    DemoView displayLineFromX:10 y:10 toX:40 y:10.
</CODE></PRE>
</A>

everything will be transformed; even strings, bitmaps and line widths:

<A TYPE="example">
<PRE><CODE>
    |img|

    img := Image fromFile:'libtool/bitmaps/SBrowser.xbm'.
    DemoView clear.
    DemoView paint:(Color yellow) on:(Color red).
    DemoView lineWidth:1.

    DemoView transformation:nil.
    DemoView displayLineFromX:10 y:10 toX:40 y:10.
    DemoView displayOpaqueForm:img x:20 y:20.
    DemoView displayOpaqueString:'hello' x:50 y:30.

    (Delay forSeconds:1) wait.
    DemoView transformation:(WindowingTransformation
				    scale:2@2 translation:0@0).

    DemoView displayLineFromX:10 y:10 toX:40 y:10.
    DemoView displayOpaqueForm:img x:20 y:20.
    DemoView displayOpaqueString:'hello' x:50 y:30.
</CODE></PRE>
</A>

(notice, that transformations also work with all of the above drawing
 operations; you may want to try the opaque string and bitmap examples above
 again with scaling now in effect)
<P>
there are also convenient methods in <CODE>WindowingTransformation</CODE>
to setup for drawing in real-world units, such as inches or millimeters.
In the following, drawing is done in centimeters:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).
    DemoView lineWidth:1.

    DemoView transformation:(WindowingTransformation
				    unit:#cm on:Display).

    DemoView displayLineFromX:0 y:0.1 toX:5 y:0.1.
    0 to:5 do:[:i |
	DemoView displayLineFromX:i y:0 toX:i y:0.2.
    ]
</CODE></PRE>
</A>

the same in inches:

<A TYPE="example">
<PRE><CODE>
    DemoView clear.
    DemoView paint:(Color yellow).
    DemoView lineWidth:1.

    DemoView transformation:(WindowingTransformation
				    unit:#inch on:Display).

    DemoView displayLineFromX:0 y:0.1 toX:3 y:0.1.
    0 to:3 by:0.25 do:[:i |
	DemoView displayLineFromX:i y:0 toX:i y:0.2.
    ]
</CODE></PRE>
</A>

the above examples show one problem with scaling: you may want to label the above
line (think of axes being drawn). In this labelling, the coordinates should be
transformed, while the string itself shoul be drawn unscaled.
<BR>
For this, you can use <CODE>displayUnscaledString:x:y:</CODE> which
transformes the x/y coordinate, but draws the unscaled (device) font.

<A TYPE="example">
<PRE><CODE>
    DemoView viewBackground:(Color blue).
    DemoView clear.
    DemoView paint:(Color yellow).
    DemoView lineWidth:1.

    DemoView transformation:(WindowingTransformation
				    unit:#inch on:Display).

    DemoView displayLineFromX:0 y:0.1 toX:3 y:0.1.
    0 to:3 by:0.25 do:[:i |
	DemoView displayLineFromX:i y:0 toX:i y:0.2.
    ].
    DemoView font:(Font family:'helvetica'
			  face:'medium'
			 style:'roman'
			  size:12).
    0 to:3 do:[:i |
	DemoView displayUnscaledString:i printString x:i y:0.3.
    ]
</CODE></PRE>
</A>

There are also unscaled versions of the opaque string methods and
the bitmap display methods.
<P>
Of course, instead of using these unscaled versions, you could also switch
back to an identity transformation when drawing those strings. But then,
you still had to apply the transformation manually to the x/y coordinates of
the strings.
<P>
To get transformed values of your coordinates, transformations may be
manually applied. For example:
<PRE><CODE>
    devicePoint := (aView transformation) applyTo:logicalPoint
</CODE></PRE>
or vice versa (i.e. from device coordinates back to logical coordinates):
<PRE><CODE>
    logicalPoint := (aView transformation) applyInverseTo:devicePoint
</CODE></PRE>
Internally,  <CITE>Smalltalk/X</CITE> uses the transformation also for scrolling.
Therefore, all scrolling operations are transparent to your drawing calls.




<H2><A HREF="#I_COLORS" NAME="COLORS">Colors</A></H2>

Instances of <CODE>Color</CODE> represent colors in a device independent
way. Internally, they store the red, green and blue components.
Since the eye only differenciates between about 100 greylevels,
the rgb values of the actually displayed colors may be rounded somewhat,
when colors are displayed on the screen.
<P>
Instances are created by:
<PRE><CODE>
    |myColor|

    myColor := Color red:50 green:100 blue:0.
</CODE></PRE>
The component values are in percent, ranging from 0/0/0 (for black)
to 100/100/100 (for white). Thus, the above color should be some
lime-like green-yellow.
<P>
Color offers variants of the above instance creation message,
(which may be useful, if the r/g/b values were read from some file):
<PRE><CODE>
    myColor := Color redByte:r greenByte:g blueByte:b.
</CODE></PRE>
takes byte-valued integral r/g/b values (i.e. 0..255) and is useful,
if colorValues are read from an image file,
<PRE><CODE>
    myColor := Color gray:grayPercent.
</CODE></PRE>
creates a gray color with given brighness
percentage (i.e. all of red, green and blue get the same)
<PRE><CODE>
    myColor := Color cyan:c magenta:m yellow:y
</CODE></PRE>
uses the c/m/y color space (which is used with printing)
and finally:
<PRE><CODE>
    myColor := Color hue:h light:l saturation:s
</CODE></PRE>
takes h/l/s arguments, where hue is the position on the color wheel
(in degrees 0..360), light is the brightnes of the color (0..100)
and saturation gives the amount of color (0 is gray, 100 is fully saturated).



<P>
For common colors (red, green, blue, yellow, black, white and a few more),
a short instance creation protocol is also avaliable:
<PRE><CODE>
    myColor := Color red.  "or green, blue, black etc."
</CODE></PRE>
<P>

For <CITE>ST-80</CITE> compatibility, there exists a companion class
called <CODE>ColorValue</CODE>. This class expects r/g/b components
in [0..1]. Therefore, you can also write:
<PRE><CODE>
    ColorValue red:0.5 green:1.0 blue:0.0
</CODE></PRE>
or:
<PRE><CODE>
    ColorValue brightness:0.5
</CODE></PRE>
and get the same color as from corresponding messages to Color.

<P>
After creation, colors are not associated to a specific device.
This is done by sending <CODE>onDevice:<VAR>aDevice</VAR></CODE> to the color instance.
The device argument can be either a Workstation device (such as Display)
or some other medium, such as a postscript printer.
Once associated to a device, a color stores the device id of the color
(which is either the colormap index or any other device handle for the color)
internally.
<BR>
All of the above described drawing methods perform this device conversion
automatically. However, to avoid this operation to be repeated over and over
with every draw, it is wise to add code to do this conversion once during
early startup of your view (if you have defined your own subclass of view).
<BR>
For example, your views <CODE>#initialize</CODE> method could look like:
<PRE><CODE>
    ...
    super initialize.
    ...
    myPaintColor := someColor onDevice:device.
    ...
</CODE></PRE>
and use <VAR>myPaintColor</VAR> for drawing operations.
<P>
Be careful, once the color is reclaimed by the garbage collector,
the corresponding device color will be freed as well.
This may lead to hard to find redraw bugs, if you do something like:
<PRE><CODE>
    ...
    aView paint:(Color yellow).
    ...
    aView paint:(Color green).
    ...
</CODE></PRE>
and a garbage collect occurs in between. In the above, something is drawn
in yellow, for which the next free device color is allocated.
If a garbage collect occurs in between, this colormap entry may be reclaimed and
reused for the green color. Everything drawn in yellow before will now (since
the devices colormap has changed) be shown in green too !
<P>
To avoid the above, you must keep a reference to the device color somewhere,
to prevent the garbage collector from reclaiming the color cell, as long
as the view is visible.
The best strategy is to keep all used colors in some instance variable of the
view or of your model (as was done in the above <CODE>#initialize</CODE> method).
i.e.:
<PRE><CODE>
    in an instance variable:
	    ... myColors yellow green ...

    myColors := OrderedCollection new.
    yellow := Color yellow onDevice:Display.
    green := Color green onDevice:Display.
    myColors add:yellow; add:green.

    ...
    aView paint:yellow.
    ...
    aView paint:green.
    ...
</CODE></PRE>

For raster operations, special colors where the pixel value is given,
are required. These are created with:

<UL>
<LI><CODE>Color noColor</CODE>
<BR>
Returns a ``color'' with a pixelValue of 0 (zero)
<P>
<LI><CODE>Color allColor</CODE>
<BR>
Returns a ``color'' with a pixelValue of all ones (16rFFF...FFF)
<P>
<LI><CODE>Color colorId:<VAR>aNumber</VAR></CODE>
<BR>
Returns a ``color'' with a pixelValue of <VAR>aNumber</VAR>
</UL>

Finally, on displays which use a color lookup table, writable color cells
can be allocated with:
<PRE><CODE>
    <VAR>variableColor</VAR> := Color variableColorOn:<VAR>aDevice</VAR>
</CODE></PRE>
this special `colors' pixelValue is fixed, but its r/g/b components
can be changed at any later time with:
<PRE><CODE>
    <VAR>variableColor</VAR> red:<VAR>r</VAR> green:<VAR>g</VAR> blue:<VAR>b</VAR>
</CODE></PRE>

example:
<A TYPE="example">
<PRE><CODE>
     |l cell|

     cell := Color variableColorOn:(Screen current).
     cell isNil ifTrue:[^ self warn:'variable color not available'].

     l := Label new.
     l label:('hello' asText allBold).
     l foregroundColor:cell.
     l open.

     l := EditTextView new.
     l contents:('hello\world\this is\blinking'asText
		    emphasizeFrom:21 to:28
			     with:(Array
				       with:#bold
				       with:(#color->cell))
		) withCRs.
     l open.

     [
	1 to:30 do:[:i|
	    i odd ifTrue:[
		cell red:100 green:0 blue:0
	    ] ifFalse:[
		cell red:0 green:0 blue:0
	    ].
	    Display flush.
	    (Delay forSeconds:0.4) wait
	].
	1 to:30 do:[:i|
	    i odd ifTrue:[
		cell red:0 green:100 blue:0
	    ] ifFalse:[
		cell red:0 green:0 blue:0
	    ].
	    Display flush.
	    (Delay forSeconds:0.4) wait
	].
     ] fork.
</CODE></PRE>
</A>

Be careful when using these writable color cells: they are not
available on all display types (trueColor, greyscale or black&amp;white systems).
<BR>
Always write your application to provide a fallback algorithm (for example,
by doing full redraws) in case the display server does not use a color
lookup table.
<BR>
(ask the display for its capabilities, using <CODE>Display visualType</CODE>.)




<H2><A HREF="#I_FONTS" NAME="FONTS">Fonts</A></H2>

Instances of <CODE>Font</CODE> represent fonts in a device independent
way. Internally, they store the name of the font as family, face, style
and size.
<BR>
Instances are created by:
<PRE><CODE>
    |myFont|

    myFont := Font family:'times'
		     face:'medium'
		    style:'roman'
		     size:12
</CODE></PRE>
The size parameter is <STRONG>not</STRONG> the number of device pixels,
but instead the point size (printer units) of the font. Here, one point
is 1/72'th of an inch.
<BR>
Therefore a size 12 font may (and will) have a different number of
device pixels depending on the medium on which it is to be rendered.
On a 100dpi display, it will be about 12*(1/72)*100 = 16 pixels high;
on a 75dpi display, about 12 and on a 300 dpi printer page, there will
be roughly 12*(1/72)*300 = 48 pixels. The device is free to round, or take
a nearby size as replacement. You should make your applications drawing
independ if the physical size.
<P>
You can work with fonts in this device independent manner as long
as no device specific queries are to be made. All drawing operations
(i.e. displayString...) will take device independent fonts and
convert themself to a device representation.
<P>
Therefore, you can use the same font object for different display
media - for example, a view and a postscript printer page.
<BR>
As in:
<PRE><CODE>
    |myFont myView myPage|

    myFont := Font family:'times'
		     face:'medium'
		    style:'roman'
		     size:12.

    myView := View in: .....

    myPage := PSGraphicsContext ....

    myView font:myFont.
    myView displayString: ....

    myPage font:myFont.
    myPage displayString: ....
</CODE></PRE>
However, as soon as you need some physical characteristics of a font,
you need a font to be <VAR>bound</VAR> to the specific device.
<BR>
The conversion from a device independent font to one that is bound to
a specific device is done by sending "<CODE>onDevice:<VAR>aDevice</VAR></CODE>"
to a font (similar to the color handling).
The returned value is an instance of Font which represents the same font as
the original, but is bound to that device (if the original was already
for that device, this is a noop and the original font is returned.
Therefore, if in doubt, use this conversion;
it does not hurt).
<P>
In particular, this conversion is required when asking a font for its
<VAR>ascent</VAR>, <VAR>descent</VAR>, <VAR>height</VAR> and some other
device specific attributes.
<P>
You will get an error (debugger) when asking a font which is not bound to
a device about these attributes.
<P>
As a summary, have a look at the following code fragment:
<PRE><CODE>
    |f|

    f := Font family:'times'
		face:'medium'
	       style:'roman'
		size:18.
    f := f onDevice:(DemoView device).
    DemoView displayString:'hello' x:0 y:(f ascent).
    DemoView displayString:'world' x:0 y:(f height + f ascent).
</CODE></PRE>
in the above, <CODE>ascent</CODE> asks for the number of pixels
above the baseline (remember: displayString's y argument specifies the
y coordinate of the baseline) and
<CODE>height</CODE> asks for the fonts overall height (i.e. ascent plus
descent).

<H2><A HREF="#I_CURSORS" NAME="CURSORS">Cursors</A></H2>

For cursors, the same device-independent vs. device dependent story is
true as for fonts or colors.
However, this conversion is typically done automatically
by the views cursor setting methods.
<P>
A cursor can be created from a bitmap array, from a form or from an image.
Also, for the most commonly used cursors, you will find convenient
methods in Cursors class protocol.
<BR>
For example, the waiting hourglass cursor is returned by:
<PRE><CODE>
    Cursor wait
</CODE></PRE>
or a standard arrow cursor is returned by:
<PRE><CODE>
    Cursor normal
</CODE></PRE>
<P>
To load a cursor from a bitmap image found in a file,
first read the file into an image instance, then convert it
into a cursor.
<BR>
For example:
<PRE><CODE>
    |img cursor|

    img := Image fromFile:'goodies/bitmaps/xpmBitmaps/cursors/cross2.xpm'.
    cursor := Cursor fromImage:img.
</CODE></PRE>


Once the cursor is created, you can set it in any view with:
<PRE><CODE>
    aView cursor:someCursor
</CODE></PRE>
or, a concrete example using above demoView:
<PRE><CODE>
    DemoView cursor:(Cursor wait)
</CODE></PRE>
There are also convenient methods to change the cursor in all views
which belong to a common windowGroup - either permanently or
for the duration of some block evaluation.
(You can ask every view about its
 windowGroup by sending it <CODE>#windowGroup</CODE>).
<BR>
Thus, a busy subview can change the cursor of all its relatives
with (assuming <VAR>self</VAR> is some view):
<PRE><CODE>
    self windowGroup withCursor:(Cursor wait)
    do:[
	...
	... long computation
	...
    ]
</CODE></PRE>
using this assures correct restoration of the original cursors
- even in case of an aborted or terminated computation.
<BR>
Beside windowGroups, views also understand this message:
<BR>
(assuming <VAR>self</VAR> is some view)
<PRE><CODE>
    self withCursor:(Cursor wait)
    do:[
	...
	... long computation
	...
    ]
</CODE></PRE>
Here, only that single views cursor is changed for the duration of
the block evaluation.
<P>

Finally, standardSystemViews also offer this interface to change
the cursor in itself and all of its subviews. Since all topviews
are instances of <CODE>StandardSystemView</CODE> (or of its subclasses),
a busy view can also use:
<PRE><CODE>
    self topView withCursor:(Cursor wait)
    do:[
	...
	... long computation
	...
    ]
</CODE></PRE>


So you can decide if a wait cursor is to be shown in a single view
in a single topView with all of its subviews,
or in all views belonging to that windowGroup.

<P>
For <CITE>ST-80</CITE> compatibility, cursors also support the
<CODE>showWhile:</CODE> message. This will display the receiver cursor
in <STRONG>ALL</STRONG> views while evaluating the block argument.
<P>

Example:
<A TYPE=example>
<PRE><CODE>
    |top v1 v2 v3 v4|

    top := StandardSystemView extent:200@200.
    v1 := View origin:0.0@0.0 corner:0.5@0.5 in:top.
    v1 level:-1.
    v2 := View origin:0.5@0.0 corner:1.0@0.5 in:top.
    v2 level:-1.
    v3 := View origin:0.0@0.5 corner:0.5@1.0 in:top.
    v3 level:-1.
    v4 := View origin:0.5@0.5 corner:1.0@1.0 in:top.
    v4 level:-1.

    v1 cursor:(Cursor hand).
    v2 cursor:(Cursor extent:16@16
		      sourceArray:#(
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000
				2r0000000110000000
				2r0000000110000000
				2r0000001111000000
				2r0000111111110000
				2r0000111111110000
				2r0000001111000000
				2r0000000110000000
				2r0000000110000000
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000 )
		      maskArray:#(
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000
				2r0000000110000000
				2r0000000110000000
				2r0000001111000000
				2r0000111111110000
				2r0000111111110000
				2r0000001111000000
				2r0000000110000000
				2r0000000110000000
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000
				2r0000000000000000 )
		      offset:-8@-8).
    v3 cursor:(Cursor fromImage:(Image fromFile:'goodies/bitmaps/xpmBitmaps/cursors/cross2.xpm')).
    v4 cursor:(Cursor normal).
    top openAndWait.

    Delay waitForSeconds:5.
    top withCursor:Cursor wait do:[10000 factorial].
</CODE></PRE>
</A>

<H2><A HREF="#I_EVENTS" NAME="EVENTS">Events</A></H2>

The following is only of interest, if you plan to create your own widgets or
view classes.
<BR>
Every event is initially handled by an event dispatcher process, of which
there is exactly one per display screen.
<BR>
(As described below, you can handle multiple screens,
by starting an event dispatcher and create views on the other display(s)).
<P>
The event dispatcher will read the event and put it into an event queue.
Then the associated windowGroup process gets a signal that some work is
to be done.
<BR>
The event processing method (in <CODE>WindowGroup</CODE>) fetches the event
from the queue
and sends a corresponding message to the view in question.
(see also: <A HREF="processes.html#VIEWSNPROCS">``views and processes''</A>.)
<BR>
All event forwarding is concentrated in one single method
(<CODE>WindowEvent class sendEvent:...</CODE>). Therefore, additional
or different event processing functionality can be easily added there.



<H3><A HREF="#I_EVENTS_TYPES" NAME="EVENTS_TYPES">Event types</A></H3>


The following table lists (the subset of the most interesting)
events and the corresponding messages which are sent to the view:
<BR>
<H4><A NAME="EVENTS_KEYBOARD">Keyboard Events</A></H4>
Keyboard event information constist of the keyCode and
the x/y position of the mouse pointer at the time of the event.
The keycode can be a character for normal
keys or a symbol such as #Copy, #Cut etc. for Acceleration keys.

<UL>
<LI><VAR>key press</VAR>
<BR> - <CODE>keyPress:keyCode x:x y:y</CODE>
<P>

<LI><VAR>key release</VAR>
<BR> - <CODE>keyRelease:keyCode x:x y:y</CODE>
</UL>

<H4><A NAME="EVENTS_MOUSE">Moude Events</A></H4>

For mouseButton press and release events, the
information constist of the button number and
the x/y position of the mouse pointer at the time of the event.
<P>
For motion and enter/leave events, the button-state is encoded
as bits in the buttonState argument, which is an integer number.

<UL>
<LI><VAR>mouse button press</VAR>
<BR>  - <CODE>buttonPress:button x:x y:y</CODE>
<P>

<LI><VAR>mouse button release</VAR>
<BR> - <CODE>buttonRelease:button x:x y:y</CODE>
<P>

<LI><VAR>mouse movement</VAR>
<BR> - <CODE>buttonMotion:buttonState x:x y:y</CODE>
<P>

<LI><VAR>mouse pointer enters view</VAR>
<BR> - <CODE>pointerEnter:buttonState x:x y:y</CODE>
<P>

<LI><VAR>mouse pointer leaves view</VAR>
<BR> - <CODE>pointerLeave:buttonState</CODE>
<P>

<LI><VAR>mouse wheel motion</VAR>
<BR> - <CODE>mouseWheelMotion:buttonState x:x y:y amount:amount deltaTime:dTime</CODE>

</UL>

<H4><A NAME="EVENTS_REDRAW">Redraw and Visibility Events</A></H4>
<UL>
<LI><VAR>expose an area</VAR>
<BR> - <CODE>exposeX:x y:y width:w height:h:</CODE>
<P>

<LI><VAR>view has been mad visible the very first time</VAR>
<BR> - <CODE>mapped</CODE>
<P>

<LI><VAR>the view has been made invisible</VAR>
<BR> - <CODE>unmapped</CODE>
<P>

<LI><VAR>the views visibility has changed</VAR>
<BR> - <CODE>visibilityChanged:</CODE>
<P>
</UL>

<H4><A NAME="EVENTS_CONFIG">Views Configuration</A></H4>
<UL>
<LI><VAR>view has been moved or resized</VAR>
<BR> - <CODE>configureX:x y:y width:w height:h:</CODE>
<P>
</UL>

<H4><A NAME="EVENTS_OTHER">Other events</A></H4>
<UL>
<LI>more are found in the <CODE>SimpleView</CODE>
and especially the <CODE>WindowSensor</CODE>
classes...
</UL>

A special situation arises for events which pass x/y coordinates,
and the view has a (non-identity) transformation defined:
<BR>
In this case, some of the above methods are called with logical coordinates
(i.e. the inverse transformation being applied).
If the view is interested in the raw device events (i.e. device coordinates),
it should redefine the <CODE>deviceXXX</CODE> methods,
which actually do the transformation and
call for one of the above methods with the logical coordinates.
<BR>
For example, to get the device coordinate for buttonPress events,
redefine <CODE>deviceButtonPress:x:y:</CODE> in your view class.
<P>
See the classes <CODE>WindowSensor</CODE>, <CODE>WindowGroup</CODE> and
<CODE>WindowEvent</CODE> for more (internal) details.



<H3><A HREF="#I_EVENTS_ENABLING" NAME="EVENTS_ENABLING">Enabling/disabling events</A></H3>

some special events have to be enabled explicitely - they are ignored
by default.
<BR>
Events are enabled with:
<UL>
<LI><CODE>enableButtonEvents</CODE> - enables buttonPress and buttonRelease
<LI><CODE>enableMotionEvents</CODE> - enables motion events
<LI><CODE>enableEnterLeaveEvents</CODE> - enables pointerEnter and pointerLeave
<P>
<LI><CODE>enableEvent:</CODE><VAR>eventSymbol</VAR> - enables a specific event
<P>
<LI>more are found in PseudoViews protocol ...
</UL>
and disabled with:
<UL>
<LI><CODE>disbaleButtonEvents</CODE> - disables buttonPress and buttonRelease
<LI><CODE>disableMotionEvents</CODE> - disables motion events
<LI><CODE>disableEvent:</CODE><VAR>eventSymbol</VAR> - disables a specific event
<P>
<LI>more are found in PseudoViews protocol ...
</UL>

Key, button, focus and exposeEvents are <b>always</b> enabled by default
(but can be disabled and reenabled).
<P>
See the <CODE>enableXXX</CODE> and <CODE>disableXXX</CODE> methods in
the <CODE>PseudoView</CODE> class for more details.
<P>
<DL><DT>Notice:<DD>
Not all event types will be delivered with some display devices - some
(like colorMap or selection notifications) may be very device specific.
<BR>
Enable/disable messages for those unimplemented events will be silently ignored.
</DL>


<H3><A HREF="#I_EVENTS_FORWARDING" NAME="EVENTS_FORWARDING">Event forwarding: delegates and controllers</A></H3>

Events can be forwarded to a <VAR>delegate</VAR>. Any view with an event
delegate will not receive user events in which the delegate has shown interest.
Instead, these will be forwarded to the delegate with the original view as an addition argument.
<BR>
To delegate events, you need some object which understands one or more of the messages:
<UL>
<LI><CODE>keyPress:key x:x y:y view:aView</CODE>
<LI><CODE>keyRelease:key x:x y:y view:aView</CODE>
<LI><CODE>buttonPress:button x:x y:y view:aView</CODE>
<LI><CODE>buttonShiftPress:button x:x y:y view:aView</CODE>
<LI><CODE>buttonMultiPress:button x:x y:y view:aView</CODE>
<LI><CODE>buttonRelease:button x:x y:y view:aView</CODE>
<LI><CODE>buttonMotion:buttonMask x:x y:y view:aView</CODE>
<LI><CODE>pointerEnter:state x:x y:y view:aView</CODE>
<LI><CODE>pointerLeave:state view:aView</CODE>
</UL>
and set the views delegate with:
<PRE><CODE>
    aView delegate:theDelegate
</CODE></PRE>
Since the delegate may only be interested in some events (and let others
be handled as usual), it will be asked by another message before the above
forwarding takes place. If the delegate has no interest, it should return false
on those messages; otherwise true.
The corresponding query messages are:
<UL>
<LI><VAR>aDelegate</VAR> <CODE>handlesKeyPress:key inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesKeyRelease:key inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesButtonPress:button inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesButtonShiftPress:button inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesButtonMultiPress:button inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesButtonRelease:button inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesButtonMotion:buttonMask inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesPointerEnter:state inView:aView</CODE>
<LI><VAR>aDelegate</VAR> <CODE>handlesPointerLeave:state inView:aView</CODE>
</UL>
If the delegate does not implement those messages, this is taken as if it is
not interested in those events. Therefore, only the <CODE>handlesXXX</CODE>
methods for those that are actually to be forwarded have to be implemented.
<P>
To support both views which do event processing themselves and
views for which a controller (i.e. <CITE>Smalltalk-80's</CITE>
Model-View-Controller or MVC way of handling events),
events are alternatively forwarded to the controller if the views
controller instance variable is non-nil.
<BR>
This makes porting of <CITE>Smalltalk-80</CITE> code easier,
since all you have to do is to set a views controller
to have that controller process these events .
<P>
Delegation via the <VAR>delegate</VAR> takes precedence over the controller.
This allows event delegation even for views which have a controller;
therefore, this allows adding/modifying the behavior of existing widgets
without a need to modify these and/or define a new controller class.
(For example, additional keyboard shortcuts can be easily implemented using
the delegation mechanism.)



<H3><A HREF="#I_EVENTS_SENDING" NAME="EVENTS_SENDING">Sending events to other (alien) views</A></H3>

On some display station types (currently: X displays only),
it is possible to send keyboard events to other (possibly alien) views.
<BR>
A scenario, where this makes sense is to provide input to an inputField
of another application, which does not correctly support the clipboard
mechanism.
<BR>
Low level events are sent with:
<PRE><CODE>
    aDisplayDevice
	sendKeyOrButtonEvent:typeSymbol
	x:xPos
	y:yPos
	keyOrButton:keySymCodeOrButtonNr
	state:stateMask
	toViewId:targetId
</CODE></PRE>

To send a string to some other view (as if it was typed in), there is a more convenient
interface, which breaks up the string into individual characters, and sends individual
<VAR>KeyPress</VAR> and <VAR>KeyRelease</VAR> events:
<PRE><CODE>
    aDisplayDevice simulateKeyboardInput:aCharacterOrString inViewId:viewId
</CODE></PRE>
You have to acquire the alien views ID either by a query to the display:
<PRE><CODE>
    aDisplayDevice viewIdFromPoint:point.
</CODE></PRE>
or by passing it somehow manually
from the other application
(deposit its ID as an XAtom, or pass it as a commandLine argument)
<P>
example:
<A type="example">
<PRE><CODE>
      |point id|

      point :=  Display pointFromUser.
      id := Display viewIdFromPoint:point.
      Display simulateKeyboardInput:'Hello_world' inViewId:id
</CODE></PRE>
</A>
This is a very special functionality and only recommended to help
interfacing to badly written alien applications.




<H3><A HREF="#I_EVENTS_LISTENING" NAME="EVENTS_LISTENING">Event listening</A></H3>

For certain types of applications (event recorders, automatic help messages etc.)
it may be useful to catch <b>any</b> event, for <b>any</b> known view in the smalltalk system.
<BR>
(In theory, this could be acomplished using delegates for every single view -
 but this is too complicated to set up and manage.)
<BR>
To allow for this, the <CODE>WindowSensor</CODE> class allows an object
to be registered as <VAR>listener</VAR>, to be sent every incoming event
<STRONG>before</STRONG> it is dispatched to the corresponding views event queue.
<BR>
Once registered, the event listener will get the same type of messages as
listed for the delegates in the previous section.
<P>
You can register either a global eventListener (which will get events for any
view), by registering your listener in the <CODE>WindowSensor</CODE> class,
<BR>
as in:
<PRE><CODE>
    WindowSensor eventListener:<VAR>someListenerObject</VAR>
</CODE></PRE>
or, for an individual windowSensor (and therefore get the events for all of its
associated views)
<BR>
with:
<PRE><CODE>
    <VAR>aWindowSensor</VAR> eventListener:<VAR>someListenerObject</VAR>
</CODE></PRE>
A concrete application of a sensor-specific listener is to display
a help or info message in some infoView (a label), whenever the pointer
enters a subview (like the lower info-field in MS-Windows applications),
or to display bubble help in some automatically popping view.
<P>
In contrast to the way delegation works, the evenetlistener is <STRONG>not</STRONG>
asked if it responds to those messages; a listener must implement and
respond to all of the above messages.
<BR>
In addition, these methods <STRONG>must</STRONG> return a boolean value.
If they return <CODE>true</CODE>,
the event is <STRONG>not</STRONG> dispatched to the views event queue.
If they return <CODE>false</CODE>, the event is processed as usual.

<BR>
As a consequence, a listener which simply returns <CODE>true</CODE>  in all
of its listener methods, will disable all event handling for the sensors view
or for all views (if its a global listener).
<P>
Be careful (save your work before) when playing with this mechanism;
for the above reason, a faulty event listener may easily lead to a
locked smalltalk system
(however, you can repair things in the miniDebugger:
 enter its interpreter ('I'-command) and evaluate
<CODE>"WindowSensor eventListener:nil"</CODE>
 there).
<P>
It is not possible to listen to events of non-smalltalk (i.e. alien) views with this mechanism.



<H3><A HREF="#I_EVENTS_FLUSHING" NAME="EVENTS_FLUSHING">Flushing events</A></H3>

In some situations, it may be required to remove pending events from
a sensors input queue.
<BR>
A situation where this is useful is to remove typeahead user input,
in case of some error situation.
<BR>
The following flush methods are available:

<UL>
<LI><VAR>aWindowSensor</VAR> <CODE>flushEventsFor:</CODE> <VAR>aViewOrNil</VAR>
<BR>
this flushes all events (both user events and redraw events).
If the argument is nil, events for any view controlled by the sensor are flushed.
Otherwise, only events for that single view are flushed.
<P>

<LI><VAR>aWindowSensor</VAR> <CODE>flushUserEventsFor:</CODE> <VAR>aViewOrNil</VAR>
<BR>
this flushes all user events (i.e. only mouse and keyboard events).
If the argument is nil, events for any view controlled by the sensor are flushed.
Otherwise, only events for that single view are flushed.
<P>

<LI><VAR>aWindowSensor</VAR> <CODE>flushExposeEventsFor:</CODE> <VAR>aViewOrNil</VAR>
<BR>
this flushes all redraw events.
If the argument is nil, events for any view controlled by the sensor are flushed.
Otherwise, only events for that single view are flushed.
<P>

<LI><VAR>aWindowSensor</VAR> <CODE>flushKeyboardFor:</CODE> <VAR>aViewOrNil</VAR>
<BR>
this flushes all keyboard events.
If the argument is nil, events for any view controlled by the sensor are flushed.
Otherwise, only events for that single view are flushed.
</UL>



<H2><A HREF="#I_MULTISCREEN" NAME="MULTISCREEN">Handling multiple screens</A></H2>

<CITE>Smalltalk/X</CITE>'s combination of event and process driven event
handling allows the system to serve multiple display screens; in fact,
the setup required to implement applications doing this is pretty easy.
(especially, due to the way, colors, fonts etc. are handled).
<BR>
Of course, handling multiple screens is not possible with all types of display:
a Windows or OS/2 Display does not support remote access;
therefore, the things described below are (currently) only valid for
Xserver based implementations.
<P>
Lets first repeat, how the event mechanism works in <CITE>ST/X</CITE>:
<P>
The physical reading of display related events is done by the event
dispatcher process (created in <CODE>aDisplay startDispatch</CODE>).
This process keeps waiting for arriving events, reads them and forwards
them to a per-windowgroup event queue.
<BR>
On the other side of the queue, the process associated to the windowGroup
waits on a semaphore for arriving events and handles them by forwarding
the events to the controller object which is associated to the
view which received the event (or, directly to the view, if it
happens to have no controller).
<BR>
This is done in a method in <CODE>WindowSensor</CODE>.
<P>
All we have to do for multiple display screens is to start an event
dispatcher process for the other display, and create views on this new
display.
<P>
The steps to do this are:

<UL>
<LI >create a new instance of XWorkstation (or GLXWorkstation):

<A TYPE="example">
<PRE><CODE>
    Smalltalk at:#Display2 put:(XWorkstation new).
</CODE></PRE>
</A>

this simply creates a new display object - there is no connection or
event dispatching yet. In the example above, we keep this object in a global
variable for later accessibility (in the examples below).
<BR>
However, in a real application - you should keep
a collection of open displays somewhere in your application, and possibly
add some administration functionality to allow remote display processes
to be managed somehow
(for a first start, the ProcessMonitor should be fine).
<P>
<LI>have it connect to the display (i.e. the xServer):
<BR>
(replace 'porty' below with the name of your display)

<A TYPE="example">
<PRE><CODE>
    Display2 := Display2 initializeFor:'porty:0.0'
</CODE></PRE>
</A>

(this expression returns nil, if the connection is refused by the
Xserver or any other error occurs).
<BR>
The argument to the <CODE>#initializeFor:</CODE> method is
class specific. Currently, for Xdisplays, this is the name of the
display station and its screen number (usually 0.0).
<BR>
On other display hardware (i.e. instances of other display classes),
you may have to provide a different argument value.
<P>

<LI>setup an I/O error exception handling procedure
<BR>
This is required to prevent broken connections (i.e. switching off remote
displays) from stopping the show for all users.
To do so, a static exception handler is required for the per-display
I/O error signals:
<BR>
<A TYPE="example">
<PRE><CODE>
    Display2 deviceIOErrorSignal handlerBlock:[:ex |
	Transcript beep.
	Transcript showCR:'Display (' , Display2 displayName , '): connection broken.'.
	AbortSignal raise.
    ].
</CODE></PRE>
</A>
If no such handler is setup, a broken connection will lead to a
debugger to be opened on the main display (i.e. the startup display).
<P>

<LI>start an event dispatcher process for it

<A TYPE="example">
<PRE><CODE>
    Display2 startDispatch
</CODE></PRE>
</A>

once the above has been executed, you will find the new event dispatcher process
in the <VAR>ProcessMonitor</VAR> ready to receive events.
<P>

<LI>create views on this display

<A TYPE="example">
<PRE><CODE>
    (FileBrowser onDevice:Display2) open
</CODE></PRE>
</A>
or:
<A TYPE="example">
<PRE><CODE>
    (Workspace onDevice:Display2) open
</CODE></PRE>
</A>
or:
<A TYPE="example">
<PRE><CODE>
    (OldLauncher onDevice:Display2) open
</CODE></PRE>
</A>

The <CITE>Smalltalk/X</CITE> <CODE>ApplicationModel</CODE> class has been
changed to also allow opeing its views on remote displays;
<BR>
Therefore, you can also start applications on other displays:
<A TYPE="example">
<PRE><CODE>
    (Launcher onDevice:Display2) open
</CODE></PRE>
</A>



</UL>
Thats it; this even allows a team of programmers to
work concurrently in different browsers (on different screens)
within the same executing smalltalk system
(or your data entry application to handle multiple Xterminals).
<P>
Since some of the default displays state was initialized from
your startup file (keyboard &amp; button mappings), these are obviously
not set correctly in this new display.
<BR>
Therefore, you may want to setup these with:

<A TYPE="example">
<PRE><CODE>
    Display2 keyboardMap:(Display keyboardMap).
    Display2 buttonTranslation:(Display buttonTranslation).
</CODE></PRE>
</A>

before opening the first views on the other display.


<VAR>Additional background info:</VAR>
<BR>
Previous versions of <CITE>ST/X</CITE> accessed a global variable
(named <CODE>"Display"</CODE>) in many places to refer to the display screen.
(actually, this was a leftover from attempts to be ST-80V2.x compatible)
<BR>
For example, popUpMenus, fonts,
colors etc. were always created on this device by default.
<BR>
This was changed in the newest version to use
<CODE>"Screen current"</CODE> instead. This expression refers to the currently
active screen at the time the process runs, and will return different
display instances for processes running under different screeens windowGroups.
<BR>
In order to avoid limiting yourself to single display operation,
do not access the global <CODE>"Display"</CODE>.
If at all, the default screen should now be accessed in programs
via <CODE>"Screen default"</CODE>.
<BR>
(remember the section on using globals in the coding style document ?)
<P>
If you ever plan to support multiple display screens
(and, you never know for sure), you should <STRONG>NOT</STRONG> repeat
the authors bugs and also use <CODE>"Screen current"</CODE> whenever creating
new views with an explicit display assignment.
<BR>
If you do not give an explicit display device (i.e. you use <CODE>"someView open"</CODE>),
the default device will be the one returned by above expression.
<P>
Due to the device independent way colors, cursors, fonts etc. are handled,
you do not have to change your single display application to be
operated on multiple concurrent displays.
<BR>
(it looks as if the initial design of the display interface
 was not too bad; after all no single line of the existing applications views
 had to be changed for multiple screen support ;-)
<P>
Be reminded, that multiple screen handling has not been
fully tested and is still an experimental feature.
There may still be a few places left in the system,
which refer to the explicit <CODE>"Display"</CODE>. If you encounter
any of these and have problems due to that, please let the autor know
about this. There is no warranty, that things work correctly everywhere
and popUps or dialogs will not be opened on the default screen occasionally.
<P>
<DL><DT>Notice:<DD>
If an image is restarted, which was saved while multiple screens active,
it will (currently) <STRONG>not</STRONG> automatically reconnect to all
displays and reopen those remote views.
<BR>
Your application has to do this manually, by making itself a dependent
of <CODE>ObjectMemory</CODE> to get notified of image save/restart.
It should close all remote views at image save time,
and recreate them at image restart time.
<P>
<DT>Notice2:<DD>
Although it looks pretty cool, to have multiple systemBrowsers open
on multiple displays, be reminded that the system has no provisions
to handle concurrent access to the class hierarchy.
<BR>
With the current version,
it is <b>not</b> recommended to use multiple display connections for
group development.
<P>
The multidisplay feature is still very usable, for special end-user applications.
However, these have to care manually for access to critical shared
resources (files for example).

<P>
<DT><A NAME="MULTITRANSCRIPT">Notice3:</A><DD>
If multiple launchers are open,
there are now multiple transcript windows, where informational output can
be sent to:
<UL>
<LI>the global (or main-) Transcript,
<BR>this is the transcript subview of the first opened Launcher.
<BR>Access to this is still possible from everywhere via the global variable
<CODE>Transcript</CODE>.

<P>
<LI>the remote (or slave-) Transcripts.
<BR>this is accessed by the message <CODE>Transcript current</CODE>, which
returns a different transcript view on each remote display.
</UL>

The same caution as with accessed to the <CODE>Display</CODE> global
should be taken when accessing the <CODE>Transcript</CODE> in those multidisplay
applications; urgent error messages should be sent to <CODE>Transcript</CODE>;
local information to <CODE>Transcript current</CODE>.


</DL>


<H2><A HREF="#I_TROUBLEGUIDE" NAME="TROUBLEGUIDE">Trouble Guide </A></H2>

This chapter tries to list common errors made in view programming.
It lists trouble symptoms and gives hints for fixing.
<BR>
The list is defintely not complete and will be extended over time
(as trouble reports arrive from users). Please help others, by
telling us about your problems (even if you found fixes) for inclusion
into this list.

<UL>

<LI>in my new view classes instance, all internal state is undefined
<BR>
<UL>
<LI>check for a redefined <CODE>#initialize</CODE> method which
does <STRONG>NOT</STRONG> do a <CODE>"super initialize"</CODE>.
</UL>
<P>
All redefined #initialize methods <b>must</b> also call for the superclasses'
initialization.
<BR>
The same is true for other redefined methods: #initStyle, #mapped,
#realized and #destroy - unless you intent to trap those and
suppress certain actions.
<BR>
If you do this (which is not recommended),
have a look at whats done in the superclasses method(s).
<P>


<LI>my view does not show up
<BR>
<UL>
<LI>check if the origin of the view is within the visible are of the
screen or (if its a subview) withing the superviews area.
(this happens if you accidently write <CODE>"view origin:100.0@50.0"</CODE>
instead of: <CODE>"view origin:100@50"</CODE>)
<LI>check for a funny extent (such as 0 or 1 pixel wide/high; this happens
if you accidently write <CODE>"view extent:1@1"</CODE> instead of:
<CODE>"view extent 1.0@1.0"</CODE>)
<LI>if its a topview: did you forget to send it some variant of
the <CODE>#open</CODE> message ?
<LI>check for a redefined initialization method, which
does <STRONG>NOT</STRONG> invoke the original method via a
<CODE>"super"</CODE> send.
<LI>maybe it is shown, but its viewbackground is the same as its
outer views, and it has no border or 3D level ?
<BR>
To see, give your view some funny viewBackground (such as red).
</UL>
<P>

<LI>I cannot destroy the view with the windowmanager
<BR>
<UL>
<LI>check for redefined <CODE>#destroy</CODE> or <CODE>#terminate</CODE>
methods which do not call the superclasses methods via a super send.
<LI>check if the view was opened with a <CODE>#realize</CODE> message
(instead of <CODE>#open</CODE>).
<BR>
The first creates the view without a windowGroup
process (i.e. events are sent directly to the view).
<LI>check if the views windowGroup process has died without cleaning
up correctly (however, this should not happen in normal situations)
</UL>
<P>
To get rid of the view, use the launcher's <VAR>destroy view</VAR>
function. This destroys the view physically - even if the windowGroups
process no longer handles any events.
<BR>
If this fails also, the system has lost the knowledge about the view,
but failed to shut it down towards the display hardware.
<BR>
If your system is still in a working condition, saving and restarting a
snapshot should help to get rid of them. If you cannot save/restart,
backup from the last saved working snapshot image, and check your changes
made since then.
<P>

<LI>my view vanishes after a while
<BR>
<UL>
<LI>this can only happen if you send <CODE>#realize</CODE> to the view.
<BR>
Since in this case, no extra windowGroup/process is created for the new view,
it is subject to garbage collection. Since there is noone refering the view,
the garbage collector will sooner or later free the view
(and the views finalization will destroy the corresponding X window).
<BR>
Try <CODE>"View new realize"</CODE> vs. <CODE>"View new open"</CODE>.
Wait for a while after evaluating the above expressions.
<BR>
As a general rule: never open views by sending <CODE>#realize</CODE>, unless
you know what you are doing.
</UL>


<P>
<LI>I draw into a view, but it does not show anything
<BR>
<UL>
<LI>check for a correct paint setting
<LI>check for the coordinates being within the visible area
<LI>check for a transformation, which transforms your drawing to outside
the visible area
<LI>check for a clipRectangle being set so that your drawing gets clipped away
<LI>check if the view ``thinks'' its visible (it has an instance variable
named <CODE>"shown"</CODE>) - many drawing methods simply do nothing, if
this variables states that the view is fully covered or unmapped.
<BR>
If the setting is wrong, check, how &amp; where it was set to a wrong value
<LI>see `drawing after #open' problem in next paragraph
</UL>
<P>

<LI>after #open, I draw into a view, but it does not show anything
or I get into the debugger
<p>
background info:
<br>
the #open message starts a new process, which handles the view
(and all of its subviews) events. Right after the open message, the new views
process (although created) had usually no chance to startup, initialize and
display the view. Therefore, a drawing or other access to the new view usually fails.
<BR>
I.e. the following is wrong:
<a type="example">
<PRE><CODE>
    |v|

    v := View new.
    v open.
    v displayString:'hello' at:10@10.
</CODE></PRE>
</a>
and may lead to some internal error, since drawing into the new view
is attemted <b>before</b> that view gets physically created and all of
its internal state and resources are setup correctly.
<P>

<UL>
<LI>
wait until the new view is visible before drawing into it:
<a type="example">
<PRE><CODE>
    |v|

    v := View new.
    v openAndWait.
    v displayString:'hello' at:10@10.
</CODE></PRE>
</a>
</UL>

The above problem is only encountered, with <VAR>doIt</VAR> evaluations;
typical applications open their views in some startup method, and access
the subviews while that applications process is in control.
<P>
Therefore, #openAndWait is never required in methods of <CODE>ApplicationModel</CODE>,
<CODE>StandardSystemView</CODE> or <CODE>View</CODE>, or of their subclasses
- <b>except</b> if views from <b>other</b> applications are accessed (which was
actually the case with the above <var>doIt</var> evaluations).
<P>







<P>
<LI>my view opens and works, but my other view(s) seem dead now
<BR>
<UL>
<LI>did you send <CODE>#realize</CODE> or <CODE>#openModal</CODE> instead of
<CODE>#open</CODE> ?
<LI>if redefined: do your views redefined <CODE>#initialize</CODE> and <CODE>#realize</CODE>
methods return (i.e. is there an endless loop) ?
</UL>


<P>
<LI>my view does not get any button events
<BR>
<UL>
<LI>did you disable these events (<CODE>#enableXXXEvent</CODE>) ?
<LI>did you redefine any of the <CODE>buttonPress:x:y:</CODE>
or <CODE>buttonRelease:x:y</CODE> with a bug ?
Set a breakpoint on it and see if its reached.
<LI>did you redefine any of the <CODE>#deviceButtonXXX</CODE> and
not send either <CODE>"super deviceButtonXXX"</CODE>
or <CODE>"self buttonXXX</CODE>" ?
</UL>

<P>
<LI>the colors change in the view - although I did not draw anything ?!?
<BR>
<UL>
<LI>looks like the garbage collector reclaimed your color, and another
color reused that color-lookup index.
<BR>
Did you forget to hold a reference to that color which prevents
the color from being reclaimed
by the garbage collector (read the chapter on Colors above) ?
</UL>

<P>
<LI>all of my views state is undefined (i.e. paint, viewBackground setting etc.)
<BR>
<UL>
<LI>check for a redefined <CODE>#initialize</CODE> method which
does <STRONG>NOT</STRONG> do a <CODE>"super initialize"</CODE>
</UL>

<P>
<LI>I placed a view into a ScrollableView, but the scrollbar does not
show the correct size/origin
<BR>
<UL>
<LI>did you define <CODE>#widthOfContents</CODE> and <CODE>#heightOfContents</CODE>
in your view ?
<LI>if so, do they return the correct values ?
</UL>


<P>
<LI>I placed a view into a ScrollableView, but the scrollbar does not
update its size when the contents changes size
<BR>
<UL>
<LI>did you forget to send <CODE>"self changed:#sizeOfContents"</CODE>
whenever appropriate (i.e. after changing the contents) ?
</UL>


<P>
<LI>I placed a view into a ScrollableView and allow scrolling via
some key action. The view does scroll, but the scrollbar does not update its origin.
<BR>
<UL>
<LI>did you forget to send <CODE>"self changed:#originOfContents"</CODE>
whenever appropriate?
</UL>




<P>
<LI>I ask a font about its ascent/descent/height or width, and get into
the debugger telling me something like <VAR>"querying device independent font ..."</VAR>
<BR>
<UL>
<LI>your font is a device indepenent font, which does not know about its
dimensions - you must associate that font to some specific device first.
<BR>
i.e. instead of:
<PRE><CODE>
    ...
    myFont := Font family:'courier' size:10.
    ...
    h := myFont height.
    ...
</CODE></PRE>
you must ask a device specific font, as in:
<PRE><CODE>
    ...
    myFont := Font family:'courier' size:10.
    ...
    myFont := myFont onDevice:device.
    h := myFont height.
    ...
</CODE></PRE>
(read the chapter on fonts above).
</UL>




</UL>

<P>
<DL><DT>Notes:<DD>
<A NAME="FN1" HREF="#BACK_FN1">(*) subview creation</A>
<BR>
If you read the sections on color, font and cursor handling,
you may notice that there is a slight difference: if a view is created without
a superview, its physical device is not known until the subview is placed
into a topview (because the topview could be on any graphics device).
<BR>
Therefore, certain queries for device specific (such as color-index, pixel
sizes of fonts etc.) are not possible until the subview is placed into its
topView.
<BR>
For most normal applications, this does not make a difference.
However, for example, if you want to fix a subviews dimension based upon
its font height <STRONG>before</STRONG> that view is placed into a topView,
the font size query will fail and report an error.
</DL>


<P>
<P>
<HR>
<P>
<IMG NOPRINT ALIGN=middle SRC="../../icons/stx.gif" alt="ST/X Logo">
Copyright ? 1995 Claus Gittinger Development &amp; Consulting, all rights reserved
<P>
<ADDRESS>
<tt>&lt;<a href="mailto:cg@exept.de">cg@exept.de</a>&gt;</tt>
</ADDRESS>

<HR>
Doc $Revision: 1.72 $ $Date: 2016-07-28 14:23:01 $

</BODY>
</HTML>
