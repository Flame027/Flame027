"Name: MinneStoreNotice: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALLTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OROTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OROTHER DEALINGS IN THE SOFTWARE.Comment: MinneStore Version 2.02 for Visual Smalltalk 3.1.2Copyright(c) 1997, 1998 by Jonathan Carlson----------------------------------------------------------------------MinneStore Version 2.02 for Visual Works 3.0 NCPorting Version 1.0Copyright(c) 1999 by Giovanni Giorgi For the license see 'notice' under the parcel access menuGiovanni can be reached via e-mail:	daitangio@tin.it	gg482344@silab.dsi.unimi.itTry it NOW:MSExample ExampleCodeMSExample testCodeSupplybyGG------------ Report of TestSuite:  -----------------------TestSuite runCompatibilityTest.  "Ok 99.9%"Only one line failed, but is ok for most uses.I change that line in method CompatibilityTesting>>testFileProtocolAlso look at FlavorCompatibility class>>createLockFile: aString ifExists: aBlock TestSuite runDiskObjectServiceTest. "OK"TestSuite runMinneStoreTest1 "OK"TestSuite runMinneStoreTest2. "OK"TestSuite runMinneStoreTest3. "OK"TestSuite runMinneStoreTest4. "OK"No important errors remains and it works at 95-100% ------ How To Update MinneStore:Example:Suppose you downloaded the file MinneStore.st of version 3.0 of MinneStore and you want to update it.It is very easy: 1) copy the MinneStore.st in the visualworks_home\image directory 2) Launch VW, then open parcel browse, select MinneStone parcel and click with the right mouse button on it.3) Select build/addFileIn and file in the MinneStore.st file.4) Save the MinneStore parcel.5) Plan a small journey to Milan (Italy), my city :) For additional information see the vw_porting.txtENJOY!!!Giovanni GiorgiHideSource: falseParcel: MinneStorePrerequisiteParcels: #(#('BOSS' '3.0 ncuo'))SaveSource: trueVersion: 2.03 GG Porting 1.2 Unix CompliantPre-load block: 	''A Parcel's pre-load action must be a block taking three arguments,	 the Parcel being loaded, the Parcel's environment (a PoolDictionary holding	 its defined classes) and the Parcel's undeclared variables (a PoolDictionary	 holding its undeclared variables).  Fill-out this template, and then accept.		 The pre-load action is run before any of the Parcel's code is installed in the	 system.  Consequently it cannot and should not mention any code in the	 Parcel.  But it does have access to that code through the block's arguments.		A pre-load action is only necessary in unusual circumstances, for example	when variables must be declared or initialized before installing a Parcel's code.''		[:aParcel :parcelEnvironment :parcelUndeclared|		''This code MUST NOT BE TOUCHED!!!		If you need to add some code, do it *after* the Transcript line!!!!!!!!		G.G.''		parcelUndeclared at: #MinneStorePropertyDB put: (WeakDictionary new:90).	]Post-load method: Object class>postLoadActionFor:Date: 8:31:46 am March 11, 1999"'From VisualWorksÂ® Non-Commercial, Release 3.0 of May 8, 1998 on March 11, 1999 at 8:31:46 am'!(Dialog confirm: 'You are filing-in a Parcel source file!!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']!Object subclass: #File	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore-GG-Patch'!File class	instanceVariableNames: ''!Object subclass: #FlavorCompatibility	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore-GG-Patch'!FlavorCompatibility class	instanceVariableNames: ''!Object subclass: #ExceptionCompatibility	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore-GG-Patch'!ExceptionCompatibility class	instanceVariableNames: ''!Error subclass: #DOLockStuckError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOLockStuckError class	instanceVariableNames: ''!Object subclass: #TestResult	instanceVariableNames: 'startTime stopTime testName failures errors successes '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!TestResult class	instanceVariableNames: ''!Error subclass: #MSDeletedLeafException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSDeletedLeafException class	instanceVariableNames: ''!Error subclass: #DOTestException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOTestException class	instanceVariableNames: ''!Object subclass: #MinneStore	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MinneStore class	instanceVariableNames: ''!MinneStore subclass: #MSText	instanceVariableNames: 'textString '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSText class	instanceVariableNames: ''!MinneStore subclass: #MSTrunk	instanceVariableNames: 'leftTrunkOrBranch rightTrunkOrBranch maximumValue parent unused1 unused2 unused3 '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSTrunk class	instanceVariableNames: ''!MinneStore subclass: #MSAspect	instanceVariableNames: 'name getter setter objectSetName unused1 unused2 '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSAspect class	instanceVariableNames: ''!MSAspect subclass: #MSMultiObjectAspect	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSMultiObjectAspect class	instanceVariableNames: ''!MinneStore subclass: #MSObjectSet	instanceVariableNames: 'name path indexes aspects myPersistence objectPersistence database cache persistenceCreationMethod hasChangedMethod afterStoringMethod beforeStoringMethod afterReadingMethod returnBlock andOr result recursion maximumLeavesPerBranch forceIndexUpdate unused2 unused3 unused4 '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSObjectSet class	instanceVariableNames: ''!MinneStore subclass: #MSLeaf	instanceVariableNames: 'value ids unused '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSLeaf class	instanceVariableNames: ''!Error subclass: #DOInvalidVersionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOInvalidVersionError class	instanceVariableNames: ''!MSAspect subclass: #MSSingleObjectAspect	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSSingleObjectAspect class	instanceVariableNames: ''!Object subclass: #MSReadProxy	instanceVariableNames: 'objectSet realObject '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSReadProxy class	instanceVariableNames: ''!MSReadProxy subclass: #MSSingleObjectReadProxy	instanceVariableNames: 'id '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSSingleObjectReadProxy class	instanceVariableNames: ''!MinneStore subclass: #MSStorageProxy	instanceVariableNames: 'objectSetName unused1 unused2 '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSStorageProxy class	instanceVariableNames: ''!MSStorageProxy subclass: #MSMultiObjectStorageProxy	instanceVariableNames: 'ids '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSMultiObjectStorageProxy class	instanceVariableNames: ''!MSStorageProxy subclass: #MSSingleObjectStorageProxy	instanceVariableNames: 'id '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSSingleObjectStorageProxy class	instanceVariableNames: ''!Error subclass: #MSBranchAboutToMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSBranchAboutToMorph class	instanceVariableNames: ''!MinneStore subclass: #MSExample	instanceVariableNames: 'name number description '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSExample class	instanceVariableNames: ''!MSExample subclass: #Employee	instanceVariableNames: 'notes manager '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!Employee class	instanceVariableNames: ''!Object subclass: #TestSuite	instanceVariableNames: 'name testCases '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!TestSuite class	instanceVariableNames: ''!MinneStore subclass: #MinneStoreDB	instanceVariableNames: 'objectSets path duringTransaction persistenceCreationMethod uniqueObjectSets unused1 unused2 unused3 unused4 '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MinneStoreDB class	instanceVariableNames: ''!Object subclass: #DiskObjectServices	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DiskObjectServices class	instanceVariableNames: ''!DiskObjectServices subclass: #DOUserPolicy	instanceVariableNames: 'changedFiles transactionReadCache transactionWriteCache rollbackBlocks '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOUserPolicy class	instanceVariableNames: ''!DiskObjectServices subclass: #DOService	instanceVariableNames: 'userPolicy pathName '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOService class	instanceVariableNames: ''!DOUserPolicy subclass: #DOSingleUserPolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOSingleUserPolicy class	instanceVariableNames: ''!DOService subclass: #DOSingleObjectService	instanceVariableNames: 'fileName '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOSingleObjectService class	instanceVariableNames: ''!DOService subclass: #DOMultiObjectService	instanceVariableNames: 'nextIdDOManager fileNamePattern objectsPerFilePolicy '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOMultiObjectService class	instanceVariableNames: ''!DiskObjectServices subclass: #DOWrapper	instanceVariableNames: 'originalObject object version id '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOWrapper class	instanceVariableNames: ''!DiskObjectServices subclass: #DOObjectsPerFilePolicy	instanceVariableNames: 'userPolicy manager '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOObjectsPerFilePolicy class	instanceVariableNames: ''!DiskObjectServices subclass: #DODeletedObject	instanceVariableNames: 'id version '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DODeletedObject class	instanceVariableNames: 'id version '!DOObjectsPerFilePolicy subclass: #DOMultiObjectsPerFilePolicy	instanceVariableNames: 'objectsPerFile '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOMultiObjectsPerFilePolicy class	instanceVariableNames: ''!MinneStore subclass: #MSHighValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSHighValue class	instanceVariableNames: ''!MSExample subclass: #IndirizzoPersona	instanceVariableNames: 'email note indirizzo '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore-GG-Patch'!IndirizzoPersona class	instanceVariableNames: ''!Error subclass: #FailedCheck	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!FailedCheck class	instanceVariableNames: ''!Object subclass: #TestCase	instanceVariableNames: 'selector '	classVariableNames: 'LogStream '	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!TestCase class	instanceVariableNames: ''!TestCase subclass: #MinneStoreTestCase3	instanceVariableNames: 'db '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!MinneStoreTestCase3 class	instanceVariableNames: ''!TestCase subclass: #MinneStoreTestCase1	instanceVariableNames: 'db '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!MinneStoreTestCase1 class	instanceVariableNames: ''!TestCase subclass: #DiskObjectServicesTestCase	instanceVariableNames: 'service '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!DiskObjectServicesTestCase class	instanceVariableNames: ''!DiskObjectServicesTestCase subclass: #MultiObjectTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!MultiObjectTestCase class	instanceVariableNames: ''!MinneStoreTestCase1 subclass: #MinneStoreTestCase4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!MinneStoreTestCase4 class	instanceVariableNames: ''!DiskObjectServicesTestCase subclass: #SingleObjectTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!SingleObjectTestCase class	instanceVariableNames: ''!TestCase subclass: #MinneStoreTestCase2	instanceVariableNames: 'db '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!MinneStoreTestCase2 class	instanceVariableNames: ''!TestCase subclass: #SetTestCase	instanceVariableNames: 'full empty '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!SetTestCase class	instanceVariableNames: ''!TestCase subclass: #CompatibilityTesting	instanceVariableNames: 'propertyDict '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!CompatibilityTesting class	instanceVariableNames: ''!DOUserPolicy subclass: #DOMultiUserPolicy	instanceVariableNames: 'lockedFiles '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOMultiUserPolicy class	instanceVariableNames: ''!MinneStore subclass: #MSTreeHolder	instanceVariableNames: 'name getter setter path domain owner indexTree indexTreePersistence maximumLeavesPerBranch lastLeafValueFound indexTreeChanges persistenceCreationMethod unused1 unused2 unused3 '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSTreeHolder class	instanceVariableNames: ''!MinneStore subclass: #MSNilValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSNilValue class	instanceVariableNames: ''!MSReadProxy subclass: #MSMultiObjectReadProxy	instanceVariableNames: 'ids '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSMultiObjectReadProxy class	instanceVariableNames: ''!DiskObjectServices subclass: #DOTestObject	instanceVariableNames: 'name age propertyDict '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStoreTestingFramework'!DOTestObject class	instanceVariableNames: ''!MinneStore subclass: #MSBranch	instanceVariableNames: 'leaves maximumValue leavesFileId parent maximumLeavesPerBranch leafPersistence unused1 unused2 unused3 '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSBranch class	instanceVariableNames: ''!DOObjectsPerFilePolicy subclass: #DOSingleObjectPerFilePolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!DOSingleObjectPerFilePolicy class	instanceVariableNames: ''!MinneStore subclass: #MSTestClasses	instanceVariableNames: 'name number description '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!MSTestClasses class	instanceVariableNames: ''!MSTestClasses subclass: #Assembly	instanceVariableNames: 'parts assemblies '	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!Assembly class	instanceVariableNames: ''!MSTestClasses subclass: #Part	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MinneStore'!Part class	instanceVariableNames: ''!File comment:'English:File is only a class for supporting MinnieStone.VisualWorks uses the Filename class and Streams, and there isn''t something of very much similar to File class concept in VisualSmalltalk.Italian:File e'' una mera classe di supporto per il MinnieStone, e spero che non faccia troppo conflitto!!!!'!FlavorCompatibility comment:'    This class generalizes messages for Dolphin Smalltalk.    PATCHED BY GIOVANNI GIORGI	to work with VW3.0 and 2.5.x'!IndirizzoPersona comment:'This class is used for examples and for building a small TelephonBook Application.Instance Variables:email	<String>	note	<String>	indirizzo	<String>	'!!File class methodsFor: 'services'!Copyright	"Copyright(c) 1997,1998  Jonathan A. Carlson"!createFileNamed: aString 	"Spero vada bene... Versione precedente, che funzionava solo con l' esempio, ma non con i test:	|fd|	fd:=aString asFilename.	fd newReadWriteStream close.	^aString asFilename."	| fd |	fd := aString asFilename.	"Lo apre  e lo chiude (=lo crea)"	fd newReadWriteStream close.	"Ora (ri)fornisce il desiderato Stream sperando bene...."	^fd newReadWriteStream .!exists: aString	^((aString asFilename) exists).!remove: aString 	^aString asFilename delete!remove: aString ifAbsent: aBlock	|f|	f:=aString asFilename.	f exists ifFalse: [^aBlock]	ifTrue: [ ^(f delete).].! !!FlavorCompatibility class methodsFor: 'Giorgi Giovanni Patch Mar99'!directoryDelimiterString	"Answer the character used for delimiting directories.	For DOS, Windows, and OS/2 this is a backward slash.	For Unix this is a forward slash.	GG Porting:	On VW  I use a special class, which should be able to carry a Filename across different filesystem. It works only in sometimes!!!!"^String with:(LogicalFilename separator).! !!FlavorCompatibility class methodsFor: 'Giorgi Giovanni Patch 2 Gen99'!aNewBinaryStreamableCollection: anInteger	"Answer something that can be streamed over with a ReadWriteStream."	"Original: ^String new: anInteger"	"Una ByteString non va bene, per cui cerco qualcosa d' altro:"	^ByteArray new: anInteger!aNewByteArray: size	"Answer something that can be streamed over with a ReadWriteStream.	This is usually a byte array, but is sometimes a string."	^String new: size!aNewWeakDictionary	"Answer a weak 'dictionary' where the values can be garbage collected.GG:The VW offers IdentityDictionary and I am trying to use it"	^IdentityDictionary new.	"^PseudoWeakValueIdentityDictionary cleanupThreshold: 100."!assert: aBoolean	"GG"	super assert: aBoolean.	"super ASSERT: aBoolean"!atPropertyNamed: aSymbol for: object1 put: object2	"Put the property and answer object1"	"Patched in object by GG"	object1		propertyAt: aSymbol		put: object2.	^object1!clearMemory		Object initPropertyEngine.!clone: anObject	"Make a thoroughly deep copy by filing anObject out to a stream and reading it back in"	"Edited by GG"			| stream |	stream := ReadWriteStream on: (ByteArray new: 100).	self dumpObject: anObject on: stream.	^self loadObjectFrom: stream.!Comment"       This class generalizes messages for Dolphin Smalltalk.    PATCHED BY GIOVANNI GIORGI	to work with VW3.0 and 2.5.x"!createDirectoryNamed: aString	"Answer true if successful.  False if not."	"Correzione di GG Error al posto di File ERROR e modifche rimuovendo Directory..."	[ (aString asFilename) makeDirectory]		on: Error		do: [:e | ^false].	^true.!createFileNamed: aString	"Answer an open, empty file whether it exists already or not.	Il problema e' che devo resituire uno stream in aalcuni casi, un file in altri!!!!!!	Questo funziona per il test di compatibilita' ma non funziona per createLockFile:ifExists: cosi' quest' ultimo metodo e' stato cambiato"	| file |	[file := File createFileNamed: aString]		on: Error "Era FileAlreadyExists"		do: [].		^file.	"era 	^File fromPath: aString	ma non cosi' dovrebbe essere ok"!createLockFile: aString ifExists: aBlock 	"Answer an empty and closed file if it doesn't exist, or the value of a block if it does."	"Fixed by GG"	| f |	f := aString asFilename.	f exists 		ifTrue: [^aBlock value]		ifFalse: 			[ 			 (f readWriteStream) close.			^f]!doesDirectoryExist: aString	"Answer a boolean."   "Correzione di GG"  " ^Directory exists: aString." ^(aString asFilename) exists.!doesFileExist: aString	^File exists: aString!dumpObject: anObject on: aStream    "Answer anObject"	"Write an object into a Stream	But What is returned??? by G.G. "	| bos |	aStream reset.	bos := BinaryObjectStorage onNew: aStream.	"Basic Step 2"[bos nextPut: anObject]				"Basic Step 3"	valueNowOrOnUnwindDo: [bos close]."It close the bos steam, I hope this is right GG"	^anObject		"Originale:"	"^ObjectFiler dump: anObject on: aStream"!dumpObject: anObject toNewFile: aString    "Answer anObject.  If the file already exists, replace its contents.  Make sure file gets closed."	|s|	s:=(aString asFilename) newReadWriteStream.	self dumpObject: anObject on: s.		"Originale: ^ObjectFiler dump: anObject newFile: aString"!exceptionDetails: exception	"Answer the objects that the exception was signaled with"    ^exception messageText!exceptionReceiver: exception	"Answer the receiver of a MessageNotUnderstood exception."	^exception message receiver!filedSizeOf: anObject	"Answer the number of bytes this object would take on disk.	This method not required."	| stream |	stream := WriteStream on: (String new: 100).	self dumpObject: anObject on: stream.	^stream size.!fileNameLike: aString    "Answer a string.  Windows95/NT allows long file names with spaces."	"Si prevede l' uso solo sotto Windows95/Unix"	^aString."	^(OperatingSystem isWindows95 or: [OperatingSystem isWindowsNT])		ifTrue: [aString]		ifFalse: [File fileName: aString extension: '']."!FlavorCompatibility    "This is a dummy method for file-out purposes."!indexOfCollection: collection2 in: collection1	"This will probably work in any flavor of Smalltalk."    | index1 index2 limit1 limit2 |    limit2 := collection2 size.    limit1 := collection1 size - limit2 + 1.    index1 := 1.    [index1 <= limit1]        whileTrue: [            (collection1 at: index1) = (collection2 at: 1)                ifTrue: [                    index2 := 2.                    [index2 <= limit2                        and: [ (collection1 at: index1 + index2 - 1) =                            ( collection2 at: index2 ) ] ]                        whileTrue: [index2 := index2 + 1].                    index2 > limit2                        ifTrue: [ ^index1] ].            index1 := index1 + 1].    ^0!isCollection: anObject	"Answer a boolean"	^anObject isCollection!isDictionary: anObject	"Answer a boolean"	"Modifcato da GG"	anObject isNil ifTrue: [^false] ifFalse:[	^ (anObject asFilename) isDictionary].!isStream: anObject	"Answer a boolean"	^anObject isStream!isString: anObject	"Answer a boolean"	^anObject isString!issue	"Used to just have a symbol #issue in the code, but VAST doesn't like it.	This method is needed for all 'flavors'"!isSymbol: anObject	"Answer a boolean"	^anObject isSymbol!loadObjectFrom: aStream 	"Answer the first object loaded from aStream."	"GG"	| bos array |	aStream reset.	bos := BinaryObjectStorage onOldNoScan: aStream.	[array := bos contents]		valueNowOrOnUnwindDo: [bos close].	"^ObjectFiler loadFrom: aStream"	^(array at:1)!loadObjectFromFileNamed: aString	"Answer the object loaded from file named aString.	___If the file doesn't exist__, answer nil.	Make sure file gets closed properly."	"GG"	|f|f:=(aString asFilename).f exists ifFalse:[^nil] ifTrue:[	^(self loadObjectFrom: (f readStream)).].	"^ObjectFiler loadFromPathName: aString"!lockNameForFile: aString	^aString, '.lock'!MinneStore	"Used to just have a symbol #MinneStore in dangling methods, but VAST doesn't like it.	Keep this method in order to be portable."!MinneStoreCompatibility	"Dummy method for file-out purposes"!needsWork	"Used to just have a symbol #needsWork in the code, but VAST doesn't like it."!nextWordOf: aReadStream	"Answer the next word in aReadStream, delimited by whitespace and punctuation.	Answer nil if there are no more words in the receiver."	| first |	aReadStream skipSeparatorsAndPunctuation ifFalse: [^nil].	first := aReadStream position.	aReadStream skipWhile: [:c | c isLetter or: [c isDigit]].	^aReadStream contents copyFrom: first+1 to: aReadStream position!propertyNamed: aSymbol for: anObject    "if property is absent answer nil."		^anObject propertyAt: aSymbol!propertyNamed: aSymbol for: anObject ifAbsent: aBlock    "if property is absent answer the value of aBlock"	^anObject propertyAt: aSymbol ifAbsent: aBlock!propertyNamed: aSymbol for: anObject ifAbsentPut: niladicBlock    "if property is absent, insert and return the value of niladicBlock"	| temp |	^anObject 		propertyAt: aSymbol 		ifAbsent:			[anObject propertyAt: aSymbol put: (temp := niladicBlock value).			temp].!removeDirectoryNamed: aString ifAbsent: aBlock 	"Remove a directory along with all its' files and 	subdirectories. 	This is a powerful command, use with care. 	Answer true if successful, false if not."	"Riscritto da Zero da GG e ricorsiva!!!! 	Il problema e' che le directory vanno prima svuotate !!!!!! 	self removeDirectoryNamed: 'C:\MSTest' ifAbsent: []. 	"	| dir |	dir := aString asFilename.	dir exists ifFalse: [^aBlock value]		ifTrue: 			[(dir filenamesMatching: '*')				do: [:each | each isDirectory						ifTrue: [self removeDirectoryNamed: each asString ifAbsent: aBlock]						ifFalse: [each delete]].			dir delete.			^True]!removeFileNamed: aString	File remove: aString!removeFileNamed: aString ifAbsent: aBlock	File remove: aString ifAbsent: aBlock!replaceAll: string1 in: aString with: string2	| i str |	(i := FlavorCompatibility indexOfCollection: string1 in: aString) > 0		ifFalse: [^self copy].	str :=		i < 2			ifTrue: ['']			ifFalse: [aString copyFrom: 1 to: i - 1].	^str, string2, (aString copyFrom: i + string1 size to: aString size)!testing	"Used to just have a symbol #testing in the code, but VAST doesn't like it.	Keep this method in order to be compatible"!triggerEvent: aSymbol for: anObject	^anObject triggerEvent: aSymbol!triggerEvent: aSymbol for: anObject with: anArgument	^anObject triggerEvent: aSymbol with: anArgument!triggerEvent: aSymbol for: anObject with: anArgument1 with: anArgument2	^anObject triggerEvent: aSymbol with: anArgument1 with: anArgument2!wait	"Wait for about 1 second.	This is pretty primitive because it ties up the machine, but it works for 	now since it is only used when a file is locked."	| endTime |	endTime := Time now asSeconds + 1.	[Time now asSeconds < endTime]		whileTrue: [].!waitFor: anInteger	"Wait for anInteger number of milliseconds.	This is hardly exact, but it will work for now."	| seconds |	seconds := (anInteger / 1000) asInteger.	seconds == 0 		ifTrue: [seconds := 1].	1 to: seconds do: [self wait].! !!ExceptionCompatibility class methodsFor: 'As yet unclassified'!anyError    "Answer the top level exception to watch for."    ^Error!DOInvalidVersionError	^Smalltalk at: #DOInvalidVersionError!DOLockStuckError    ^Smalltalk at: #DOLockStuckError!during: block1 ensure: block2    "Whatever happens in block 1, block 2 will be executed.    Note: If an exception happens in the during block, the method    using this will not continue."	^block1 ensure: block2!error: aString    "This method just for documentation purposes."	"Sosituito halt a error:"	^super halt: aString.!exceptionNamed: exceptionName    ^self perform: exceptionName!FailedCheck    "Used by the testing framework"    ^Smalltalk at: #FailedCheck!MessageNotUnderstood	^Smalltalk at: #MessageNotUnderstood!MinneStoreCompatibility	"Dummy method for file-out purposes"!MSBranchAboutToMorph	^Smalltalk at: #MSBranchAboutToMorph!MSDeletedLeafException	^Smalltalk at: #MSDeletedLeafException!on: exceptionName during: actionBlock do: handleBlock    "Watch for an exception in the action block.    If it happens, execute the handle block."	^actionBlock        on: (self exceptionNamed: exceptionName)        do: handleBlock!pass: anException    "Pass the exception so something above can handle it."	^anException pass!resume: anException    "Keep the code executing from where the exception was signaled."	^anException resume!return: anException    "Stop the execution of the code where the exception was signaled."	^anException return!signal: exceptionName    "Let it be known that an exception happened."	"^(self exceptionNamed: exceptionName) signal"	^(self exceptionNamed: exceptionName) raiseSignal!signal: exceptionName with: anObject    "Let it be known that an exception happened."	"VW pach: signal -> raiseSignal"	(self exceptionNamed: exceptionName) raiseSignal: anObject!testEnsure    "Test the ensure block code.    'Exception Handled' should be printed to the Transcript.    Then a walkback window should open.  When you close it,    'Ensure block executed' should show on the transcript."	"VW Ok, ma ora l' error: consente un proceed..."    ExceptionCompatibility        during:            [Transcript cr; show: 'ExceptionHandled.'.            ExceptionCompatibility error: 'Error occurred.']        ensure: [Transcript cr; show: 'Ensure block executed'].!testExample1	"self testExample1"    "An example where the exception is returned (processing is not resumed).    Before...During... should be printed on the Transcript."	"VW OK"    ExceptionCompatibility        on: #testException        during:            [Transcript show: 'Before...'.            ExceptionCompatibility signal: #testException.            Transcript show: 'After'.]        do: [: excp |            Transcript show: 'During...'.            ExceptionCompatibility return: excp ]!testExample2    "An example where the exception is resumed.    Before...During...After  should be printed on the Transcript."	"VW OK"    ExceptionCompatibility        on: #testException        during:            [Transcript show: 'Before...'.            ExceptionCompatibility signal: #testException.            Transcript show: 'After']        do: [: excp |            Transcript show: 'During...'.            ExceptionCompatibility resume: excp ]!testExample3    "An example where the exception is passed up to be handled by something else.    Before...During...  should be printed on the Transcript, then a walkback opened"	"VW OK"    ExceptionCompatibility        on: #testException        during:            [Transcript show: 'Before...'.            ExceptionCompatibility signal: #testException.            Transcript show: 'After']        do: [: excp |            Transcript show: 'During...'.            ExceptionCompatibility pass: excp ]!testException    "Answer a test exception to be watched for."    ^Smalltalk at: #DOTestException! !!DOLockStuckError class methodsFor: 'As yet unclassified'!MinneStoreCompatibility	"Dummy method for file-out purposes"! !!TestResult methodsFor: 'As yet unclassified'!error: aString in: aTestCase    "Record an error."    errors add: (Array with: aTestCase with: aString)!failure: aString in: aTestCase    "Record a failure."    failures add: (Array with: aTestCase with: aString)!initialize    "Initialize instance variables of test result."    failures := OrderedCollection new.    errors := OrderedCollection new.    successes := OrderedCollection new.!noErrors    ^errors isEmpty!noFailures    ^failures isEmpty!printError: error on: aStream    aStream        nextPutAll: 'Error- ';        nextPutAll: error printString.!printErrorsOn: aStream    errors do:        [:each |        aStream cr; space;space;space;space.        self printError: each on: aStream]!printFailure: failure on: aStream    aStream        nextPutAll: 'Failure- ';        nextPutAll: failure printString!printFailuresOn: aStream    failures do:        [:each |        aStream cr; space;space;space;space.        self printFailure: each on: aStream]!printHeaderOn: aStream    aStream        nextPutAll: 'Test results for ';        nextPutAll: testName;        cr; space;space;space;space;        nextPutAll: 'Start time: ';        nextPutAll: startTime printString;        cr; space;space;space;space;        nextPutAll: 'Stop time: ';        nextPutAll: stopTime printString!printOn: aStream    self printHeaderOn: aStream.    self printErrorsOn: aStream.    self printFailuresOn: aStream.    self printSuccessesOn: aStream.!printSuccess: failure on: aStream    aStream        nextPutAll: 'Success- ';        nextPutAll: failure printString!printSuccessesOn: aStream    successes do:        [:each |        aStream cr; space;space;space;space.        self printSuccess: each on: aStream]!setTest: aTest    "Set the associated test name and initialize the test result."    testName := aTest name.    self initialize!start    startTime := Date dateAndTimeNow!stop    stopTime := Date dateAndTimeNow!success: aTestCase    "Record a failure."    successes add: aTestCase.!successful    ^self noFailures & self noErrors! !!TestResult class methodsFor: 'As yet unclassified'!comment^'Instances are created by sending a TestSuite the message "run".A TestResult records the name of the TestSuite, the start and stop times,and all errors (uncaught signals) and failures (explicitly caught by should:and shouldnt: inside a TestCase).Copyright (c) 1994, First Class Software, Inc.  All rights reserved.'!test: aTest    "Instantiate a new test result associated with the passed    test suite."    ^self new setTest: aTest! !!MSDeletedLeafException class methodsFor: 'As yet unclassified'!MinneStoreCompatibility	"Dummy method for file-out purposes"! !!DOTestException methodsFor: 'As yet unclassified'!isResumable	^true! !!DOTestException class methodsFor: 'As yet unclassified'!MinneStoreCompatibility	"Dummy method for file-out purposes"! !!MinneStore methodsFor: 'As yet unclassified'!initialize	"Default to nothing.  Subclasses should override if needed."!isMSTreeHolder	^false! !!MinneStore class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!initializePath: aString	"Create path.  If it already exists, remove all files in it."	FlavorCompatibility removeDirectoryNamed: aString ifAbsent: [].	FlavorCompatibility createDirectoryNamed: aString.!new	"Answer a new initialized instance of myself."	^super new initialize.! !!MSText methodsFor: 'As yet unclassified'!asMSText	^self!isMSText	^true!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	textString printOn: aStream.	aStream nextPut: $).!textString: aString	textString := aString.!words	"Answer a collection of words found in this text"	| stream word coll |	coll := OrderedCollection new.	textString isNil ifTrue: [ ^coll ].	stream := ReadStream on: textString.	[ (word := FlavorCompatibility nextWordOf: stream) isNil ]		whileFalse: [ coll add: word ].	^coll	!wordsDo: aOneArgumentBlock	"For each word in my string execute aOneArgumentBlock"	| stream word |	textString isNil ifTrue: [ ^self ].	stream := ReadStream on: textString.	[ (word := FlavorCompatibility nextWordOf: stream) isNil ] 		whileFalse: [ aOneArgumentBlock value: word ].	! !!MSText class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!lowValue	"Answer the lowest possible value to be used in place of nil."	^String new!newOn: aString	"Public - use this instead of new"	^self new textString: aString.! !!MSTrunk methodsFor: 'As yet unclassified'!addLeafValue: anObject id: anInteger	"Add a leaf value/id to my trunks or branches."	leftTrunkOrBranch maximumValue >= anObject		ifTrue: [leftTrunkOrBranch addLeafValue: anObject id: anInteger]		ifFalse: [rightTrunkOrBranch addLeafValue: anObject id: anInteger]!addLeavesTo: aCollection	leftTrunkOrBranch addLeavesTo: aCollection.	rightTrunkOrBranch addLeavesTo: aCollection.	^aCollection!addValuesFor: idSet to: aCollection	"Add the values of all leaves that have an id in idSet to aCollection"	leftTrunkOrBranch addValuesFor: idSet to: aCollection.	rightTrunkOrBranch addValuesFor: idSet to: aCollection.	^aCollection.!addValuesTo: aCollection	"Add all leaf values to aCollection"	leftTrunkOrBranch addValuesTo: aCollection.	rightTrunkOrBranch addValuesTo: aCollection.	^aCollection.!allLeaves	"This is only used for testing right now."	^self addLeavesTo: (OrderedCollection new).!allValues	"Answer all of the values that I index."	^self addValuesTo: (OrderedCollection new)!allValuesFor: idSet	"Answer all of the values that I index for the object ids in the list."	^self addValuesFor: idSet to: OrderedCollection new.!beforeStoring	parent isMSTreeHolder		ifTrue: [self clearParent].  "logic moved to MSTreeHolder>>commitTransaction"	leftTrunkOrBranch beforeStoring.	rightTrunkOrBranch beforeStoring.!beginTransaction	"Only do this to the first branch because all branches share the same leaf DOManager."	self firstBranch beginTransaction.	!clearParent	self parent: nil.!commitTransaction	"Only do this to the first branch because all branches share the same leaf DOManager."	self firstBranch commitTransaction.	!firstBranch	"Answer the first branch in my tree."	^leftTrunkOrBranch firstBranch.!firstLeaf	"Answer the very first (lowest value) leaf that I hold."	^leftTrunkOrBranch isEmpty		ifTrue: [rightTrunkOrBranch firstLeaf]		ifFalse: [leftTrunkOrBranch firstLeaf].!isEmpty	"Answer true or false.  If both left and right trunk/branches are empty, answer true."	^leftTrunkOrBranch isEmpty and: [rightTrunkOrBranch isEmpty]!leafEqualTo: anObject	"Answer a leaf that is = an Object."	^leftTrunkOrBranch maximumValue >= anObject		ifTrue: [leftTrunkOrBranch leafEqualTo: anObject]		ifFalse: [rightTrunkOrBranch leafEqualTo: anObject]!leafGreaterThan: anObject	"Answer a leaf that is > an Object."	leftTrunkOrBranch maximumValue > anObject		ifTrue:			[leftTrunkOrBranch isEmpty  "may be empty from removing stuff."				ifFalse: [^leftTrunkOrBranch leafGreaterThan: anObject]].	^rightTrunkOrBranch leafGreaterThan: anObject.!leafGreaterThanOrEqualTo: anObject	"Answer a leaf that is >= an Object."	leftTrunkOrBranch maximumValue >= anObject		ifTrue: 			[leftTrunkOrBranch isEmpty   "may be empty from removing stuff."				ifFalse: [^leftTrunkOrBranch leafGreaterThanOrEqualTo: anObject]].	^rightTrunkOrBranch leafGreaterThanOrEqualTo: anObject.!left: leftBranchright: rightBranchparent: aTreeHolderOrTrunk	"Set my left and right branches."	leftTrunkOrBranch := (leftBranch parent: self).	rightTrunkOrBranch := (rightBranch parent: self).	parent := aTreeHolderOrTrunk.!maximumLeavesPerBranch: anInteger	"Set the maximum number of leaves allowed in a single branch before splitting.	Push this info down to the branches."	leftTrunkOrBranch maximumLeavesPerBranch: anInteger.	rightTrunkOrBranch maximumLeavesPerBranch: anInteger.!maximumValue	"Instance variable getter.  If nil, set to max value of my right trunk or branch."	maximumValue == nil		ifTrue: [maximumValue := rightTrunkOrBranch maximumValue].	^maximumValue.!newPath: aString	leftTrunkOrBranch newPath: aString.!parent: anMSTreeHolder	parent := anMSTreeHolder!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: 'maxValue: ';		print: maximumValue;		nextPut: $).!reapplyChanges	"Send this message up to my parent."	^parent reapplyChanges!removeLeafValue: anObject id: anInteger	"Remove this leaf value/id from my branches."	leftTrunkOrBranch maximumValue >= anObject		ifTrue: [leftTrunkOrBranch removeLeafValue: anObject id: anInteger]		ifFalse: [rightTrunkOrBranch removeLeafValue: anObject id: anInteger]!replace: aBranch with: aTrunk	"used when a branch is morphing into a trunk."	leftTrunkOrBranch == aBranch		ifTrue: [leftTrunkOrBranch := aTrunk].	rightTrunkOrBranch == aBranch		ifTrue: [rightTrunkOrBranch := aTrunk].!rollbackTransaction	"Only do this to the first branch because all branches share the same leaf DOManager."	self firstBranch rollbackTransaction.	!saveIndexTree	"Pass this message along to my parent Trunk or TreeHolder."	parent saveIndexTree!saveLeaves	"Ask (politely) my trunks or branches to save themselves."	leftTrunkOrBranch saveLeaves.	rightTrunkOrBranch saveLeaves.! !!MSTrunk class methodsFor: 'As yet unclassified'!Comment"	Trunks hold Trunks and Branches.	Branches hold Leaves."!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!newOn: anMSBranch parent: aTreeHolderOrTrunk	"Answer a new instance of myself with aBranch split between my right and left branches."	^self new		left: anMSBranch asLeftBranch		right: anMSBranch asRightBranch		parent: aTreeHolderOrTrunk! !!MSAspect methodsFor: 'As yet unclassified'!getter	^getter!getter: aSymbol	^getter := aSymbol!name	^name!name: aSymbol	^name := aSymbol!objectSetName	"Answer the name of the object set this aspect represents."	^objectSetName!objectSetName: aSymbol	"Setter"	objectSetName := aSymbol!setReadProxyFor: anObjectwith: anMSObjectSet	"This is called after reading an object.  anMSObjectSet is the object set for the aspect, not the object."	| proxy |	FlavorCompatibility assert: (objectSetName == anMSObjectSet name).  FlavorCompatibility testing.	proxy := anObject perform: getter.	proxy == nil		ifTrue: [^self].	proxy isMSStorageProxy		ifTrue:			"Change it to a read proxy."			[proxy := proxy asMSReadProxy.			proxy objectSet: anMSObjectSet.			anObject perform: setter with: proxy].	!setStorageProxyFor: anObject with: anMSObjectSet	"This is called before storing an object.  anMSObjectSet is the object set for the aspect, not the object."	| aspectValue proxy |	FlavorCompatibility assert: (objectSetName == anMSObjectSet name).  FlavorCompatibility testing.	aspectValue := anObject perform: getter.	aspectValue == nil		ifTrue: [^self].	aspectValue isMSStorageProxy		ifTrue: [^self].  "This should be true only if something went wrong."	aspectValue isMSReadProxy		ifTrue:			["aspectValue realObjectIsInstantiated     - Removed 98/2/22				ifTrue: [self storeAspect: aspectValue realObject using: anMSObjectSet]."			proxy := aspectValue asMSStorageProxy]		ifFalse:			["self storeAspect: aspectValue using: anMSObjectSet.   - Removed 98/2/22"			self validateAspect: aspectValue using: anMSObjectSet.  "Added 98-2-22"			proxy := self storageProxyClass newFor: aspectValue and: anMSObjectSet].	anObject perform: setter with: proxy.!setter	^setter!setter: aSymbol	^setter := aSymbol!storageProxyClass	^self implementedBySubclass! !!MSAspect class methodsFor: 'As yet unclassified'!Comments"	an Aspect contains meta-data about an ObjectSets relationship 	to another ObjectSet.  An aspect knows how to get an aspect value	from an object in an ObjectSet.		For example: 			ObjectSet named #Person has an aspect named #address which 			holds one or many objects that are stored in ObjectSet named #Address"!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!newName: nameSymbolgetter: getterSymbolsetter: setterSymbolobjectSetName: osnSymbol	"Answer a new instance of myself with everything filled in."	^self new		name: nameSymbol;		getter: getterSymbol;		setter: setterSymbol;		objectSetName: osnSymbol;		yourself.! !!MSMultiObjectAspect methodsFor: 'As yet unclassified'!storageProxyClass    ^MSMultiObjectStorageProxy!storeAspect: aspectValue using: anMSObjectSet	"Private - Store multiple objects."	FlavorCompatibility issue. "This method not used now because I decided aspects should not be stored with main object."	anMSObjectSet storeAll: aspectValue.!validateAspect: collection using: anMSObjectSet	"Private - Store multiple objects."	collection isEmpty		ifTrue: [^self]		ifFalse:			[collection do: 				[:each |				(anMSObjectSet dbIdFor: each) isNil					ifTrue: [self error: 'You have attempted to store an object whose aspect (', 							name printString, ') has a value that has not been stored'].				]			].! !!MSMultiObjectAspect class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!MSObjectSet methodsFor: 'As yet unclassified'!afterReading: anObject	"Private - If the afterReadingMethod selector is not nil, send it to anObject."		afterReadingMethod == nil		ifFalse: [anObject perform: afterReadingMethod].!afterReadingMethod: aSymbol	"Public - This method selector (aSymbol) is sent to an object 	after it has been read from the database."	afterReadingMethod := aSymbol!afterStoring: anObject	"Private - If the afterStoringMethod selector is not nil, send it to anObject."	afterStoringMethod == nil		ifFalse: [anObject perform: afterStoringMethod].!afterStoringMethod: aSymbol	"Public - This method selector (aSymbol) is sent to an object	after it has been stored to the database (but before the commit)."	afterStoringMethod := aSymbol!and    "Public - use this method between #where... methods"    andOr := #and!and: indexName between: anObject1 and: anObject2    "Public - Specifying a search criteria"    ^self and;        selectFor: indexName        selector: #between:and:        criteria: (Array with: anObject1 with: anObject2)!and: indexName eq: anObject    "Public - Specifying a search criteria where index value is equal to anObject."    ^self and;        selectFor: indexName        selector: #equals:        criteria: anObject!and: indexName ge: anObject    "Public - Specifying a search criteria where index value is greater than or equal to anObject."    ^self and;        selectFor: indexName        selector: #greaterThanOrEqualTo:        criteria: anObject!and: indexName gt: anObject    "Public - Specifying a search criteria where index value is greater than anObject."    ^self and;        selectFor: indexName        selector: #greaterThan:        criteria: anObject!and: indexName gte: anObject    "Public - Specifying a search criteria where index value is greater than or equal to anObject."    ^self and;        selectFor: indexName        selector: #greaterThanOrEqualTo:        criteria: anObject!and: indexName hasAllWords: aCollectionOfStrings    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self and;        selectFor: indexName        selector: #hasAllWords:        criteria: aCollectionOfStrings!and: indexName hasSomeWords: aCollectionOfStrings    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self and;        selectFor: indexName        selector: #hasSomeWords:        criteria: aCollectionOfStrings!and: indexName hasWord: aString    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self and;        selectFor: indexName        selector: #startsWith:        criteria: aString asLowercase!and: indexName includes: aString    "Public - Specifying a search criteria.  Use only when the key is a string."    ^self and;        selectFor: indexName        selector: #includes:        criteria: aString!and: indexName le: anObject    "Public - Specifying a search criteria where index value is less than or equal to anObject."    ^self and;        selectFor: indexName        selector: #lessThanOrEqualTo:        criteria: anObject!and: indexName lt: anObject    "Public - Specifying a search criteria where index value is less than anObject."    ^self and;        selectFor: indexName        selector: #lessThan:        criteria: anObject!and: indexName lte: anObject    "Public - Specifying a search criteria where index value is less than or equal to anObject."    ^self and;        selectFor: indexName        selector: #lessThanOrEqualTo:        criteria: anObject!and: indexName ne: anObject    "Public - Specifying a search criteria where index value is not equal to anObject."    ^self and;        selectFor: indexName        selector: #doesNotEqual:        criteria: anObject!aspect: aspectNamegetter: getterNamesetter: setterNameholdsMany: objectSetName	aspects		at: aspectName		put:			(MSMultiObjectAspect				newName: aspectName				getter: getterName				setter: setterName				objectSetName: objectSetName).!aspect: aspectNamegetter: getterNamesetter: setterNameholdsOne: objectSetName	aspects		at: aspectName		put:			(MSSingleObjectAspect				newName: aspectName				getter: getterName				setter: setterName				objectSetName: objectSetName).!aspect: aspectNameholdsMany: objectSetName	self		aspect: aspectName		getter: aspectName		setter: (aspectName, ':') asSymbol		holdsMany: objectSetName!aspect: aspectNameholdsOne: objectSetName	self		aspect: aspectName		getter: aspectName		setter: (aspectName, ':') asSymbol		holdsOne: objectSetName!aspectNamed: aSymbol	^self 		aspectNamed: aSymbol 		ifAbsent:[self error: 'This aspect has not been defined: ', aSymbol].!aspectNamed: aSymbol ifAbsent: aBlock	"Answer a MSAspect."	^aspects 		at: aSymbol		ifAbsent: aBlock.!aspects	^aspects!beforeStoring: anObject	"Private - If the beforeStoringMethod selector is not nil, send it to anObject."		beforeStoringMethod == nil		ifFalse: [anObject perform: beforeStoringMethod].!beforeStoringMethod: aSymbol	"Public - This method selector (aSymbol) is sent to an object before it has been stored."	beforeStoringMethod := aSymbol!beginTransaction	objectPersistence beginTransaction.	indexes do: [:each | each beginTransaction].	!cache	"Answer the instance identity cache for this ObjectSet."	cache == nil		ifTrue: [cache := FlavorCompatibility aNewWeakDictionary].	^cache!commitTransaction	objectPersistence commitTransaction.	indexes do: [:each | each commitTransaction].!database: aMinneStoreDB	"Private"	database := aMinneStoreDB!dbIdFor: anObject	"Answer the database id for anObject.  Answer nil if it has none."	^objectPersistence idFor: anObject.!delete: anObject	"Private - Store anObject to disk, and update the indexes.	If anObject is deemed unchanged, it won't be stored."	| id deletedObject |	(id := self dbIdFor: anObject) isNil		ifTrue: [self error: 'Trying to delete an object without a db id'.].	self validateObject: anObject.	self removeIndexValuesFor: anObject.	deletedObject := objectPersistence delete: anObject.	^self cache		at: (self dbIdFor: anObject)		put: deletedObject.!execute    "Public - Execute the query that started with get..."	| answer |	returnBlock == nil		ifTrue: [self error: '#getAll: or #getOne: must be used before #execute.'].	answer := returnBlock value.	returnBlock := nil.	^answer.!fileName	"Private - Answer the file name where I am stored.  Get it from my class method."	^self class fileName	!forAllDo: aSingleArgumentBlock    "Private - execute a block for each object I manage."	| lastId lastFileId thisFileId collection |	lastId := objectPersistence lastId.	lastFileId := 0.	1 to: lastId do:		[:i |		(thisFileId := objectPersistence fileNumberForId: i) > lastFileId			ifTrue: 				[lastFileId := thisFileId.				collection := objectPersistence readFileNumber: thisFileId.				collection do: 					[:each | 					each isDODeletedObject 						ifFalse: [aSingleArgumentBlock value: each]]].		].!forceIndexUpdate	"Private - Used when adding a new index to already stored objects."	forceIndexUpdate := true.	!getAll    "Private - set the returnBlock instance variable"	returnBlock := [self returnAll].!getCount    "Private - set the returnBlock instance variable"	returnBlock := [self returnCount].!getIds    "Private - set the returnBlock instance variable"	returnBlock := [self returnIds].!getOne    "Private - set the returnBlock instance variable"	returnBlock := [self returnOne].!getValuesOf: indexName	self indexNamed: indexName.  "Make sure it exists"	returnBlock := [self returnValuesOf: indexName].!hasChanged: anObject	"Private - Answer true or false.  True if anObject has changed since reading 	or hasn't been saved to the database yet.  	If no method selector was specified then assume true."	hasChangedMethod == nil		ifTrue: [^true].	(self dbIdFor: anObject) == nil		ifTrue: [^true]. "It has never been saved yet."	^anObject perform: hasChangedMethod.!hasChangedMethod: aSymbol	"Public - This method selector is used to find out if an object to be stored has changed or not.	If it hasn't changed, we won't store it."	hasChangedMethod := aSymbol!idFor: anObject	"Private - Answer the database id for anObject."self error: 'didnt know this was being used.'.	^objectPersistence idFor: anObject.!indexNamed: aSymbol	"Private - Answer the index with name of aSymbol"	^indexes at: aSymbol ifAbsent: [self error: 'There is no index named ' , aSymbol]!indexOn: indexSymbol domain: aClass	"Public - create an index named indexSymbol for domain of aClass.	Assume the getter is the same as the index name."	self 		newIndexNamed: indexSymbol		getter: indexSymbol		domain: aClass!indexOn: indexSymbol domain: aClass getter: getterMethodSymbol	"Public - create an index named indexSymbol for domain of aClass."	self 		newIndexNamed: indexSymbol		getter: getterMethodSymbol		domain: aClass!indexPathFor: aSymbol	"Answer  aString."	^path , (FlavorCompatibility fileNameLike: aSymbol)!initialize    "Private"	indexes := IdentityDictionary new.	aspects := IdentityDictionary new.	myPersistence := DOSingleObjectService perform: self persistenceCreationMethod with: path, self fileName.	myPersistence storeYourselfOn: path, self myPersistenceFileName.	objectPersistence := DOMultiObjectService perform: self persistenceCreationMethod with: path.	objectPersistence objectsPerFile: 5.	self maximumLeavesPerBranch: self class defaultMaximumLeavesPerBranch.!isMSObjectSet	"Answer true"	^true!maximumLeavesPerBranch	^maximumLeavesPerBranch!maximumLeavesPerBranch: anInteger	"Use this method before any indexes have been defined."	maximumLeavesPerBranch := anInteger.	indexes do: [:each | each maximumLeavesPerBranch: anInteger].	!myPersistence	"Answer an MSDiskObjectManager."	^myPersistence	!myPersistence: aDOManager	"Set the myPersistence instance variable to a disk object manager."	myPersistence := aDOManager	!myPersistenceFileName	"Private - Answer the file name for my persistence 'manager'.  Get it from my class method."	^self class myPersistenceFileName	!name	^name!name: aSymbol	name := aSymbol!newIndexNamed: indexNamegetter: getterMethodNamedomain: aClass	"Private - Create a new index with name of indexName.    Application -- Watch for the error MSInvalidDomainError.  This    occurs when the domain class does not respond to #lowValue"	| holder holderPathName |	(FlavorCompatibility isSymbol: indexName)		ifFalse: [self error: 'Index name must be a symbol'].	(FlavorCompatibility isSymbol: getterMethodName)		ifFalse: [self error: 'Getter method name must be a symbol'].	holderPathName := self indexPathFor: indexName.	indexes do: 		[:each |		each path = holderPathName			ifTrue:[self error: 'Your index name is too similar to ', each name]		].	holder := MSTreeHolder newOn: holderPathName owner: self.	holder name: indexName.	holder getter: getterMethodName.	holder domain: aClass.	indexes at: indexName put: holder.	self save.	objectPersistence lastId isNil 		ifFalse: [self updateIndexes].!newPath: aString	"Used when a database has been opened in a new directory."	self path: aString.	objectPersistence pathName: path.	indexes do: 		[:each |		each newPath: (self indexPathFor: each name)].	!objectsPerFile: anInteger	"Public - Set the number of objects to be stored in each file.	This method may only be used during db initialization."	objectPersistence objectsPerFile: anInteger.!or    "Public - use this method between #where... methods"    andOr := #or!or: indexName between: anObject1 and: anObject2    "Public - Specifying a search criteria"    ^self or;        selectFor: indexName        selector: #between:and:        criteria: (Array with: anObject1 with: anObject2)!or: indexName eq: anObject    "Public - Specifying a search criteria where index value is equal to anObject."    ^self or;        selectFor: indexName        selector: #equals:        criteria: anObject!or: indexName gt: anObject    "Public - Specifying a search criteria where index value is greater than anObject."    ^self or;        selectFor: indexName        selector: #greaterThan:        criteria: anObject!or: indexName gte: anObject    "Public - Specifying a search criteria where index value is greater than or equal to anObject."    ^self or;        selectFor: indexName        selector: #greaterThanOrEqualTo:        criteria: anObject!or: indexName hasAllWords: aCollectionOfStrings    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self or;        selectFor: indexName        selector: #hasAllWords:        criteria: aCollectionOfStrings!or: indexName hasSomeWords: aCollectionOfStrings    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self or;        selectFor: indexName        selector: #hasSomeWords:        criteria: aCollectionOfStrings!or: indexName hasWord: aString    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self or;        selectFor: indexName        selector: #startsWith:        criteria: aString asLowercase!or: indexName includes: aString    "Public - Specifying a search criteria.  Use only when the key is a string."    ^self or;        selectFor: indexName        selector: #includes:        criteria: aString!or: indexName le: anObject    "Public - Specifying a search criteria where index value is less than or equal to anObject."    ^self or;        selectFor: indexName        selector: #lessThanOrEqualTo:        criteria: anObject!or: indexName lt: anObject    "Public - Specifying a search criteria where index value is less than anObject."    ^self or;        selectFor: indexName        selector: #lessThan:        criteria: anObject!or: indexName lte: anObject    "Public - Specifying a search criteria where index value is less than or equal to anObject."    ^self or;        selectFor: indexName        selector: #lessThanOrEqualTo:        criteria: anObject!or: indexName ne: anObject    "Public - Specifying a search criteria where index value is not equal to anObject."    ^self or;        selectFor: indexName        selector: #doesNotEqual:        criteria: anObject!or: indexName startsWith: aString    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self or;        selectFor: indexName        selector: #startsWith:        criteria: aString!path	^path!path: aString	"Set the path instance variable."	path := (aString last = FlavorCompatibility directoryDelimiter)		ifTrue: [aString]		ifFalse: [aString , FlavorCompatibility directoryDelimiterString].	!persistenceCreationMethod	persistenceCreationMethod == nil		ifTrue: [persistenceCreationMethod := database persistenceCreationMethod].	^persistenceCreationMethod.!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: name;		nextPut: $).!privateStore: anObject	"Private - Store anObject to disk, and update the indexes.	If anObject is deemed unchanged, it won't be stored."	| id |	self validateObject: anObject.	(self hasChanged: anObject)		ifTrue: 			[self beforeStoring: anObject.			self updateIndexesFor: anObject.			self setStorageProxiesFor: anObject.			objectPersistence store: anObject.			self setReadProxiesFor: anObject.			self afterStoring: anObject.]		ifFalse: [self setStorageProxiesFor: anObject].	^self cache		at: (self dbIdFor: anObject)		put: anObject.!readAll	"Public - Answer all of the object in this object set.    Answer is nil if the object does not exist."	| all |	all := objectPersistence readAll.	^all 		collect:			[:each |			self cache				at: (self dbIdFor: each)				ifAbsentPut:					[self setReadProxiesFor: each.					self afterReading: each.										each].			]!readForId: anInteger	"Public - Answer the object in this object set with an id of anInteger.    Answer is nil if the object does not exist."	| object | 	^self cache		at: anInteger		ifAbsent:			[(object := objectPersistence readId: anInteger) == nil				ifTrue: "don't save nil in the cache"					[nil]				ifFalse:					[self setReadProxiesFor: object.					self afterReading: object.										cache at: anInteger put: object].			].!readForIds: aCollection	"Public - Answer the object in this object set with an id of anInteger.    Answer is nil if the object does not exist."	^aCollection collect: [:each | self readForId: each].!removeFromCache: anObject	"Public - Remove this object from the object identity cache."	^self cache 		removeKey: (self dbIdFor: anObject) 		ifAbsent: [nil]!removeIndexValuesFor: anObject	"Private - "	| key oldKey oldObject id |	oldObject := objectPersistence read: anObject.	id := self dbIdFor: anObject.	indexes do:		[:each |		ExceptionCompatibility		on: #MessageNotUnderstood		during: [oldKey := oldObject perform: each getter]		do: 	[ :exception |  "we are probably indexing with info from an aspect."			"exception message receiver isMSStorageProxy    -- VSE"			FlavorCompatibility issue. "The below code works in Dolphin only."			exception receiver isMSStorageProxy "-- Dolphin"				ifTrue: [self error: 'You have taken an index value from an aspect. ObjectSet: ', name, ' Index: ', each name]			].		each removeValue: oldKey id: id.		].!returnAll	"Private - Answer a collection of objects that match the criteria"	| answer |	ExceptionCompatibility		during:			[result isNil ifTrue: [answer := self readAll].			answer := result collect: [:each | self readForId: each]]		ensure:			[result := nil.			andOr := nil].	^answer.!returnCount	"Private - Answer the number of stored objects whose indexes	match the previously specified criteria."	^self returnIds size!returnIds    "Answer a collection of ids whose objects match the previously specified criteria."    | answer |    answer := result.    result := nil.    andOr := nil.    ^answer.!returnOne	"Private - Answer the first object that matches or nil."	| answer |	ExceptionCompatibility		during:			[result isNil ifTrue: [^nil].			result isEmpty ifTrue: [^result := nil].			answer := self readForId: result first]		ensure:			[result := nil.			andOr := nil].	^answer.!returnValuesOf: indexName	"Private - Answer a collection of index values for the objects that match the criteria"	| answer |	ExceptionCompatibility		during:			[answer := 				result isNil 				   ifTrue: [(self indexNamed: indexName) allValues]				   ifFalse: [(self indexNamed: indexName) allValuesFor: result].			]		ensure:			[result := nil.			andOr := nil].	^answer.!rollbackTransaction	objectPersistence rollbackTransaction.	indexes		do:			[:each |			each rollbackTransaction].	!save	"Private - Clean things up and Save myself to disk."	| temp1 temp2 temp3 temp4 |	indexes do: [:each | each beforeStoring].	temp1 := myPersistence.	temp2 := database.	temp3 := cache.	myPersistence := nil.	database := nil.	cache := nil.	ExceptionCompatibility		during: [temp1 store: self]		ensure:			[myPersistence := temp1.			database := temp2.			cache := temp3].!selectFor: indexName selector: aSelector criteria: anObject	"Private - Send aSelector with anObject to index named indexName.	Based on the andOr variable, union or intersect the results.	This method is used by #where:equals , #where:startsWith:, etc...	result variable will be nil the first time this is called."	| anOC |	(result notNil and: [andOr = nil])		ifTrue:			[result := nil.			andOr := nil.			self error: 'Use the #and or #or method between #where:.. methods'].	(result isCollectionOtherThanString and: [result isEmpty and: [andOr = #and]])		ifTrue:			[ "This is for efficiency.  No reason to go on."			andOr := nil.			^result].	ExceptionCompatibility	on: #anyError	during: [ " Start of the #on:do: block "		(anObject isCollectionOtherThanString and: [#(equals: hasAllWords: hasSomeWords:) doesNotInclude: aSelector])			ifTrue: [anOC := (self indexNamed: indexName) perform: aSelector withArguments: anObject]			ifFalse: [anOC := (self indexNamed: indexName) perform: aSelector with: anObject].		]	do:	[:excp |		result := nil.		andOr := nil.		ExceptionCompatibility pass: excp].	result isNil		ifTrue:			[andOr := nil.			^result := anOC].	(andOr = #and)		ifTrue:			[andOr := nil.			anOC isEmpty				ifTrue: [^result := OrderedCollection new].			^result := anOC intersectionOf: result.].	(andOr = #or)		ifTrue:			[andOr := nil.			anOC isEmpty				ifTrue: [^result].			^result := result uniqueUnionOf: anOC].FlavorCompatibility testing. self error: 'Oops, I didn''t think it could get this far'."	result := nil.	andOr := nil.	self error: 'Use the #and or #or method between #where:.. methods'."	!setReadProxiesFor: anObject	"Private - Replace anObjects related objects (aspects) with proxy objects.	If an aspect is 'dependent', then it should not be an aspect, but should be stored with the object."	| temp |	self aspects		do: [:eachAspect |			temp := database objectSetNamed: eachAspect objectSetName.			eachAspect setReadProxyFor: anObject with: temp].!setStorageProxiesFor: anObject	"Private - Replace anObjects related objects (aspects) with proxy objects.	If an aspect is 'dependent', then it should not be an aspect, but should be stored with the object.	In the process of setting the aspect proxies, the aspects get stored as well."	| temp |	self aspects		do: [:eachAspect |			temp := database objectSetNamed: eachAspect objectSetName. 			eachAspect setStorageProxyFor: anObject with: temp].!store: anObject	"Public - Check for recursive stores of the same object before storing it to disk"	recursion == nil		ifTrue:			[recursion := Set new.			recursion add: anObject.			self privateStore: anObject.			recursion := nil]		ifFalse:			[(recursion includes: anObject)				ifTrue: [^anObject].			recursion add: anObject.			self privateStore: anObject]!storeAll: aCollection	"Public - store a collection of object to disk."	aCollection		do: [:each | self store: each].	!storesClass: aClass	"Public - Definition protocol"	database objectSetsAt: aClass put: self.!storesClasses: aCollection	"Public - Definition protocol"	aCollection do: [ :each |		database objectSetsAt: each put: self].!unforceIndexUpdate	"Private - Used when adding a new index to already stored objects."	forceIndexUpdate := false.	!updateIndexes	"Private - used by #newIndexNamed:getter:domain: when an index has been 	added when there is already data in the database."	| tempHasChangedMethod |	database beginTransaction.	tempHasChangedMethod := hasChangedMethod.	ExceptionCompatibility		during:			[hasChangedMethod := nil.			self forceIndexUpdate.			self forAllDo: [:each | database store: each]]		ensure: 			[hasChangedMethod := tempHasChangedMethod.			self unforceIndexUpdate].	"If any untrapped error occurs during the storing, the changes will be automatically rolled back."	database commitTransaction.!updateIndexesFor: anObject	"Private - "	| key oldKey oldObject id |	(id := self dbIdFor: anObject) isNil		ifTrue: [id := objectPersistence assignIdTo: anObject]		ifFalse: [oldObject := objectPersistence read: anObject].	indexes do:		[:each |		key := anObject perform: each getter.		oldObject isNil			ifTrue: [each addValue: key id: id]			ifFalse:				[ExceptionCompatibility					on: #MessageNotUnderstood					during: [oldKey := oldObject perform: each getter]					do: 	[ :exception |  "we are probably indexing with info from an aspect."						(FlavorCompatibility exceptionReceiver: exception) isMSStorageProxy							ifTrue: [self error: 'You have taken an index value from an aspect. ObjectSet: ', name, ' Index: ', each name]						].				(oldKey ~= key or: [forceIndexUpdate == true]) ifTrue: 					[each removeValue: oldKey id: id.					each addValue: key id: id.].				].		].!validateObject: anObject    "Private - Validate anObject for the proper index protocol before storing it."    indexes do: [ :each |        (anObject respondsTo: each getter)            ifFalse: [ self error: 'Object does not respond to: ', each getter ] ].    !where: indexName between: anObject1 and: anObject2    "Public - Specifying a search criteria"    ^self        selectFor: indexName        selector: #between:and:        criteria: (Array with: anObject1 with: anObject2)!where: indexName eq: anObject    "Public - Specifying a search criteria. Equivalent to #where:equals:"    ^self        selectFor: indexName        selector: #equals:        criteria: anObject!where: indexName ge: anObject    "Public - Specifying a search criteria Equivalent to #where:isGreaterThanOrEqualTo:"    ^self        selectFor: indexName        selector: #greaterThanOrEqualTo:        criteria: anObject!where: indexName gt: anObject    "Public - Specifying a search criteria. Equivalent to #where:isGreaterThan:"    ^self        selectFor: indexName        selector: #greaterThan:        criteria: anObject!where: indexName gte: anObject    "Public - Specifying a search criteria Equivalent to #where:isGreaterThanOrEqualTo:"    ^self        selectFor: indexName        selector: #greaterThanOrEqualTo:        criteria: anObject!where: indexName hasAllWords: aCollectionOfStrings    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self        selectFor: indexName        selector: #hasAllWords:        criteria: aCollectionOfStrings!where: indexName hasSomeWords: aCollectionOfStrings    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self        selectFor: indexName        selector: #hasSomeWords:        criteria: aCollectionOfStrings!where: indexName hasWord: aString    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self        selectFor: indexName        selector: #startsWith:        criteria: aString asLowercase!where: indexName includes: aString    "Public - Specifying a search criteria.  Use only when the key is a string."    ^self        selectFor: indexName        selector: #includes:        criteria: aString!where: indexName le: anObject    "Public - Specifying a search criteria. Equivalent to #where:isLessThanOrEqualTo:"    ^self        selectFor: indexName        selector: #lessThanOrEqualTo:        criteria: anObject!where: indexName lt: anObject    "Public - Specifying a search criteria. Equivalent to #where:isLessThan:"    ^self        selectFor: indexName        selector: #lessThan:        criteria: anObject!where: indexName lte: anObject    "Public - Specifying a search criteria. Equivalent to #where:isLessThanOrEqualTo:"    ^self        selectFor: indexName        selector: #lessThanOrEqualTo:        criteria: anObject!where: indexName ne: anObject    "Public - Specifying a search criteria where index value is not equal to anObject."    ^self        selectFor: indexName        selector: #doesNotEqual:        criteria: anObject!where: indexName startsWith: aString    "Public - pecifying a search criteria.  Use only when the key is a string."    ^self        selectFor: indexName        selector: #startsWith:        criteria: aString! !!MSObjectSet class methodsFor: 'As yet unclassified'!Comments"This class represents the interface for storing/retrieving an Object into/froma set of like objects.  Like objects are distinguished by their class or theirclass group.  Like objects must have the same index interface (IOW, have the same index value getter methods)."!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!defaultMaximumLeavesPerBranch	"Used by the indexes unless overridden.  Must be an even number.	When branch file has this many leaves, it splits itself into two branches."	^20.!fileName    "Private - Answer a string with the file name where I am stored."    ^'MSObjSet.obj'!myPersistenceFileName	"Private - Answer the file name for my persistence 'manager' ."	^'DOPrstnc.obj'!new    "Do not use this method.  Use #newOn:  "    self error: 'Do not use #new.  Use #newOn: pathName'!newOn: aString	"Public - Instantiate myself and set path to aString."	self initializePath: aString.	^self basicNew		path: aString;		initialize;		yourself.!newOn: aString for: aMinneStoreDB	"Public - Instantiate myself and set path to aString."	self initializePath: aString.	^self basicNew		database: aMinneStoreDB;		path: aString;		initialize;		yourself.!XopenOn: pathName	"Public - Load an instance of myself from pathName.	This method to be deleted when I'm sure I won't need it."	| fullFileName dbm path tempPersistence |	path := (pathName last = FlavorCompatibility directoryDelimiter		ifTrue: [pathName]		ifFalse: [pathName , FlavorCompatibility directoryDelimiterString]).	tempPersistence := (DOService openOn: path , self myPersistenceFileName).	dbm := tempPersistence read.	FlavorCompatibility needsWork. self error: 'needs work below'.	dbm isNil		ifTrue: [self error"FileError signal"].	dbm myPersistence: tempPersistence.	^dbm.! !!MSLeaf methodsFor: 'As yet unclassified'!<= anMSLeaf	self class == anMSLeaf class		ifFalse: [^false].	^self value <= anMSLeaf value.!addId: anInteger	"Set my database id number that goes with the key."    	ids == nil ifTrue: [ 		ids := anInteger.		^self. ].	ids isInteger ifTrue: [		ids = anInteger			ifTrue: [ ^self ]			ifFalse: [				ids := OrderedCollection with: ids with: anInteger.				^self ] ].	(ids includes: anInteger) ifFalse: [		ids add: anInteger ].!ids	"Public - Answer a collection of ids that I hold."	ids == nil		ifTrue: [^Array new].	ids isInteger		ifTrue: [^Array with: ids].	^ids.!isEmpty	"Answer true or false.  Answer true if I hold no ids."	^ids == nil!printOn: aStream	"Public - Print a textual representation of  myself onto aStream."	super printOn: aStream.	aStream nextPut: $( .	value printOn: aStream.	aStream nextPut: $: .	"Print up to 3 of the database Ids associated with the index key."	1 to: self ids size do: [ :x |		x = 4	ifTrue: [ aStream nextPutAll: '...' ] .		x < 4 ifTrue: [ aStream print: (self ids at: x); nextPut: $  ] ] .	aStream nextPut: $)!removeId: anInteger	"Remove my database id number that goes with my value.	When ids gets empty, it is set back to nil."    	ids isNil ifTrue: [ ^self ].	ids isInteger ifTrue: [		ids = anInteger			ifTrue: [ 				^ids := nil ]			ifFalse: [ ^self ]. ].	(ids includes: anInteger) ifTrue: [		ids remove: anInteger.		ids isEmpty			ifTrue: [^ids := nil].		ids size = 1 			ifTrue: [ids := ids first] ] .!value	"Public - Answer my value instance variable."	^value!value: anObject id: anInteger	"Private - set the value and ids instance variables."	value := anObject.	ids := anInteger.! !!MSLeaf class methodsFor: 'As yet unclassified'!Comment"	Leaves are held by branches."!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!newValue: anObject id: anInteger	^self new		value: anObject 		id: anInteger				! !!DOInvalidVersionError class methodsFor: 'As yet unclassified'!MinneStore	"Dummy method for file-out purposes"!MinneStoreCompatibility	"Dummy method for file-out purposes"! !!MSSingleObjectAspect methodsFor: 'As yet unclassified'!storageProxyClass    ^MSSingleObjectStorageProxy!storeAspect: aspectValue using: anMSObjectSet	"Private - store a single object."	FlavorCompatibility issue. "This method not used now because I decided aspects should not be stored with main object."	anMSObjectSet store: aspectValue.!validateAspect: aspectValue using: anMSObjectSet	"Private - Store multiple objects."	(anMSObjectSet dbIdFor: aspectValue) isNil		ifTrue: [self error: 'You have attempted to store an object whose aspect (', 					name printString, ') has a value that has not been stored'].! !!MSSingleObjectAspect class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!MSReadProxy methodsFor: 'As yet unclassified'!basicRealObject	^realObject!class	^self realObject class!doesNotUnderstand: aMessage	"Read in and become my real object.  Reimplemented by my subclasses."	^self realObject		perform: aMessage selector		withArguments: aMessage arguments.!getRealObject	"This is common code used my subimplementers."	realObject == nil		ifTrue: [realObject := #error].!inspect	self realObject inspect.!isMSProxy	"Answer true."	^true!isMSReadProxy	"Answer true"	^true!objectSet	^objectSet!objectSet: anMSObjectSet	objectSet := anMSObjectSet!printString	^'a MSReadProxy{', self basicRealObject printString, '}'!realObject	realObject == #error		ifTrue: [^#ThereWasAProblemInstantiatingThisObject].	self realObjectIsInstantiated		ifFalse: [self getRealObject].	^realObject!realObjectIsInstantiated	^realObject ~~ nil!vmInterrupt: aSymbol        "Private - Process virtual machine interrupt.  This method is called        by the virtual machine.  It is entered with interrupts disabled.  The        interrupt handler should enable interrupts at the appropriate time."	"This method needed for Visual Smalltalk"    Process perform: aSymbol.    ^self!vmInterrupt: anInteger with: anObject	"See comment on Object instance method.	This method needed by Dolphin."	Processor vmInterrupt: anInteger with: anObject.	^self.	! !!MSReadProxy class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!MSSingleObjectReadProxy methodsFor: 'As yet unclassified'!asMSStorageProxy	^MSSingleObjectStorageProxy new		id: id;		objectSetName: objectSet name;		yourself.!getRealObject	realObject := objectSet readForId: id.	super getRealObject.!id	^id!id: anInteger	id := anInteger! !!MSSingleObjectReadProxy class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!MSStorageProxy methodsFor: 'As yet unclassified'!asMSReadProxy	"Answer an instance of MSReadProxy with my pertinent info in it.	Implemented by my subclasses."!isMSProxy	"Answer true."	^true!isMSStorageProxy	"Answer true."	^true!objectSetName	^objectSetName!objectSetName: aSymbol	objectSetName := aSymbol!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: objectSetName;		nextPutAll: ' - ';		yourself.! !!MSStorageProxy class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!MSMultiObjectStorageProxy methodsFor: 'As yet unclassified'!asMSReadProxy	"See superimplementor comments"	| proxy |	proxy := MSMultiObjectReadProxy new.	proxy ids: ids.	^proxy!ids	ids == nil		ifTrue: [ids := OrderedCollection new].	^ids!ids: aCollection	ids := aCollection.!printOn: aStream	super printOn: aStream.	aStream 		print: ids;		nextPut: $).! !!MSMultiObjectStorageProxy class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!newFor: aCollection and: anMSObjectSet	"Create a new instance of myself using aCollection and anMSObjectSet.	This method is being called right before saving an object to disk."	^self new		ids: (aCollection collect: [ :each | anMSObjectSet dbIdFor: each ]);		yourself.! !!MSSingleObjectStorageProxy methodsFor: 'As yet unclassified'!asMSReadProxy	"See superimplementor comments"	| proxy |	proxy := MSSingleObjectReadProxy new.	proxy id: id.	^proxy!id	^id!id: anInteger	id := anInteger!printOn: aStream	super printOn: aStream.	aStream 		print: id;		nextPut: $).! !!MSSingleObjectStorageProxy class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!newFor: anObject and: anMSObjectSet	"Create a new instance of myself using anObject and anMSObjectSet."	^self new		id: (anMSObjectSet dbIdFor: anObject);		yourself.	! !!MSBranchAboutToMorph methodsFor: 'As yet unclassified'!isResumable    ^true! !!MSBranchAboutToMorph class methodsFor: 'As yet unclassified'!MinneStoreCompatibility	"Dummy method for file-out purposes"! !!MSExample methodsFor: 'As yet unclassified'!description	^description!description: aString	description := aString!name	^name!name: aString	name := aString!number	^number!number: anInteger	number := anInteger!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $( ;		print: name ;		space;		print: number;		nextPut: $).! !!MSExample class methodsFor: 'instance creation'!name: aString number: anInteger	^self new		name: aString;		number: anInteger! !!MSExample class methodsFor: 'examples'!ExampleCode"This is the example found on the MinneStore web site.""Defining the database:"   | db path|   path:= 'C:\MinnieStoreDB-Example\'.   db := MinneStoreDB newOn: path.   db supportMultipleUsers.   (db addObjectSetNamed: #Parts)      storesClass: Part;      indexOn: #name domain: String;      indexOn: #number domain: Integer.   (db addObjectSetNamed: #Assemblies)      storesClass: Assembly;      indexOn: #name domain: String;      indexOn: #number domain: Integer;      aspect: #parts holdsMany: #Parts;      aspect: #assemblies holdsMany: #Assemblies.   db save."Creating and storing the objects:"   db := MinneStoreDB openOn: path.   db store: (Part name: 'spout' number: 101).   db store: (Part name: 'lever' number: 102).   db store: (Part name: 'o-ring' number: 103).   db store: (Part name: 'elbow' number: 104).   db store: (Part name: 'gasket' number: 105).   db store: (Part name: 'seat' number: 106).   db store: (Part name: 'nut' number: 107).   db store: (Part name: 'lift rod' number: 108).   db store: (Part name: 'strap' number: 109).   db store: (Part name: 'pivot rod' number: 110).   db store: (Part name: 'aerator' number: 111).   db store: (Part name: 'hub' number: 112).   db store:       ((Assembly name: 'Handle' number: 151)         addPart: ((db getOne: #Parts) where: #name eq: 'lever'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'o-ring'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'elbow'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'hub'; execute);         yourself).   db store:       ((Assembly name: 'Drain' number: 152)         addPart: ((db getOne: #Parts) where: #name eq: 'seat'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'gasket'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'o-ring'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'nut'; execute);         yourself).   db store:       ((Assembly name: 'Lift Rod' number: 153)         addPart: ((db getOne: #Parts) where: #name eq: 'lift rod'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'strap'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'nut'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'pivot rod'; execute);         yourself).  db store:       ((Assembly name: 'Faucet' number: 154)         addAssembly: ((db getOne: #Assemblies) where: #name eq: 'Drain'; execute);         addAssembly: ((db getOne: #Assemblies) where: #name eq: 'Lift Rod'; execute);         addAssembly: ((db getOne: #Assemblies) where: #name eq: 'Handle'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'spout'; execute);         addPart: ((db getOne: #Parts) where: #name eq: 'aerator'; execute);         yourself)."Retrieving from the database:"   db := MinneStoreDB openOn: path.  (db getAll: #Parts)      where: #number between: 105 and: 110;  "inclusive"      execute.   (db getAll: #Parts)      where: #name eq: #('spout'  'aerator');   "either spout or aerator"    or;  where: #number eq: 105;      execute.   (db getAll: #Assemblies)      where: #name startsWith: 'Fa';      execute.!testCodeSupplybyGG	"This is an example to test the porting of propertyAT:... methods	This is a crash-test and works well!!!!	MSExample testCodeSupplybyGG	GG"		| db path |	"Defining the database:"	path := 'C:\MinnieStoreRubrica\'.	FlavorCompatibility removeDirectoryNamed: path ifAbsent: [].	db := MinneStoreDB newOn: path.	db supportMultipleUsers.	(db addObjectSetNamed: #IndirizzoPersona)		storesClass: IndirizzoPersona;		indexOn: #name domain: String;		indexOn: #number domain: Integer;		indexOn: #email domain: String.	db save.	"Creating and storing the objects:"	db := MinneStoreDB openOn: path.	Transcript show:	'Storing Objects...';cr.	db		store: (IndirizzoPersona name: 'Alex Simmerman' number: 7190000);		store: ((IndirizzoPersona name: 'Frank Petzold' number: 0) 					email: 'turbine@usa.net');	 	store: ((IndirizzoPersona name: 'Mikey Mouse' number: 0) 					email: 'mouse@acme.it').		db save.	Object  initPropertyEngine.	Transcript show:	'REOPENING AND STORING ONE ENTRY AND DELETING ONE';cr.	db := MinneStoreDB openOn: path.	db 		store: ((IndirizzoPersona name: 'Steffan Kisley' number: 0) 					email: 'Kisley@iname.com').	((db getAll: #IndirizzoPersona)		where: #number			between: 0			and: 99999999;		execute) inspect.	"inclusive"	db delete:(	((db getAll: #IndirizzoPersona)		where: #email eq:#('mouse@acme.it');		execute) at: 1 ).	db save.	"Second clean up"	Object initPropertyEngine.	db := MinneStoreDB openOn: path.	Transcript show:	'Retrieving from the database:';cr.	((db getAll: #IndirizzoPersona)		where: #number			between: 0			and: 99999999;		execute) inspect.	"inclusive"	((db getAll: #IndirizzoPersona)		where: #name eq: #( 'Frank Petzold');		or;		where: #number eq: 7190000;		execute) inspect.		((db getAll: #IndirizzoPersona)		where: #email startsWith: 'Ki';		execute) inspect!unixTestCodeSupplybyGG	"This is an example to test the porting of propertyAT:... methods	This example do not work so well under Linux, but I am working on it!!!!	MSExample unixTestCodeSupplybyGG	GG"		| db path |	"Defining the database:"	path := '/tmp/MinnieStoreRubrica'.	FlavorCompatibility removeDirectoryNamed: path ifAbsent: [].	db := MinneStoreDB newOn: path.	db supportMultipleUsers.	(db addObjectSetNamed: #IndirizzoPersona)		storesClass: IndirizzoPersona;		indexOn: #name domain: String;		indexOn: #number domain: Integer;		indexOn: #email domain: String.	db save.	"Creating and storing the objects:"	db := MinneStoreDB openOn: path.	Transcript show:	'Storing Objects...';cr.	db		store: (IndirizzoPersona name: 'Alex Simmerman' number: 7190000);		store: ((IndirizzoPersona name: 'Frank Petzold' number: 0) 					email: 'turbine@usa.net');	 	store: ((IndirizzoPersona name: 'Mikey Mouse' number: 0) 					email: 'mouse@acme.it').		db save.	Object  initPropertyEngine.	Transcript show:	'REOPENING AND STORING ONE ENTRY AND DELETING ONE';cr.	db := MinneStoreDB openOn: path.	db 		store: ((IndirizzoPersona name: 'Steffan Kisley' number: 0) 					email: 'Kisley@iname.com').	((db getAll: #IndirizzoPersona)		where: #number			between: 0			and: 99999999;		execute) inspect.	"inclusive"	db delete:(	((db getAll: #IndirizzoPersona)		where: #email eq:#('mouse@acme.it');		execute) at: 1 ).	db save.	"Second clean up"	Object initPropertyEngine.	db := MinneStoreDB openOn: path.	Transcript show:	'Retrieving from the database:';cr.	((db getAll: #IndirizzoPersona)		where: #number			between: 0			and: 99999999;		execute) inspect.	"inclusive"	((db getAll: #IndirizzoPersona)		where: #name eq: #( 'Frank Petzold');		or;		where: #number eq: 7190000;		execute) inspect.		((db getAll: #IndirizzoPersona)		where: #email startsWith: 'Ki';		execute) inspect! !!Employee methodsFor: 'As yet unclassified'!manager	^manager!manager: anEmployee	manager := anEmployee!notes	^notes!notes: aString	notes := aString! !!TestSuite methodsFor: 'As yet unclassified'!addTestCase: aTestCase    testCases add: aTestCase!addTestCases: aCollection    aCollection do: [:each | self addTestCase: each]!defaultTestResult    "Answer an instance of the default test result class    initialized on this test suite."    ^self defaultTestResultClass test: self!defaultTestResultClass    ^TestResult!initialize    testCases := OrderedCollection new!name    ^name!run    "Run all the test cases or suites contained in this test suite    and answer a test result."    | result |    result := self defaultTestResult.    result start.    self run: result.    result stop.    ^result!run: aTestResult    testCases do: [ :each | each run: aTestResult ]!setName: aString    "Name this test suite and initialize it."    name := aString.    self initialize! !!TestSuite class methodsFor: 'As yet unclassified'!comment^'Instances aggregate TestCases, and other TestSuites.  Sending aTestSuite "run" returns a TestResult.TestSuites are designed to be easily BOSS-able or ObjectFiler-able, as are theother classes in the framework.Copyright (c) 1994, First Class Software, Inc.  All rights reserved.'!named: aString    "Instantiate a new test suite with the passed name."    ^self new setName: aString!new    ^super new initialize!runCompatibilityTest    | test |     test := self named: 'Compatibility Test'.    test addTestCases: CompatibilityTesting all.    ^test run!runDiskObjectServiceTest    | test |     test := self named: 'Disk Object Services'.    test addTestCases: DiskObjectServicesTestCase all.    ^test run!runMinneStoreTest1    | test |     test := self named: 'MinneStore Test 1'.    test addTestCases: MinneStoreTestCase1 all.    ^test run!runMinneStoreTest2    | test |     test := self named: 'MinneStore Test2'.    test addTestCases: MinneStoreTestCase2 all.    ^test run!runMinneStoreTest3    | test |     test := self named: 'MinneStore Test3'.    test addTestCases: MinneStoreTestCase3 all.    ^test run!runMinneStoreTest4    | test |     test := self named: 'MinneStore Test 4'.    test addTestCases: MinneStoreTestCase4 all.    ^test run!runSetExample    ^self setExample run!setExample    "self setExample"    | test |     test := self named: 'Set Example'.    test addTestCases: SetTestCase testCases.    ^test! !!MinneStoreDB methodsFor: 'As yet unclassified'!addObjectSetNamed: aSymbol	"Public"	| objectSet pathName |	uniqueObjectSets isNil		ifTrue: [uniqueObjectSets := OrderedCollection new].	pathName := self objectSetPathFor: aSymbol.	uniqueObjectSets do: [:each |		each path = pathName			ifTrue:[self error: 'This object set name is too close to ', each name]].	objectSet := MSObjectSet newOn: pathName for: self.	objectSet name: aSymbol.	uniqueObjectSets add: objectSet.	^objectSets		at: aSymbol		put: objectSet."****** Not using the save-immediately feature right now.	self save.	^self objectSetNamed: aSymbol.*******"!beginTransaction	"Public - Begin this transaction."	self objectSetsDo: [:each | each beginTransaction].	duringTransaction := true.	!commitTransaction	"Public - Begin this transaction."	self objectSetsDo: [:each | each commitTransaction].	duringTransaction := false.	!delete: anObject	"Public - delete one object.  This is dangerous since other objects may reference it."	| objectSet result |	objectSet := (self objectSetsAt: anObject class).	^duringTransaction		ifTrue: [objectSet delete: anObject]		ifFalse:			[self beginTransaction.			ExceptionCompatibility				on: #anyError				during: [result := objectSet delete: anObject]				do:	[:exception |					self rollbackTransaction.					ExceptionCompatibility pass: exception].			self commitTransaction.			result.].!fileName	^self class fileName.!forAll: anObjectSetName do: aSingleArgumentBlock	"Public - pass each object in the objectSet to aSingleArgumentBlock.	For efficiency this does NOT read all objects before beginning the looping."	^(self objectSetNamed: anObjectSetName) forAllDo: aSingleArgumentBlock!getAll: anObjectSetName	"Public - Start an object read query."	^(self objectSetNamed: anObjectSetName) getAll!getCount: anObjectSetName	"Public - Start an object read query."	^(self objectSetNamed: anObjectSetName) getCount!getOne: anObjectSetName	"Public - Start an object read query."	^(self objectSetNamed: anObjectSetName) getOne!getValuesOf: indexName from: objectSetName	"Public - Start an index value read query."		^(self objectSetNamed: objectSetName) getValuesOf: indexName!idFor: anObject	"Public - Answer the database id for anObject or nil if it has none."	^(self objectSetFor: anObject class) dbIdFor: anObject!initialize	duringTransaction := false.	objectSets := IdentityDictionary new.!newPath: aString	"Private - Used when opening a MinneStoreDB after it has been moved.	Assume the objectSets have not yet been read from disk.	each value of the objectSets dictionary should still be a DOService."		| osPath |	self path: aString.	objectSets associations do: 		[ :each |		(FlavorCompatibility isSymbol: each key) 			ifTrue: 				[each value pathName: (osPath := self objectSetPathFor: each key).				(self objectSetNamed: each key) newPath: osPath.].		].	self save.!objectSetFor: aClass	"Public - Answer the object set that stores and retrieves aClass."	^self objectSetsAt: aClass!objectSetNamed: aSymbol	"Public - Answer the object set that is named aSymbol."	^self objectSetsAt: aSymbol!objectSetPathFor: aSymbol	"Public - Answer a string."	^path , (FlavorCompatibility fileNameLike: aSymbol), FlavorCompatibility directoryDelimiterString.!objectSetsAt: aClassOrSymbol	"Private - If the object at aClassOrSymbol is a disk object manager then	use it to read the object set and replace it with the object set."	| temp objectSet |	temp := (objectSets 			at: aClassOrSymbol 			ifAbsent: [self error: 'This objectSet has not been defined: ' , aClassOrSymbol printString]).	^temp isDOService		ifTrue: [self readObjectSetUsing: temp]		ifFalse: [temp]  "Then it is an MSObjectSet"!objectSetsAt: aClassOrSymbol put: anMSObjectSet	"Private"	^objectSets 		at: aClassOrSymbol		put: anMSObjectSet	!objectSetsDo: aBlock	"Public - Begin this transaction."	| objSet |	uniqueObjectSets copy do: 		[:each | 		objSet := each isDOService			ifTrue: [self readObjectSetUsing: each]			ifFalse: [each].		aBlock value: objSet].!path	^path!path: aString	"Private - Set the path instance variable."	path := (aString last = FlavorCompatibility directoryDelimiter)		ifTrue: [aString]		ifFalse: [aString , FlavorCompatibility directoryDelimiterString].	!persistence	"Private - Answer an instance of DOSingleObjectService."	^DOSingleObjectService		perform: self persistenceCreationMethod		with: path, self fileName!persistenceCreationMethod	"Private - Answer the method used to create persistence managers."	persistenceCreationMethod == nil		ifTrue: [self supportSingleUser].	^persistenceCreationMethod.!readObjectSetUsing: aDOService	"Answer an MSObjectSet after reading it from the database.	I use become here because aDOService is in the ObjectSets dictionary	several times."	| objectSet |	objectSet := aDOService read.	objectSet database: self.	objectSet myPersistence: aDOService.	self switchInObjectSets: aDOService with: objectSet.	^objectSet.!removeFromCache: anObject	"Public - Remove this object from the object identity cache."	^(self objectSetsAt: anObject class)		removeFromCache: anObject.!rollbackTransaction	"Public - Begin this transaction."	uniqueObjectSets		do: [:each | each rollbackTransaction].	duringTransaction := false.	!save	"Private - Save my changes to disk.  This method should be used only after the initial	database definition or after any other definition changes have been made."	FlavorCompatibility needsWork. "needs to have a unit of work here."	uniqueObjectSets do: 		[:each |		each isDOService ifFalse: 			[each save.			self switchInObjectSets: each with: each myPersistence.			"each become: each myPersistence."].		].	self persistence store: self.!store: anObject	"Public - Store one object."	| objectSet |	objectSet := (self objectSetsAt: anObject class).	duringTransaction		ifTrue: [objectSet store: anObject]		ifFalse:			[self beginTransaction.			ExceptionCompatibility				on: #anyError				during: [objectSet store: anObject]				do:	[:exception |					self rollbackTransaction.					ExceptionCompatibility pass: exception].			self commitTransaction].	!storeAll: aCollection	"Public - Store a collection of objects.  They need not be the same class."	| commitAfterSaving |	duringTransaction		ifTrue:			[commitAfterSaving := false]		ifFalse:			[commitAfterSaving := true.			self beginTransaction].	aCollection		do: [:each | self store: each].	commitAfterSaving		ifTrue: [self commitTransaction].	!supportMultipleUsers	"Public - "	persistenceCreationMethod := #newMultiUserOn:!supportSingleUser	"Public - "	persistenceCreationMethod := #newSingleUserOn:!switchInObjectSets: anObject with: anotherObject	"This method replaces the #become: I used to use."	objectSets associationsDo: 		[:each | 		each value == anObject			ifTrue: [objectSets at: each key put: anotherObject]		].	uniqueObjectSets copy do: 		[:each |		each == anObject ifTrue: 			[uniqueObjectSets remove: anObject.			uniqueObjectSets add: anotherObject]		].! !!MinneStoreDB class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!fileName	^'MSdb.obj'!newOn: aString	"Public - Instantiate myself and set path to aString.	Beware, using this will erase whatever exists on path named aString"	(FlavorCompatibility doesDirectoryExist: aString)		ifTrue: [self error: 'This directory already exists: ', aString, '  Cannot create a new one here'].	self initializePath: aString.	^self basicNew		path: aString;		initialize;		yourself.!openOn: pathName	"Public - Load an instance of myself from pathName."	| path service minneStoreDB |	path := (pathName last = FlavorCompatibility directoryDelimiter		ifTrue: [pathName]		ifFalse: [pathName , FlavorCompatibility directoryDelimiterString]).	minneStoreDB := DOSingleObjectService read: path, self fileName.	minneStoreDB isNil ifTrue: [self error: 'This is not a valid MinneStore path: ', pathName].	minneStoreDB path asLowercase = path asLowercase		ifFalse: [minneStoreDB newPath: path].	^minneStoreDB	!Version	"This version adds the functionality of MinneStoreDB>>getValuesOf: indexName from: objectSetName"		^'2.03' ! !!DiskObjectServices methodsFor: 'As yet unclassified'!error: aString	^ExceptionCompatibility error: aString!idFor: anObject	"Answer the internal database id for this object or nil if it has none."	^FlavorCompatibility		propertyNamed: #DOId		for: anObject.!initialize	"May be reimplemented by my subclasses"!signalInvalidVersionError: anObject	ExceptionCompatibility signal: #DOInvalidVersionError with: anObject!signalLockStuckError	ExceptionCompatibility signal: #DOLockStuckError!versionFor: anObject	"Answer the internal database id for this object or nil if it has none."	^FlavorCompatibility		propertyNamed: #DOVersion		for: anObject.! !!DiskObjectServices class methodsFor: 'As yet unclassified'!Comments"    The classes DOMultiObjectService and DOSingleObjectService are the interface into the    DiskObjectServices.  In order to update a disk object, it must be read first.    Here are the transaction rules for the Disk Object System.        1) All reads during a transaction are executed as if they were readForUpdate.        2) The objects read during a transaction are cached.  Because they have            been locked, the system does not have to go back to disk during the transaction.            This is an efficiency feature.        3) Transactions are meant to be short.  A transaction that includes waiting for user            input will lock other users out of those objects.        4) For most uses, an explicit readForUpdate will not be necessary.  Optimistic            locking is the default.  When a conflict occurs, DOInvalidVersionError will be            signaled.    This is how data integrity is maintained in this multi-user environment.        1) When an object is stored for the first time, it is given a DiskObject Id and a            version number.        2) The DiskObject Id ensures it's identity.  The version number ensures that            the object has not been changed since it was read.        3) If an object is changed and a copy is made, make sure the original object            is stored back to disk instead of the copy.  When the copy is stored to disk            it will be stored as a brand new object."!DiskObjectServices    "This is a dummy method used by the source code filer to    denote a Disk Object Service class and it's subclasses."!ExceptionsToExpect"You can expect the following exceptions to be signaled when...DOObjectIsDeletedError        When trying to read a deleted object.DOInvalidVersionError        When trying to update an object that has been updated since        it was last read.DOLockStuckError        When the system can't read an object because it has been locked        for a period of time."!new    "Answer a new, initialized instance of myself."    ^self basicNew initialize!Overview"The Disk Object System is intended to provide single-user or multi-user access to a binary object filing system.  Also provided is the capability tostore multiple objects, either in their own files, or with n objects ineach file.The MinneStore System uses the Disk Object System to storeobjects and set up indexes for each kind of object.This code is copyright(c) 1997, 1998 by Jonathan A. Carlson."! !!DOUserPolicy methodsFor: 'As yet unclassified'!addRollbackBlock: aBlock	rollbackBlocks isNil		ifTrue: [rollbackBlocks := OrderedCollection new].	rollbackBlocks add: aBlock.!beginTransaction	"Set the transactionCache instance variables to a new Dictionary.	All read and store commands will be saved in the cache until commit time.	If multi-user, all read files will be locked until commit or rollback."	(FlavorCompatibility isDictionary: transactionWriteCache)		ifTrue:			[transactionWriteCache isEmpty				ifTrue: [^self]				ifFalse: [self error: 'Transaction must be committed or rolled back before beginning a new one.']].	transactionWriteCache := Dictionary new.	transactionReadCache := Dictionary new.	changedFiles := Set new.!commitTransaction	"Save all changed files to disk and wipe out the transactionCaches."		"If I want to get fancy I could backup each file before writing them, and then 	delete the backup after all are saved okay (I'm afraid this would be too inefficient).	For now we'll just live with the possibility of a power failure during the commit."	self duringTransaction		ifFalse: [self error: 'You must begin a transaction before committing it.'].	transactionWriteCache		associationsDo:			[:each | FlavorCompatibility dumpObject: each value toNewFile: each key].	transactionWriteCache := nil.	transactionReadCache := nil.	changedFiles := nil.	rollbackBlocks := OrderedCollection new.!duringTransaction	"Answer true or false."	^transactionWriteCache ~= nil.!initialize	rollbackBlocks := OrderedCollection new.!isMultiUser	^false!isSingleUser	^false!readFileNamed: aString	"Check the write cache.  If nothing found, check the read cache.  	If nothing found there either, read the file named aString."	^self duringTransaction		ifTrue:			[self				transactionWriteCacheAt: aString 				ifAbsent:					[self						transactionReadCacheAt: aString						ifAbsentPutValueOf: [FlavorCompatibility loadObjectFromFileNamed: aString].					].			]		ifFalse:			[FlavorCompatibility loadObjectFromFileNamed: aString].!rollbackTransaction	"Wipe out the transactionCache instance variable."	transactionWriteCache := nil.	transactionReadCache := nil.	changedFiles := nil.	rollbackBlocks reverseDo: [:each | each value].	rollbackBlocks := OrderedCollection new.!store: fileContentsto: fileNameString	"Save anObject to fileNameString."	self duringTransaction		ifTrue:			[ "Save these changes in the transactionWriteCache to write at commit time."			self transactionWriteCacheAt: fileNameString put: fileContents.			changedFiles add: fileNameString]		ifFalse:			[FlavorCompatibility dumpObject: fileContents toNewFile: fileNameString].!transactionReadCacheAt: aString ifAbsentPutValueOf: aBlock	^transactionReadCache		at: aString		ifAbsentPut: aBlock!transactionWriteCacheAt: aString ifAbsent: aBlock	^transactionWriteCache 		at: aString 		ifAbsent: aBlock.!transactionWriteCacheAt: aString put: anObject	^transactionWriteCache 		at: aString 		put: anObject!update: aDOWrapper to: fileNameString    "Do object version checking.  This method to be used only by a SingleObjectService."	| wrapper contents |	contents := self readForUpdate: fileNameString.	wrapper := DOWrapper fromArray: contents.	aDOWrapper compareVersionWith: wrapper.	self addRollbackBlock: aDOWrapper rollbackBlock.	self store: aDOWrapper asArray to: fileNameString.! !!DOUserPolicy class methodsFor: 'As yet unclassified'!Comment	"	Instance of this class store and retrieve objects at the file level. Dealing with the	individual objects is is left up to the objects-per-file policy.		A certain amount of transaction processing is supported.	Use beginTransaction	and commitTransaction (or rollbackTransaction) to use it.			During a transaction all read and store commands will be saved in the cache	until committed or rolled back.	If multi-user, all read files will be locked until 	commit or rollback.  This is to help avoid extra disk reads and writes for 	multi-object processing"! !!DOService methodsFor: 'As yet unclassified'!beginTransaction	"Use transactions carefully.  They should be very short periods of time for 	multi-user because all read files will be locked until committed or rolled back.	All read and stored objects will be saved in the cache until commit time."		userPolicy beginTransaction.!commitTransaction	"Abort any changes and unlock all files lock by this user."		userPolicy commitTransaction.!duringTransaction	"Answer true or false."	^userPolicy duringTransaction!isDOService	^true!isMultiUser	^userPolicy isMultiUser!isSingleUser	^userPolicy isSingleUser!pathName	"Answer the path string to store objects in.  Default to the current path"	pathName isNil		ifTrue: [ pathName := '.', (FlavorCompatibility directoryDelimiterString) ].	^pathName!pathName: aString	"Set the pathName instance variable to aString."	(pathName := aString) last = (FlavorCompatibility directoryDelimiter)		ifFalse: [pathName := pathName, (FlavorCompatibility directoryDelimiterString)].!protect: aBlock	"Private - Protect a block of code (probably a save command).  Rollback changes if an error occurs.	If a transaction is already in progress, don't start a new one or commit the old one."		| myTransaction result |	myTransaction := false.	userPolicy duringTransaction  "begin a transaction if not already begun."	ifFalse: [		myTransaction := true.		userPolicy beginTransaction].	ExceptionCompatibility	on: #anyError	during: [result := aBlock value]        do: [ :error |		userPolicy rollbackTransaction.		ExceptionCompatibility pass: error].	myTransaction		ifTrue: [userPolicy commitTransaction].	^result.!readAll	"Answer all objects that I have stored."	^self subclassResponsibility!replace: object1 with: object2	"Public"	FlavorCompatibility		atPropertyNamed: #DOId		for: object2		put: (self idFor: object1).	FlavorCompatibility		atPropertyNamed: #DOVersion		for: object2		put: (self versionFor: object1).	self store: object2.!rollbackTransaction	"Abort any database changes and unlock all files lock by this user.	The version of objects stored during this transaction also change back to their original version.	Other changes to objects stored during the transaction are not rolled back."		userPolicy rollbackTransaction.!specialStore: anObject	"Public - Store anObject without making a clone.  	Subsequent changes to the object will then be saved when committed."	^self protect: [self privateStore: (DOWrapper noClone: anObject)].!store: anObject	"Public - Store anObject.  If an error occurs, the changes will be rolled back."	^self protect: [self privateStore: (DOWrapper on: anObject)].!storeYourselfOn: fullFileName	"Store myself on fullFileName"	(DOSingleObjectService newSingleUserOn: fullFileName) store: self.!userPolicy	"Private - Getter"	^userPolicy!userPolicy: aDOUserPolicy	"Private - Set my userPolicy instance variable."	userPolicy := aDOUserPolicy.!writeCacheType: aSymbol	"aSymbol can be either #stream or #object.	#stream means objects will be saved to a stream immediately during storing.	#object means the objects themselves will be held in the write cache until commit time."	userPolicy writeCacheType: aSymbol! !!DOService class methodsFor: 'As yet unclassified'!Comment^'The concrete subclasses of this abstract class are the interfaceinto the DiskObjectServices.Many objects can be stored in a file, or just one.  If we have many to store, the DOMultiObjectService is used.  If only one, the DOSingleObjectService is used.Note: In order to update or delete an object, it must be read first, thenused as a parameter into the store: or delete: method.When reading a deleted object, an instance of DODeletedObject is returned.  To replace a deleted object, you must read it then use #replace:with:Objects cannot be deleted or updated without version checking.In Other Words - You cannot store an old version of an object.Global objects like Integers and Symbols may not be storedby themselves because they are shared.  When you store oneof these classes, they must be wrapped in another object (an arrayor any other object instance).'!newMultiUser    "Answer a new instance of myself with a multi user policy."    ^self new        userPolicy: (DOMultiUserPolicy new);        yourself.!newSingleUser    "Answer a new instance of myself with a single user policy."    ^self new        userPolicy: (DOSingleUserPolicy new);        yourself.!openOn: fullFileName    "Read myself in from fullFileName"	FlavorCompatibility needsWork. "This method name is confusing given what it is really doing."	^(DOSingleObjectService newSingleUserOn: fullFileName) read! !!DOSingleUserPolicy methodsFor: 'As yet unclassified'!isLocked: fileNameString	"Answer a boolean.  Answer true since there is only one user."	^true!isSingleUser	^true!readForUpdate: aFullFileNameString	"Read whatever is in aFileNameString.  Used by DOObjectPolicy>>readForUpdate:.	The default is no locking.  DOMultiUserPolicy overrides this."	^self readFileNamed: aFullFileNameString!unlockFileNamed: aString! !!DOSingleObjectService methodsFor: 'As yet unclassified'!delete: anObject	"Public - Answer an instance of DODeletedObject.	An object must be read before it can be deleted."	| oldObjectWrapper array wrapper |	anObject isDODeletedObject ifTrue: [^anObject].	self protect: 		[oldObjectWrapper := self privateReadForUpdate.		(wrapper := DOWrapper noClone: anObject) compareVersionWith: oldObjectWrapper.		array := wrapper asDeletedObjectArray.		self userPolicy store: array to: self fullFileName.].	^DODeletedObject fromArray: array.!fileName	"Answer the name of the file."	^fileName!fileName: aString	"Set the fileName instance variable to aString."	fileName := aString.!fullFileName	"Answer the path name and file name as one string."	^self pathName, self fileName!fullFileName: aString	"Set the fileName instance variable to aString."	| i |	( i := aString lastIndexOf: FlavorCompatibility directoryDelimiter) == 0		ifTrue: [self error: 'Invalid file name.  You must include the full path and drive.'].	pathName := aString copyFrom: 1 to: i.	fileName := aString copyFrom: i+1 to: aString size.	fileName isEmpty ifTrue: [self error: 'You must include a file name with the path'].!isLocked	"Public - Answer a boolean.  Answer true if locked by this service.	If using the singleUserPolicy, true will always be answered."	^userPolicy isLocked: self fullFileName!lock: anObject	"Public - My object must already have been read in before using this method.	Use #readForUpdate if you want to do both at the same time.	If it has changed since reading, DOInvalidVersionError will be signaled.	This should be the same object that was read from disk earlier."	| oldObject |	self isLocked ifTrue: [^self].	oldObject := self privateReadForUpdate.	ExceptionCompatibility		on: #DOInvalidVersionError		during: [(DOWrapper noClone: anObject) compareVersionWith: oldObject]		do: [:excp | self unlock: anObject.			ExceptionCompatibility pass: excp].	^self!printOn: aStream		super printOn: aStream.	aStream 		nextPut: $(;		print: self fullFileName;		nextPut: $).!privateReadForUpdate	"Answer a DOWrapper or nil."	| result |	result := self userPolicy readForUpdate: self fullFileName.	^DOWrapper fromArray: result.!privateStore: aDOWrapper	"Private"	userPolicy update: aDOWrapper to: self fullFileName.!read	"Public"	| array |	array := self userPolicy readFileNamed: self fullFileName.	array isNil ifTrue: [^nil].	^(DOWrapper fromArray: array) object.!read: anObject	"Answer a copy of the disk version of anObject"	^self read!readAll	"Public - Ask my user policy to read the object from disk."	^self read.!readForUpdate	"Public"	| wrapper |	^(wrapper := self privateReadForUpdate) isNil		ifTrue: [nil]		ifFalse: [wrapper object].!readId: anInteger	"Signal an error."	self error: 'The #readId: method is used with DOMultiObjectService only.'!unlock: anObject	"To be used after reading an object for update or just locking it."	self duringTransaction		ifFalse: [userPolicy unlockFileNamed: self fullFileName].! !!DOSingleObjectService class methodsFor: 'As yet unclassified'!newMultiUserOn: fullFileName    "Answer a new instance of myself with a multi user policy."    ^self newMultiUser        fullFileName: fullFileName;        yourself.!newSingleUserOn: fullFileName    "Answer a new instance of myself with a single user policy."    ^self newSingleUser        fullFileName: fullFileName;        yourself.!read: fullFileName    ^(self newSingleUserOn: fullFileName) read! !!DOMultiObjectService methodsFor: 'As yet unclassified'!assignIdTo: anObject	"Answer the internal database id for this object or give it one if it has none."	| id |	FlavorCompatibility		atPropertyNamed: #DOId		for: anObject		put: (id := self nextId).	^id!delete: anObject	"Public - Answer an instance of DODeletedObject"	| id |	(id := self idFor: anObject) isNil		ifTrue: [self error: 'anObject must have a db id.'].	anObject isDODeletedObject		ifTrue: [^anObject].	self protect: [^objectsPerFilePolicy delete: (DOWrapper noClone: anObject)].!fileNamePattern	"Private - Get the pattern for the file names.  Default is 'File9999.obj'."	fileNamePattern == nil		ifTrue: [ fileNamePattern := 'File9999.obj' ].	^fileNamePattern!fileNamePattern: aString	"Set the pattern for the file names.  Default is 'File9999.obj'."	fileNamePattern := aString.!fileNumberForId: anInteger	^objectsPerFilePolicy fileNumberForId: anInteger!initialize	"Default the objectsPerFile policy to 1."	self objectsPerFile: 1!isLocked: anObject	"Answer a boolean.  Answer true if locked by this service.	If using the singleUserPolicy, true will always be answered."	^objectsPerFilePolicy isLocked: anObject!lastId	"Public - Answer the last id assigned or nil."	| result |	result := self nextIdDOManager read.	^result isNil		ifTrue: [nil]		ifFalse: [result first].!lock: anObject	"Lock this object.  If it has been changed since it was read, 	signal DOInvalidVersionError."	(objectsPerFilePolicy isLocked: anObject)		ifTrue: [^self].	objectsPerFilePolicy lock: anObject.!nextId    "Private - Answer the next available id."	| lastId nextId array |	array := self nextIdDOManager readForUpdate.	lastId := array isNil		ifTrue: [lastId := 0]		ifFalse: [lastId := array first].	nextId := lastId + 1.	nextIdDOManager store: (Array with: nextId).	^nextId.!nextIdDOManager	"Private - Get the next available id."	nextIdDOManager isNil		ifTrue:			[nextIdDOManager := DOSingleObjectService new				userPolicy: self userPolicy class new;				fileName: 'nextId.obj';				pathName: self pathName;				yourself].	^nextIdDOManager.!objectsPerFile: anInteger	"Set the objects-per-file policy based on the value of anInteger."	| policy |	anInteger > 1		ifTrue: [policy := DOMultiObjectsPerFilePolicy new: anInteger]		ifFalse: [policy := DOSingleObjectPerFilePolicy new].	objectsPerFilePolicy := policy.	objectsPerFilePolicy manager: self.	objectsPerFilePolicy userPolicy: userPolicy.!printOn: aStream		super printOn: aStream.	aStream 		nextPut: $(;		print: self pathName, self fileNamePattern;		nextPut: $).!privateStore: aDOWrapper	"Private - to be used only by my own methods."	aDOWrapper id isNil 		ifTrue: [aDOWrapper id: self nextId.			aDOWrapper assignIdToOriginal.].	objectsPerFilePolicy store: aDOWrapper.!read: anObject	"Answer a copy of the disk version of anObject"	| id result |	(id := self idFor: anObject) isNil		ifTrue: [self error: 'object must have a database id to read it'.].	^self readId: id.!readAll	"Answer all objects that I have stored."	^objectsPerFilePolicy readAll collect: [:each | each object]!readFileNumber: anInteger	"Answer the contents of file number anInteger"	^objectsPerFilePolicy readFileNumber: anInteger.!readForUpdate: anObject	"Answer the disk version of an object from the database"	| id result |	(id := self idFor: anObject) == nil		ifTrue: [self error: 'object must have a database id to read it'.].	^self readIdForUpdate: id.!readId: anInteger	"Answer one object read from disk or nil if none was found."	| wrapper |	wrapper := objectsPerFilePolicy readId: anInteger.	^wrapper isNil 		ifTrue: [nil]		ifFalse: [wrapper object].!readIdForUpdate: anInteger	"Answer one object read from disk or nil if none was found."	| wrapper |	self protect: 		[wrapper := objectsPerFilePolicy readIdForUpdate: anInteger.		^wrapper isNil 			ifTrue: [nil]			ifFalse: [wrapper object].		].!storeAll: aCollection	"Store a collection of objects.  If an error occurs, the changes will be rolled back."	self protect: [aCollection do: [:each | self privateStore: each]].!unlock: anObject	self duringTransaction		ifFalse: [objectsPerFilePolicy unlock: anObject].! !!DOMultiObjectService class methodsFor: 'As yet unclassified'!Comment"The strength of the DOMultiObjectService class is to storemultiple business objects.  As each object is stored it isgiven a database id and a version number."!newMultiUserOn: pathName    "Answer a new instance of myself with a multi user policy."    ^self newMultiUser        pathName: pathName;        yourself.!newSingleUserOn: pathName    "Answer a new instance of myself with a single user policy."    ^self newSingleUser        pathName: pathName;        yourself.! !!DOWrapper methodsFor: 'As yet unclassified'!asArray	"An array is really what wraps this object when it is stored"	self incrementVersion.	^Array with: object with: id with: self newVersion.	!asDeletedObjectArray	"An array is really what wraps this object when it is stored"	^Array with: #deleted with: id with: self newVersion.	!assignId	FlavorCompatibility assert: (object isNil not). FlavorCompatibility testing.	FlavorCompatibility atPropertyNamed: #DOId for: object put: id.!assignIdToOriginal	FlavorCompatibility atPropertyNamed: #DOId for: originalObject put: id.!assignVersion	FlavorCompatibility atPropertyNamed: #DOVersion for: object put: version!compareVersionWith: anObject	"Compare my objects version to the disk version of anObject.	If my object has never been in the database, don't compare versions.	Assume the object ids are the same."		self isNew		ifTrue: [^self].	version == anObject version		ifFalse: [self signalInvalidVersionError: anObject].!decrementVersion	"rollback the version of the original object"	originalObject isNil ifTrue: [self error: 'is this really an error?'].  FlavorCompatibility testing.	FlavorCompatibility atPropertyNamed: #DOVersion for: originalObject put: version.!id	^id!id: anInteger	id := anInteger!incrementVersion	"Private - increment the version on the original object"	originalObject isNil ifTrue: [self error: 'is this really an error?'].  FlavorCompatibility testing.	FlavorCompatibility atPropertyNamed: #DOVersion for: originalObject put: self newVersion.!isNew	^version == 0!newVersion	^version + 1!object	object isNil ifFalse: 		[self assignId; 			assignVersion].	^object!object: anObject	object := anObject.!originalObject: anObject	originalObject := anObject.!rollbackBlock	^[self decrementVersion.]!setObject: anObject original: original	self		object: anObject;		originalObject: original;		id: (self idFor: original);		version: (self versionFor: original)!version	^version!version: anInteger	version := 		anInteger isNil			ifTrue: [0]			ifFalse: [anInteger].! !!DOWrapper class methodsFor: 'As yet unclassified'!fromArray: anArray	"This instance wraps an object on it's way out of the database"	anArray isNil		ifTrue: [^nil].	anArray first == #deleted		ifTrue: [^DODeletedObject fromArray: anArray].	^self new 		object: (anArray at: 1);		id: (anArray at: 2);		version: (anArray at: 3).!noClone: anObject	"This method is just like #on: but doesn't create a deep copy (clone) of the object."	^self new setObject: anObject original: anObject!on: anObject	"This class wraps an object on it's way into the database.	A very deep copy of the object is made so changes can occur before committing."	^self new setObject: (FlavorCompatibility clone: anObject) original: anObject! !!DOObjectsPerFilePolicy methodsFor: 'As yet unclassified'!fullFileNameFor: anObject	"Answer the full file name for anObject."	^self fullFileNameForId: (self idFor: anObject)!isLocked: anObject	"Answer a boolean"	^userPolicy isLocked: (self fullFileNameFor: anObject)!lock: anObject	self error: 'Not yet implemented.'.	FlavorCompatibility issue.	"Because there are multiple objects in each file, and to lock an object	means locking its file, unlocking will take some thought.	Lock/Unlock capability is not needed by MinneStore, so I'm leaving this for now."	!manager: aDOManager	"Setter"	manager := aDOManager!readAll	"Answer all the stored objects."	^self subclassResponsibility.!store: anObject	"Store an object to disk."	^self subclassResponsibility!userPolicy	"Getter - If the userPolicy is nil, get it from the objectPolicy."	userPolicy == nil		ifTrue: [userPolicy := manager userPolicy].	^userPolicy.!userPolicy: aPolicy	"Setter"	userPolicy := aPolicy! !!DOObjectsPerFilePolicy class methodsFor: 'As yet unclassified'!Comment"	These classes handle the number of objects stored in each file.	The manager and user policy logic is thereby insulated from any of this knowledge."! !!DODeletedObject methodsFor: 'As yet unclassified'!asDeletedObjectArray	"This method is polymorphic with DOWrapper.	An array is really what wraps this object when it is stored."	^Array with: #deleted with: id with: self newVersion.!id	^id!isDODeletedObject	^true!newVersion	^version + 1!object	"Polymorphic with DOWrapper"	FlavorCompatibility atPropertyNamed: #DOId for: self put: id.	FlavorCompatibility atPropertyNamed: #DOVersion for: self put: version.	^self!setId: idInteger version: verInteger	id := idInteger.	version := verInteger.!version	^version! !!DODeletedObject class methodsFor: 'As yet unclassified'!fromArray: anArray	^self new setId: (anArray at: 2) version: (anArray at: 3).! !!DOMultiObjectsPerFilePolicy methodsFor: 'As yet unclassified'!delete: aWrapper	| fileName fileContents wrapper array ix |	fileName := self fullFileNameForId: aWrapper id.	fileContents := self readForUpdate: fileName.	ix := self indexForId: aWrapper id.	wrapper := DOWrapper fromArray: (fileContents at: ix).	aWrapper compareVersionWith: wrapper.	array := wrapper asDeletedObjectArray.	fileContents at: ix put: array.	self userPolicy store: fileContents to: fileName.	^DODeletedObject fromArray: array.!fileNumberForId: anInteger	^((anInteger - 1) // objectsPerFile) + 1.!fullFileNameForId: anInteger	"Answer the full file name for id of anInteger."	| fileNumber |	fileNumber := self fileNumberForId: anInteger.	^self fullFileNameNumbered: fileNumber.!fullFileNameNumbered: anInteger	"Answer the full file name for id of anInteger."	| fileName |	fileName := 		FlavorCompatibility 		replaceAll: '9999' 		in: manager fileNamePattern 		with: (anInteger asZeroFilledString: 4).	^manager pathName, fileName.!indexForId: anInteger	"Answer the remainder of the id divided by the number of objects per file."	^((anInteger + -1) \\ objectsPerFile) + 1.!objectsPerFile: anInteger	"Setter"	objectsPerFile := anInteger.!readAll	"Answer all the stored objects."	| result anOC fileContents |	anOC := OrderedCollection new.	1 to: manager lastId		do:			[:id |			(self indexForId: id) == 1				ifTrue: [fileContents := self readFileNamed: (self fullFileNameForId: id)].			result := fileContents at: (self indexForId: id).			(result := DOWrapper fromArray: result) isDODeletedObject				ifFalse: [anOC add: result].			].	^anOC!readFileNamed: fileName	"Private - delegate to my userPolicy.  If nil is returned to me, answer an empty array."	| fileContents |	^(fileContents := self userPolicy readFileNamed: fileName) isNil		ifTrue: [Array new: objectsPerFile]		ifFalse: [fileContents].!readFileNumber: anInteger	"Answer a collection of the objects in file number anInteger"	| fileContents oc result |	oc := OrderedCollection new.	fileContents := self readFileNamed: (self fullFileNameNumbered: anInteger).	^fileContents collect: [:each | (DOWrapper fromArray: each) object].!readForUpdate: fileName	"Private - delegate to my userPolicy.  If nil is returned to me, answer an empty array."	| fileContents |	^(fileContents := self userPolicy readForUpdate: fileName) isNil		ifTrue: [Array new: objectsPerFile]		ifFalse: [fileContents].!readId: anInteger	| result |	result := (self readFileNamed: (self fullFileNameForId: anInteger))						at: (self indexForId: anInteger).	^DOWrapper fromArray: result.!readIdForUpdate: anInteger	"Answer a DOWrapper"	| result |	result := (self readForUpdate: (self fullFileNameForId: anInteger))				at: (self indexForId: anInteger).	^DOWrapper fromArray: result.!store: aDOWrapper	"Used by a MultiUserPolicy. Check the object version before storing"	| id fileName fileContents |	id := aDOWrapper id.	aDOWrapper compareVersionWith: (self readIdForUpdate: id).	fileName := self fullFileNameForId: id.	fileContents := self readForUpdate: fileName.	fileContents 		at: (self indexForId: id) 		put: aDOWrapper asArray.	self userPolicy addRollbackBlock: aDOWrapper rollbackBlock.	self userPolicy store: fileContents to: fileName.! !!DOMultiObjectsPerFilePolicy class methodsFor: 'As yet unclassified'!Comment"	The benefits with using this policy object are:	1) Reduced disk space.	2) Fewer files.	3) Better throughput when reading objects in sequence.		The disadvantages of using this policy are:	1) File level locking is used in a multi-user environment.	This means more contention and chance for deadlock.	2) It may be a little slower, but I haven't tested this."!new: anInteger	"Create a new instance and set the objectsPerFile instance variable."	^self new 		objectsPerFile: anInteger;		yourself.! !!MSHighValue methodsFor: 'As yet unclassified'!< anObject	^false!<= anObject	^false!= anObject	^false!> anObject	^true!>= anObject	^true! !!MSHighValue class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!IndirizzoPersona methodsFor: 'accessing'!email	^email.!email: aString	email := aString.!indirizzo	^indirizzo!indirizzo: aStr	indirizzo:= aStr.!note	^note!note: aString	note := aString.! !!IndirizzoPersona methodsFor: 'printing'!printOn: aStream	aStream 		print: 'IndirizzoPersona';		nextPut: $< ;		print: name ;cr;		print:' Tel. ';		print: number; cr ;		print: 'Email '; print: email;cr;		print:'Via '; print: indirizzo;		nextPut: $>.! !!IndirizzoPersona class methodsFor: 'inst creation'!nome: aString numero: anInteger 	"DEPRECATED!!!!"	^self new		name: aString;		number: anInteger! !!FailedCheck class methodsFor: 'As yet unclassified'!comment^'Instances are exceptions raised by TestCase when an expectedvalue is not generated during the running of a test.  This is atest failure as opposed to an unexpected runtime error.'! !!TestCase methodsFor: 'As yet unclassified'!assertFalse: aBoolean    self assertFalse: aBoolean named: ''.!assertFalse: aBoolean named: aString    aBoolean ifTrue: [ ExceptionCompatibility signal: self failedCheckException with: aString, ' false assertion failed- ' ]!assertTrue: aBoolean    self assertTrue: aBoolean named: ''.!assertTrue: aBoolean named: aString    aBoolean ifFalse: [ ExceptionCompatibility signal: self failedCheckException with: aString, ' true assertion failed- ' ]!asString	^self class name!errorException    "Answer the exception class to use for unexpect runtime errors."    ^#anyError!expect: exceptionSymbol during: aBlock	| ok |	ok := false.	ExceptionCompatibility		on: exceptionSymbol		during: aBlock		do: [:ex | ok := true. ExceptionCompatibility return: ex.].	ok ifFalse: [self signalFailedCheckException: exceptionSymbol, ' did not occur'.].!failedCheckException    "Answer the exception class to use for test results that don't    match expected values."    ^#FailedCheck!log: aString	self class log: aString!performTest    "Perform the selector necessary to do the test and check results.    Assumes that set up and tear down is being performed by client.    Send a status message to the log stream so we can see something    during long tests."    self class log: self class name, '>>', selector.    self perform: selector!printOn: aStream    aStream        "nextPutAll: 'Test case ';"        nextPutAll: self class name;        nextPutAll: '>>';        nextPutAll: selector!run    "Run the test after performing setup and ensuring that tear down    runs even if there is an exception.  Note that test should always    be run via this method so that set up is performed.  For robustness    it is best for every test case to start with freshly set up data, rather    than trying to share data that may not have been properly initialized.    Note that if this method is used directly, error and failure exceptions    are not handled -- that is up to the client."    self setup.    ExceptionCompatibility	during: [ self performTest ]	ensure: [ self tearDown ]!run: aTestResult    "Run the test case handling error and failure exceptions    by writing information about the exception to the passed    test result."	ExceptionCompatibility	on: self errorException	during:		[ExceptionCompatibility		on: self failedCheckException		during: [ self run ]		do: [:ex | 			self stopOnCheckFailure ifTrue: [self halt].			aTestResult failure: ex description in: self.			ExceptionCompatibility return: ex] 		]	do: [:ex | 		self stopOnError ifTrue: [ExceptionCompatibility pass: ex].		aTestResult error: ex description in: self.		ExceptionCompatibility return: ex].	aTestResult success: self.!selector: aSymbol    selector := aSymbol!setup    "Run whatever code you need to get ready for the test to run."!should: aBlock    aBlock value ifFalse: [ self failedCheckException signal: 'Should failed- ' ]!shouldnt: aBlock    aBlock value ifTrue: [ self failedCheckException signal: 'Shouldn''t failed- ' ]!signalFailedCheckException: aString    ^self failedCheckException signal: aString!stopOnCheckFailure	^false!stopOnError	^false!tearDown    "Release whatever resources you used for the test."! !!TestCase class methodsFor: 'As yet unclassified'!comment^'Instances represent a single test case.  Most real uses will subclass TestCase,adding instance variables and setUp/tearDown code for setting up data sharedbetween several test cases.Instance variables:    selector - a Symbol.  Name of the method to be invoked to run the test case        represented by this instance.Copyright (c) 1994, First Class Software, Inc.  All rights reserved.'!log: astring    "Send a status string to the log stream if there is one."    self logStream isNil ifFalse: [        self logStream nextPutAll: astring; cr ]!logNil    "Turn off status message logging."    LogStream := nil!logStream    "Answer a stream for writing status messages on.  Can be nil    to turn off logging."    ^LogStream!logTranscript    "Send status messages to the Transcript."    LogStream := Transcript!selector: aSymbol    "Instantiate a new test case with the particular selector that    is to be sent to self to run the test."    ^self new selector: aSymbol! !!MinneStoreTestCase3 methodsFor: 'As yet unclassified'!setup	| dir |	dir := self class testingDirectory.	FlavorCompatibility removeDirectoryNamed: dir ifAbsent: [].	db := MinneStoreDB newOn: dir.	db supportMultipleUsers.	(db addObjectSetNamed: #Employees)		objectsPerFile: 3;		storesClass: Employee;		maximumLeavesPerBranch: 4;  "indexing parameter.  Default is 20"		indexOn: #name domain: String;		indexOn: #notes domain: MSText;		aspect: #manager holdsOne: #Employees;		yourself.	db save.!setupData1	"This should result in an error because the aspects aren't being saved as they go along."	| e1 e2 e3 |	e1 := Employee new			name: 'Jack Sprat';			notes: 'could eat no fat, his wife could eat no lean.'.	e2 := Employee new			name: 'Miss Muffet';			notes: 'sat on a tuffet, eating her curds and whey.';			manager: e1.	e3 := 		(Employee new			name: 'Humpty Dumpty';			notes: 'sat on a wall; had a great fall';			manager: e2).	db store: e3.!setupData2	db store: 		(Employee new			name: 'Jack Sprat';			notes: 'could eat no fat, his wife could eat no lean.').	db store: 		(Employee new			name: 'Miss Muffet';			notes: 'sat on a tuffet, eating her curds and whey.';			manager: ((db getOne: #Employees) where: #name eq: 'Jack Sprat'; execute)).	db store:		(Employee new			name: 'Humpty Dumpty';			notes: 'sat on a wall; had a great fall';			manager: ((db getOne: #Employees) where: #name startsWith: 'Miss'; execute)).!stopOnCheckFailure	^true!stopOnError	^true!test1	| result |	self expect: #anyError during: [self setupData1].	db := MinneStoreDB openOn: self class testingDirectory.	self setupData2.	result := (db getAll: #Employees) 			where: #notes hasWord: 'on'; 			execute.	self assertTrue: (result size == 2).	"Case should not matter"	result := (db getAll: #Employees) 			where: #notes hasAllWords: #('hAd' 'oN'); 			execute.	self assertTrue: (result size == 1).	result := (db getAll: #Employees) 			where: #notes hasSomeWords: #('on' 'had' 'eat'); 			execute.	self assertTrue: (result size == 3).! !!MinneStoreTestCase3 class methodsFor: 'As yet unclassified'!all	^OrderedCollection new		add: (self new selector: #test1);		yourself.!Comment"This class tests the sentence indexing capability and also tests relationships between objects in the same object set."!testingDirectory	^'C:\MSTest\'! !!MinneStoreTestCase1 methodsFor: 'As yet unclassified'!allPersonObjects	^(OrderedCollection new		add: (DOTestObject name: 'Frederick Buechner' age: 57);		add: (DOTestObject name: 'C.S. Lewis' age: 63);		add: (DOTestObject name: 'Blaise Pascal' age: 63);		add: (DOTestObject name: 'George MacDonald' age: nil);		add: (DOTestObject name: 'Graham Greene'  age: 80);		add: (DOTestObject name: 'Dietrich Bonhoeffer' age: 41);		add: (DOTestObject name: 'Charles Williams' age: 55);		add: (DOTestObject name: 'J.R.R. Tolkien' age: 72);		add: (DOTestObject name: 'John Steinbeck' age: 66);		yourself).!setup	| dir |	dir := self class testingDirectory.	FlavorCompatibility removeDirectoryNamed: dir ifAbsent: [].	db := MinneStoreDB newOn: dir.	db supportMultipleUsers.	(db addObjectSetNamed: #Persons)		objectsPerFile: 3;		storesClass: DOTestObject;		maximumLeavesPerBranch: 4;  "indexing parameter.  Default is 20"		indexOn: #name domain: String;		indexOn: #age domain: Integer.	db save.!stopOnCheckFailure	^true!stopOnError	^true!test1	"Store each object individually and do a general verification."	| tmp oc i |	i := 0.	self allPersonObjects do: 		[:each |		db store: each.		i := i + 1.		self assertTrue: (db idFor: each) == i].	self updateIndexes.  "This method does nothing in my class, but is used by my subclass."	self testReading.	db := MinneStoreDB openOn: self class testingDirectory.	self testReading.!test2	"Store the objects in one transaction and do a general verification."	| results |	db storeAll: self allPersonObjects.	self updateIndexes.  "This method is used by my subclass."	self testReading.	db := MinneStoreDB openOn: self class testingDirectory.	self testReading.	self testUpdating.!test3	"Test the ability to rename or move the main database directory."	| results |	db storeAll: self allPersonObjects.	self updateIndexes.  "This method is used by my subclass."	FlavorCompatibility needsWork. "add a message box below or add rename code."	self halt. "Please rename C:\MSTest\ to C:\MSTest2\ and resume the process."	db := MinneStoreDB openOn: 'C:\MSTest2\'.	results := (db getAll: #Persons) where: #age lt: 100; execute.	results do: [:each | self assertFalse: each isNil named: 'Nil Check'].	self assertTrue: (results size == 9) named: 'Size Check'.	"Do the exact same thing as above.  The second opening may be different."	db := MinneStoreDB openOn: 'C:\MSTest2\'.	results := (db getAll: #Persons) where: #age lt: 100; execute.	results do: [:each | self assertFalse: each isNil named: 'Nil Check'].	self assertTrue: (results size == 9) named: 'Size Check'.!test4	"Test deleting an object.  Make sure its really deleted."	"Test deleting an object with identical index value to another.  Read using that index value."	| results deletedObject |	db storeAll: self allPersonObjects.	self updateIndexes.  "This method is used by my subclass."	deletedObject := db delete: ((db getOne: #Persons) where: #name eq: 'C.S. Lewis'; execute).	self assertTrue: (deletedObject isDODeletedObject).	deletedObject := (db getOne: #Persons) where: #name eq: 'C.S. Lewis'; execute.	self assertTrue: (deletedObject isNil).		"The age of Lewis was 63, make sure only Pascal (also 63) gets read in."	results := (db getAll: #Persons) where: #age eq: 63; execute.	self assertTrue: (results size == 1).	self assertTrue: (results first name = 'Blaise Pascal').!test5	"Test changing an object that has already been changed since reading.  What happens?"	"Test an index with 1-to-many values per object."!testReading	| results |	results := (db getAll: #Persons)			where: #age eq: 57;			execute.	self assertTrue: (results size == 1).	results := (db getAll: #Persons)			where: #age eq: 63;			execute.	self assertTrue: (results size == 2).	results := (db getAll: #Persons)			where: #age between: 40 and: 60;			execute.	self assertTrue: (results size == 3).	results := (db getAll: #Persons)			where: #age eq: nil;			execute.	self assertTrue: (results size == 1).	results := (db getOne: #Persons)			where: #age eq: nil;			execute.	self assertFalse: results isNil.		results := (db getAll: #Persons)			where: #name startsWith: 'C.S.';			execute.	self assertTrue: (results size == 1).!testUpdating	| results |	results := (db getOne: #Persons) 			where: #age eq: 57; 			execute.	results age: 56.	db store: results.	results := (db getAll: #Persons)			where: #age lte: 57;			execute.	self assertTrue: (results size == 4).	results do: 		[:each |		each age isNil			ifTrue: [each age: 100]			ifFalse: [each age: each age + 100].		db store: each.		].	results := (db getAll: #Persons) 			where: #age lte: 57; execute.	self assertTrue: (results isEmpty).	results := (db getAll: #Persons) 			where: #age gte: 100; execute.	self assertTrue: (results size == 4).!updateIndexes	"Do nothing.  My subclass needs this."! !!MinneStoreTestCase1 class methodsFor: 'As yet unclassified'!all	^OrderedCollection new		add: (self new selector: #test1);		add: (self new selector: #test2);		add: (self new selector: #test3);		add: (self new selector: #test4);		yourself.!testingDirectory	^'C:\MSTest\'! !!DiskObjectServicesTestCase methodsFor: 'As yet unclassified'!initializeStorageLocation	FlavorCompatibility removeDirectoryNamed: self class testingDirectory ifAbsent: [].	FlavorCompatibility createDirectoryNamed: self class testingDirectory.!printOn: aStream    aStream"        nextPutAll: 'Test case ';"        nextPutAll: self class name;	nextPut: $(;	print: service userPolicy;	nextPut: $);        nextPutAll: '>>';        nextPutAll: selector!service	^service!service: aDOService	service := aDOService!setup    "Run whatever code you need to get ready for the test to run."	self initializeStorageLocation.!stopOnCheckFailure	^true!stopOnError	^true!test1	"Test that the object ids are set correctly and the versioning happens"	|  testObject testObjectClone |	testObject := DOTestObject CSLewis.	"store object.  Verify id and version."	service store: testObject.	self assertTrue: ((service versionFor: testObject) == 1) named: 'AT1'.	self validateId: testObject.	"read object just stored.  Verify id and version haven't changed."	testObjectClone := service read: testObject.		self assertTrue: ((service idFor: testObject) == (service idFor: testObjectClone)) named: 'AT2'.	self assertTrue: ((service versionFor: testObject) == (service versionFor: testObjectClone)) named: 'AT3'.	"change and store the clone, read it in and verify the change occurred."	testObjectClone name: 'different name'.	service store: testObjectClone.	self assertTrue: ((service versionFor: testObjectClone) == 2) named: 'AT4'.	testObjectClone := service read: testObjectClone.	self assertTrue: (testObjectClone name = 'different name') named: 'AT5'.	self assertTrue: ((service versionFor: testObjectClone) == 2) named: 'AT6'.	"delete the object, when read an error should be signaled."!test2	"Test the rollback mechanism."	| testObject |	testObject := DOTestObject CSLewis.	service beginTransaction.	service store: testObject.	service rollbackTransaction.	self assertTrue: ((service read: testObject) isNil) named: 'AT1'.	self assertTrue: ((service versionFor: testObject) == 0) named: 'AT2'.!test3	"Test the versioning mechanism."	| testObject testObjectClone |	testObject := DOTestObject CSLewis.	service store: testObject.	testObjectClone := service read: testObject.	testObjectClone name: 'different name'.	"store the clone"	service store: testObjectClone.	"store the original, an error should occur because the version is wrong"	self expect: #DOInvalidVersionError during: [service store: testObject].!test4	"Test that versions are rolled back when the service is rolled back."	| testObject testObjectClone originalName |	testObject := DOTestObject CSLewis.	originalName := testObject name.	service store: testObject.	self assertTrue: ((service versionFor: testObject) == 1) named: 'AT1'.	service beginTransaction.	testObject name: 'different name 1'.	service store: testObject.	self assertTrue: ((service versionFor: testObject) == 2) named: 'AT2'.	testObject name: 'different name 2'.	service store: testObject.	self assertTrue: ((service versionFor: testObject) == 3) named: 'AT3'.	service rollbackTransaction.	self assertTrue: ((service read: testObject) name = originalName) named: 'AT4'.	self assertTrue: ((service versionFor: testObject) == 1) named: 'AT5'.!test5	"Test reading all objects using the multiObject service.  	Deleted objects must not be returned"	| testObject result instance2 |	service class == DOSingleObjectService ifTrue: [^self].	service store: DOTestObject CSLewis.	service store: (instance2 := DOTestObject GrahamGreene).	service store: DOTestObject GeorgeMacDonald.	service store: DOTestObject JRRTolkien.	service delete: instance2.	result := service readAll.	self assertTrue: (result size == 3).!test6	"Test locking and unlocking using the singleObjectService.	Lock testing (#isLocked:) only returns pertinent info when using the multi-user policy"	| testObject result instance2 |	service class == DOMultiObjectService ifTrue: [^self].	service isSingleUser ifTrue: [^self].	service store: DOTestObject CSLewis.	testObject := service readForUpdate.	self assertTrue: (service isLocked) named: 'locked'.	service unlock: testObject.	self assertFalse: (service isLocked) named: 'unlocked'.!test7	"Test the basic deletion logic."	| testObject deletedObject |	service store: (testObject := DOTestObject CSLewis).	self assertTrue: ((service versionFor: testObject) == 1).	deletedObject := service delete: testObject.	self assertTrue: ((service versionFor: testObject) == 1).	self assertTrue: deletedObject isDODeletedObject named: 'isDO1'.	deletedObject := service read: testObject.	self assertTrue: deletedObject isDODeletedObject named: 'isDO2'.	self expect: #DOInvalidVersionError during: [service store: testObject].	"undo the delete with the replace:with: method"	service replace: (service read: testObject) with: testObject.	self assertFalse: (service read: testObject) isDODeletedObject named: 'isDO3'.!test8	"Test the specialStore logic."	| testObject deletedObject |	service beginTransaction.	service specialStore: (testObject := DOTestObject CSLewis).	testObject name: 'a different name'.	service commitTransaction.	testObject := service read: testObject.	self assertTrue: (testObject name = 'a different name').!test9	"Test the readFileNumber: logic."		| result |	service class == DOSingleObjectService ifTrue: [^self].	service store: DOTestObject CSLewis.	service store: DOTestObject BlaisePascal.	service store: DOTestObject FrederickBuechner.	service store: DOTestObject GrahamGreene.	service delete: (service readId: 2).	result := service readFileNumber: 1.	result do: [:each | self assertTrue: (each class == DOTestObject or: [each class == DODeletedObject])].	result := service readFileNumber: 2.	result do: [:each | self assertTrue: (each class == DOTestObject or: [each class == DODeletedObject])].! !!DiskObjectServicesTestCase class methodsFor: 'As yet unclassified'!all	^OrderedCollection new		addAll: (self selector: #test1);		addAll: (self selector: #test2);		addAll: (self selector: #test3);		addAll: (self selector: #test4);		addAll: (self selector: #test5);		addAll: (self selector: #test6);		addAll: (self selector: #test7);		addAll: (self selector: #test8);		addAll: (self selector: #test9);		yourself.!multiUser	^self new 		service: (self serviceClass newMultiUserOn: self storageLocation)!multiUserMultiObjectsPerFile	| testCase |	testCase := self multiUser.	testCase service objectsPerFile: 2.	^testCase!selector: aSymbol	"Answer a collection of instances of my subclasses."	^OrderedCollection new		add: (SingleObjectTestCase singleUser selector: aSymbol);		add: (SingleObjectTestCase multiUser selector: aSymbol);		add: (MultiObjectTestCase singleUser selector: aSymbol);		add: (MultiObjectTestCase singleUserMultiObjectsPerFile selector: aSymbol);		add: (MultiObjectTestCase multiUser selector: aSymbol);		add: (MultiObjectTestCase multiUserMultiObjectsPerFile selector: aSymbol);		yourself.!serviceClass	^self subclassResponsibility!singleUser	^self new 		service: (self serviceClass newSingleUserOn: self storageLocation).!singleUserMultiObjectsPerFile	| testCase |	testCase := self singleUser.	testCase service objectsPerFile: 2.	^testCase!storageLocation	^self subclassResponsibility!testingDirectory	^'C:\DOTest\'! !!MultiObjectTestCase methodsFor: 'As yet unclassified'!validateId: anObject	self assertFalse: ((service idFor: anObject) isNil) named: 'Invalid Id'.! !!MultiObjectTestCase class methodsFor: 'As yet unclassified'!serviceClass	^DOMultiObjectService!storageLocation	^self testingDirectory! !!MinneStoreTestCase4 methodsFor: 'As yet unclassified'!setup	"Set up the same database as my superclass, but without indexes."	| dir |	dir := self class testingDirectory.	FlavorCompatibility removeDirectoryNamed: dir ifAbsent: [].	db := MinneStoreDB newOn: dir.	db supportMultipleUsers.	(db addObjectSetNamed: #Persons)		objectsPerFile: 3;		storesClass: DOTestObject;		maximumLeavesPerBranch: 4.  "indexing parameter.  Default is 20"	db save.!updateIndexes	(db objectSetNamed: #Persons)		indexOn: #name domain: String;		indexOn: #age domain: Integer.! !!SingleObjectTestCase methodsFor: 'As yet unclassified'!delete: anObject	^service delete!validateId: anObject	self assertTrue: ((service idFor: anObject) isNil) named: 'Invalid Id'.! !!SingleObjectTestCase class methodsFor: 'As yet unclassified'!serviceClass	^DOSingleObjectService!storageLocation	^self testingDirectory, 'Test.obj'! !!MinneStoreTestCase2 methodsFor: 'As yet unclassified'!setup	| dir |	dir := self class testingDirectory.	FlavorCompatibility removeDirectoryNamed: dir ifAbsent: [].	db := MinneStoreDB newOn: dir.	db supportMultipleUsers.	(db addObjectSetNamed: #Parts)		objectsPerFile: 3;		storesClass: Part;		maximumLeavesPerBranch: 4;  "indexing parameter.  Default is 20"		indexOn: #name domain: String;		indexOn: #number domain: Integer.	(db addObjectSetNamed: #Assemblies)		objectsPerFile: 3;		storesClass: Assembly;		maximumLeavesPerBranch: 4;  "indexing parameter.  Default is 20"		indexOn: #name domain: String;		indexOn: #number domain: Integer;		aspect: #parts holdsMany: #Parts;		aspect: #assemblies holdsMany: #Assemblies.	db save.	self setupData.!setupData	"Setup and save the data for a simplified lavatory faucet assembly.	Assemblies are composed of parts and other assemblies.	Some of the parts are used in multiple assemblies."	db store: (Part name: 'spout' number: 101).	db store: (Part name: 'lever' number: 102).	db store: (Part name: 'o-ring' number: 103).	db store: (Part name: 'elbow' number: 104).	db store: (Part name: 'gasket' number: 105).	db store: (Part name: 'seat' number: 106).	db store: (Part name: 'nut' number: 107).	db store: (Part name: 'lift rod' number: 108).	db store: (Part name: 'strap' number: 109).	db store: (Part name: 'pivot rod' number: 110).	db store: (Part name: 'aerator' number: 111).	db store: (Part name: 'hub' number: 112).	db store: 		((Assembly name: 'Handle' number: 151)			addPart: ((db getOne: #Parts) where: #name eq: 'lever'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'o-ring'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'elbow'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'hub'; execute);			yourself).	db store: 		((Assembly name: 'Drain' number: 152)			addPart: ((db getOne: #Parts) where: #name eq: 'seat'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'gasket'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'o-ring'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'nut'; execute);			yourself).	db store: 		((Assembly name: 'Lift Rod' number: 153)			addPart: ((db getOne: #Parts) where: #name eq: 'lift rod'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'strap'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'nut'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'pivot rod'; execute);			yourself).	db store: 		((Assembly name: 'Faucet' number: 154)			addAssembly: ((db getOne: #Assemblies) where: #name eq: 'Drain'; execute);			addAssembly: ((db getOne: #Assemblies) where: #name eq: 'Lift Rod'; execute);			addAssembly: ((db getOne: #Assemblies) where: #name eq: 'Handle'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'spout'; execute);			addPart: ((db getOne: #Parts) where: #name eq: 'aerator'; execute);			yourself).!stopOnCheckFailure	^true!stopOnError	^true!test1	| result |	result := (db getOne: #Assemblies) where: #name eq: 'Handle'; execute.	self assertTrue: (result parts isMSReadProxy).	self assertTrue: (result parts first number = 102).  "make sure it reads parts ok."	result := (db getOne: #Assemblies) where: #name eq: 'Faucet'; execute.	self assertTrue: (result assemblies isMSReadProxy).! !!MinneStoreTestCase2 class methodsFor: 'As yet unclassified'!all	^OrderedCollection new		add: (self new selector: #test1);		yourself.!Comment	^'This class tests a complex set of object relationships.	The following describes the parts and assemblies for a	simplified lavatory faucet.'"Miscellaneous Parts: 		spout - 101		aerator - 111Assembly: Handle assembly - 151Parts:	lever - 102		o-ring* - 103		elbow - 104		hub - 112Assembly: Drain assembly - 152Parts:	seat - 106		gasket - 105		o-ring* - 103		nut* - 107Assembly: Lift Rod assembly - 153Parts:	lift rod - 108		strap - 109			nut* - 107		pivot rod - 110	Assembly: Faucet assembly - 154Parts:	Drain assembly - 152		Lift rod assembly - 153		Handle assembly - 151		spout - 101		aerator - 111* denotes shared part"!testingDirectory	^'C:\MSTest\'! !!SetTestCase methodsFor: 'As yet unclassified'!setup    empty := Set new.    full := Set with: 5 with: #abc!testAdd    empty add: 5.    self should: [empty includes: 5]!testError    2 + 'abc'!testFailure    self should: [ false ]!testGrow    empty addAll: (1 to: 100).    self should: [empty size = 100]!testIllegal    self should: [[empty at: 5. false] on: self errorException do: [:ex | true]].    self should: [[empty at: 5 put: #abc. false] on: self errorException do: [:ex | true]]!testIncludes    self should: [full includes: 5].    self should: [full includes: #abc]!testOccurrences    self should: [(empty occurrencesOf: 0) = 0].    self should: [(full occurrencesOf: 5) = 1].    full add: 5.    self should: [(full occurrencesOf: 5) = 1]!testRemove    full remove: 5.    self should: [full includes: #abc].    self shouldnt: [full includes: 5]! !!SetTestCase class methodsFor: 'As yet unclassified'!comment^'This is an example of creating a special kind of test case.  See especiallysetUp, which creates the test data used by the various testing methods.Copyright (c) 1994, First Class Software, Inc.  All rights reserved.'!testCases    "Answer a collection of test cases for adding to a test suite."    ^OrderedCollection new        add: (self selector: #testAdd);        add: (self selector: #testRemove);        add: (self selector: #testIncludes);        add: (self selector: #testGrow);        add: (self selector: #testIllegal);        add: (self selector: #testOccurrences);        add: (self selector: #testError);        add: (self selector: #testFailure);        yourself! !!CompatibilityTesting methodsFor: 'As yet unclassified'!flavorCompatibilitySelectors	"Make sure the correct methods have been coded before we do any more testing."	^OrderedCollection new		add: #assert:;		add: #atPropertyNamed:for:put:;		add: #clone:;		add: #createDirectoryNamed:;		add: #createFileNamed:;		add: #doesFileExist:;		add: #doesDirectoryExist:;		add: #dumpObject:on:;		add: #dumpObject:toNewFile:;		add: #exceptionDetails:;		add: #exceptionReceiver:;		add: #filedSizeOf:;		add: #fileNameLike:;		add: #indexOfCollection:in:;		add: #isCollection:;		add: #isDictionary:;		add: #isStream:;		add: #isString:;		add: #issue;		add: #isSymbol:;		add: #loadObjectFrom:;		add: #loadObjectFromFileNamed:;		add: #lockNameForFile:;		add: #MinneStore;		add: #needsWork;		add: #nextWordOf:; 		add: #propertyNamed:for:;		add: #propertyNamed:for:ifAbsent:;		add: #propertyNamed:for:ifAbsentPut:;		add: #removeDirectoryNamed:ifAbsent:;		add: #removeFileNamed:;		add: #removeFileNamed:ifAbsent:;		add: #replaceAll:in:with:;		add: #testing;		add: #triggerEvent:for:;		add: #triggerEvent:for:with:;		add: #triggerEvent:for:with:with:;		add: #wait;		add: #waitFor:;		yourself.!propertyDict    "This method needed to use the property feature in the FlavorCompatibility class."    ^propertyDict!propertyDict: aDictionary    "This method needed to use the property feature in the FlavorCompatibility class."    propertyDict := aDictionary!stopOnCheckFailure	^true!stopOnError	^true!testDirectoryProtocol	"Test these methods 		#createDirectoryNamed:		#removeDirectoryNamed:ifAbsent:		#doesDirectoryExist:	"		| dir |	dir := 'c:\junk145\'.	self assertTrue: (FlavorCompatibility removeDirectoryNamed: dir ifAbsent: [false]) == false.	FlavorCompatibility createDirectoryNamed: dir.	self assertTrue: (FlavorCompatibility doesDirectoryExist: dir). 	FlavorCompatibility removeDirectoryNamed: dir ifAbsent: [nil].	self assertFalse: (FlavorCompatibility doesDirectoryExist: dir).!testEnsure    "Check Transcript to make sure this test completed successfully."    ExceptionCompatibility        during:            [Transcript cr; show: 'testEnsure...'.            self error: ' Close this window']        ensure: [Transcript show: 'completed successfully'].!testFileProtocol	"Test these methods 		#removeFileNamed:ifAbsent:		#createFileNamed:		#createLockFile:ifExists:		#doesFileExist:		#createLockFile:ifExists:		#removeFileNamed:		#fileNameLike:	"    | fileName file |    fileName := 'c:\test5.txt'.    FlavorCompatibility removeFileNamed: fileName ifAbsent: [].  "It may still be there"    FlavorCompatibility removeFileNamed: fileName ifAbsent: [].  "Remove something not there."    (FlavorCompatibility createFileNamed: fileName) close.  "create a file we know isn't there."    (FlavorCompatibility createFileNamed: fileName) close.  "create file over another w/o complaining."    FlavorCompatibility removeFileNamed: fileName ifAbsent: [].    self assertTrue: ((file := FlavorCompatibility createLockFile: fileName ifExists: ['okay']) == file).    	"Compatibility fail: this command will NOT WORK:	file close."	"Because file is a Filename and not a Stream. The workaround (returning a Stream) does not work because MinnieStore has a small bug: it doesn't close the stream, and so VW do not permit to delete it!!!!!!!!!!!!!!!! I do not modify the MunnieStore code, but the compatibility test. GG"    self assertTrue: (FlavorCompatibility doesFileExist: fileName).    self assertTrue: ((FlavorCompatibility createLockFile: fileName ifExists: ['okay']) = 'okay').    FlavorCompatibility removeFileNamed: fileName.    self assertFalse: ((FlavorCompatibility fileNameLike: 'HappyBirthday') includes: $. ).!testMethodExistence	"Make sure the correct methods have been coded before we do any more testing."	self assertTrue: (ExceptionCompatibility respondsTo: #anyError).	self assertTrue: (ExceptionCompatibility respondsTo: #DOInvalidVersionError).	self assertTrue: (ExceptionCompatibility respondsTo: #DOLockStuckError).	self assertTrue: (ExceptionCompatibility respondsTo: #MessageNotUnderstood).	self assertTrue: (ExceptionCompatibility respondsTo: #MSBranchAboutToMorph).	self assertTrue: (ExceptionCompatibility respondsTo: #MSDeletedLeafException).	self flavorCompatibilitySelectors 		do: [:each | self assertTrue: (FlavorCompatibility respondsTo: each)].	self log: 'testMethodExistence completed successfully'.!testNextWord	| stream oc word |	oc := OrderedCollection new.	stream := ReadStream on: '*)Now-is thetime for...'.	[(word := FlavorCompatibility nextWordOf: stream) notNil]		whileTrue: [oc add: word].	self assertTrue: (oc asArray = #('Now' 'is' 'the' 'time' 'for')).!testObjectFilerProtocol    | stream object1 object2 |    stream := ReadWriteStream on: (FlavorCompatibility aNewBinaryStreamableCollection: 50).    object1 := Array with: 1 with: 2.    FlavorCompatibility dumpObject: object1 on: stream.    object2 := FlavorCompatibility loadObjectFrom: stream.    self assertTrue: object1 = object2.    self assertTrue: object1 ~~ object2.    FlavorCompatibility dumpObject: object1 toNewFile: 'c:\test.obj'.    object2 := FlavorCompatibility loadObjectFromFileNamed: 'c:\test.obj'.    self assertTrue: object1 = object2.    self assertTrue: object1 ~~ object2.!testPass    "Check Transcript to make sure this test completed successfully."    ExceptionCompatibility    on: #testException    during:        [Transcript cr; show: 'testPass...'.        ExceptionCompatibility        on: #testException        during:            [ExceptionCompatibility signal: #testException.            Transcript show: 'Test failed.']        do: [:ex | ExceptionCompatibility pass: ex]        ]    do:        [:excp |        Transcript show: 'completed OK if nothing follows on this line.'.        ExceptionCompatibility return: excp].!testPropertyProtocol    "This method tests the property methods on FlavorCompatibility."    | obj |    obj := self class new.    self assertTrue: ((FlavorCompatibility propertyNamed: #test1 for: obj) isNil).    self assertTrue: ((FlavorCompatibility atPropertyNamed: #test1 for: obj put: 10) == obj).    self assertTrue: ((FlavorCompatibility propertyNamed: #test1 for: obj) == 10).    self assertTrue: ((FlavorCompatibility propertyNamed: #test2 for: obj ifAbsent: [3]) == 3).    self assertTrue: ((FlavorCompatibility propertyNamed: #test2 for: obj ifAbsentPut: [4]) == 4).    self assertTrue: ((FlavorCompatibility propertyNamed: #test2 for: obj) == 4).    self assertTrue: ((FlavorCompatibility propertyNamed: #test3 for: obj ifAbsentPut: [7+7]) == 14).    self assertTrue: ((FlavorCompatibility propertyNamed: #test3 for: obj) == 14).!testResume    "Check Transcript to make sure this test completed successfully."    ExceptionCompatibility        on: #testException        during:            [Transcript cr; show: 'testResume...'.            ExceptionCompatibility signal: #testException.            Transcript show: 'completed successfully']        do: [:excp| ExceptionCompatibility resume: excp].!testReturn    "Check Transcript to make sure this test completed successfully."    ExceptionCompatibility        on: #testException        during:            [Transcript cr; show: 'testReturn...'.            ExceptionCompatibility signal: #testException.            Transcript show: 'Did not complete successfully']        do: [:excp|            Transcript show: 'completed OK if nothing follows on this line.'.            ExceptionCompatibility return: excp].! !!CompatibilityTesting class methodsFor: 'As yet unclassified'!all	^OrderedCollection new		add: (self new selector: #testMethodExistence);		add: (self new selector: #testNextWord);		add: (self new selector: #testFileProtocol);		add: (self new selector: #testDirectoryProtocol);		add: (self new selector: #testObjectFilerProtocol);		add: (self new selector: #testPropertyProtocol);		add: (self new selector: #testResume);		add: (self new selector: #testReturn);		add: (self new selector: #testPass);		add: (self new selector: #testEnsure);  "This test must be last."		yourself.!CompatibilityTesting    "This is a dummy method for file-out purposes."! !!DOMultiUserPolicy methodsFor: 'As yet unclassified'!commitTransaction	"Save my changes and remove all of the locks I have placed."	super commitTransaction.	self removeLocks.!delete: aDOWrapper using: objectsPerFilePolicy	objectsPerFilePolicy deleteMultiUser: aDOWrapper!isLocked: fileNameString	"Answer a boolean"	^self lockedFiles includes: fileNameString!isMultiUser	^true!lockedFiles	"Private - Answer the set of file names that have been locked by me."	lockedFiles == nil		ifTrue: [lockedFiles := Set new: 10].	^lockedFiles!lockFileNamed: aString	"Set the lock on this file name string."	| lockName |	lockName := FlavorCompatibility lockNameForFile: aString.	(self lockedFiles includes: aString)		ifTrue: [^self].	self tryToLock: lockName times: 20.	self lockedFiles add: aString.!readFileNamed: aString	"If a transaction is going on, I need to lock the file anyways since I'll depend on it not changing."	self duringTransaction		ifTrue: [self lockFileNamed: aString].	^super readFileNamed: aString.!readForUpdate: aFullFileName	"Read anObject from aFullFileName.  This will lock this file until you store or commit it."	self lockFileNamed: aFullFileName.	^super readFileNamed: aFullFileName.!removeLocks	"Remove all locks that I have set.  I use a copy of the lockedFiles collection because	the #unlockFileNamed: method removes items from the unlockedFiles collection."	self lockedFiles copy 		do: [ :each | self unlockFileNamed: each.]!rollbackTransaction	"Remove all of the locks I have placed.  Since nothing is saved yet, I don't have to explicitly roll anything back.."	self duringTransaction		ifFalse: [self error: 'You must begin a transaction before rolling it back.'].	self removeLocks.	super rollbackTransaction.!store: fileContentsto: fileNameString    "Save anObject to fileNameString.  This method does no version checking."    self lockFileNamed: fileNameString.    super store: fileContents to: fileNameString.    self duringTransaction        ifFalse: [self unlockFileNamed: fileNameString].!tryToLock: aLockFileNametimes: anInteger	"Private - Set the lock on this file name string. Signal LockStuckError if I can't get it."	| i successful |	i := anInteger.	successful := true.	[i > 0] whileTrue: 			[successful := true.		FlavorCompatibility		createLockFile: aLockFileName		ifExists: 			[successful := false.			FlavorCompatibility waitFor: 500].		successful ifTrue: [^self].		i := i + -1].	self signalLockStuckError.!unlockFileNamed: aString	"Remove the lock on this file name string."	| lockName |	lockName := FlavorCompatibility lockNameForFile: aString.	FlavorCompatibility removeFileNamed: lockName.	self lockedFiles remove: aString.! !!DOMultiUserPolicy class methodsFor: 'As yet unclassified'!testMultiObjectsPerFile!testSingleObjectPerFile!testTheConcept1	"Test to see if my multi-user concurrency concept will even work.	Start this method on machine one.  Then start testTheConcept2 on machine two."	| me lockName |	lockName := 'K:\TEST.LOK'.	me := self new.	[FlavorCompatibility doesFileExist: lockName] 		whileFalse: [FlavorCompatibility wait].	self testTheConcept2.!testTheConcept2	"Start this method on machine two."	| me lockName |	lockName := 'K:\TEST.LOK'.	me := self new.	1 to: 10 do: 		[ :x |		me tryToLock: lockName times: 10.		Transcript nextPutAll: 'Set lock: '; nextPutAll: Time current asString; cr.		FlavorCompatibility wait; wait.		FlavorCompatibility removeFileNamed: lockName.		Transcript nextPutAll: 'Removed lock at: '; nextPutAll: Time current asString; cr.]! !!MSTreeHolder methodsFor: 'As yet unclassified'!addRedoBlock: aBlock	indexTreeChanges ~= nil		ifTrue: [indexTreeChanges add: aBlock].!addValue: aValueid: anInteger	"Public - Record this change and execute it."	self addRedoBlock: [self privateAddValue: aValue id: anInteger].	self privateAddValue: aValue id: anInteger.!allValues	"Answer all of the values that I index."	^self indexTree allValues!allValuesFor: idCollection	"Answer all of the values that I index."	^self indexTree allValuesFor: idCollection asSet !atMSText: aString remove: anId    "Private -"	FlavorCompatibility needsWork.	aString asMSText wordsDo: 		[ :eachWord | self removeValue: eachWord asLowercase id: anId ].!beforeStoring	indexTree := nil.!beginTransaction	indexTreePersistence beginTransaction.	self indexTree beginTransaction.	indexTreeChanges == nil		ifTrue: [indexTreeChanges := OrderedCollection new].!between: anObject1 and: anObject2    "Public - Answer a collection of ids that have values between    anObject1 and anObject2 (inclusive)."    | result anOC object1 object2 |    anObject1 isNil ifTrue: [ object1 := MSNilValue new]        ifFalse: [ object1 := anObject1 ].    anObject2 isNil ifTrue: [ object2 := MSNilValue new]        ifFalse: [ object2 := anObject2 ].    anOC := OrderedCollection new.    object1 > object2 ifTrue: [ ^anOC ].    result := self leafGreaterThanOrEqualTo: object1.    [ result isNil or: [result value > object2] ] whileFalse: [        anOC addAll: result ids.        result := self nextLeaf.].    ^anOC.!commitTransaction	self indexTree commitTransaction.	indexTree clearParent.	indexTreePersistence commitTransaction.	indexTree parent: self.	indexTreeChanges := nil.!domain: aClass    "Private - Setter.  A Domain must respond to the method #lowValue."	domain := aClass.!equals: aValue	"Public -    Answer a collection of object ids that have this key value."	| leaf value ids anOC |	aValue isCollectionOtherThanString		ifTrue:			[anOC := OrderedCollection new.			aValue do:[:each | anOC addAll: (self equals: each)].			^anOC].	aValue isNil		ifTrue: [value := MSNilValue new]		ifFalse: [value := aValue].	leaf := self indexTree leafEqualTo: value.	ids := (leaf == nil		ifTrue: [OrderedCollection new]		ifFalse: [leaf ids asOrderedCollection]).	lastLeafValueFound := "Set the last leaf value found instance variable."		(leaf == nil			ifTrue: [nil]			ifFalse: [leaf value]).	^ids.!firstLeaf	"Answer the first (lowest value) leaf in my indexTree."	| leaf |	leaf := self indexTree firstLeaf.	lastLeafValueFound :=		(leaf == nil			ifTrue: [nil]			ifFalse: [leaf value]).	^leaf.!getter    "Answer the getter method to use to get the value used in this index."    ^getter!getter: aSymbol    "Public - set the getter method that answers the value used by this index."    getter := aSymbol!greaterThan: anObject	"Public - Answer a collection of ids that have key values    greater than anObject."	| result anOC object |	anObject isNil		ifTrue: [object := MSNilValue new]		ifFalse: [object := anObject].	result := self leafGreaterThan: object.	anOC := OrderedCollection new.	[result isNil]		whileFalse:			[anOC addAll: result ids.			result := self nextLeaf.			].	^anOC.!greaterThanOrEqualTo: anObject	"Public - Answer a collection of ids that have key values    greater than or equal to anObject."	| result anOC object |	anObject isNil		ifTrue: [object := MSNilValue new]		ifFalse: [object := anObject].	result := self leafGreaterThanOrEqualTo: object.	anOC := OrderedCollection new.	[result isNil]		whileFalse:			[anOC addAll: result ids.			result := self nextLeaf.			].	^anOC.!hasAllWords: aStringOrArrayOfStrings    "Public - Answer a collection of ids that have all the words in anArrayOfStrings."    | mainColl subColl arrayOfStrings |    (domain == MSText or: [MSText subclasses includes: domain])        ifFalse: [self error: 'Use #where:hasAllWords: method only on an MSText index'].    ((FlavorCompatibility isString: aStringOrArrayOfStrings) or: [aStringOrArrayOfStrings isMSText])        ifTrue: [arrayOfStrings := aStringOrArrayOfStrings asMSText words]        ifFalse: [arrayOfStrings := aStringOrArrayOfStrings].    (FlavorCompatibility isCollection: arrayOfStrings)        ifFalse: [^self error: 'Invalid collection parameter: ' , arrayOfStrings printString].    mainColl := OrderedCollection new.    arrayOfStrings        do:            [:eachWord |            (FlavorCompatibility isString: eachWord)                ifFalse: [^self error: 'Invalid String parameter: ' , eachWord printString].            mainColl isEmpty "true on first time thru"                ifTrue:                    [subColl := mainColl := self startsWith: eachWord asLowercase]                ifFalse:                    [subColl := self startsWith: eachWord asLowercase.                    mainColl := mainColl intersectionOf: subColl].            mainColl isEmpty                ifTrue: [^mainColl].            ].    ^mainColl.!hasSomeWords: aStringOrArrayOfStrings    "Public - Answer a collection of ids that have at least one of the    words in aStringOrArrayOfStrings.  Ids will be sorted by descending    number of words matched."    | bag result numWordsFound max arrayOfStrings |    (domain == MSText or: [MSText subclasses includes: domain])        ifFalse: [self error: 'Use #where:hasSomeWords: method only on an MSText index'].    ((FlavorCompatibility isString: aStringOrArrayOfStrings) or: [aStringOrArrayOfStrings isMSText])        ifTrue: [arrayOfStrings := aStringOrArrayOfStrings asMSText words] "change string to an array of words"        ifFalse: [arrayOfStrings := aStringOrArrayOfStrings].    (FlavorCompatibility isCollection: arrayOfStrings)        ifFalse: [^self error: 'Invalid collection parameter: ' , arrayOfStrings printString].    bag := Bag new.    numWordsFound := 0.    arrayOfStrings        do:            [:eachWord |            (FlavorCompatibility isString: eachWord)                ifFalse: [^self error: 'Invalid String parameter: ' , eachWord printString].            (result := self startsWith: eachWord asLowercase) isEmpty                ifFalse:                    [numWordsFound := numWordsFound + 1.                    bag addAll: result.                    ].            ].    ^bag asArrayByDescendingOccurrences.!includes: aString    "Public - Answer a collection of ids that have values including aString.    The whole index must be searched to find these."    | result anOC |    (domain == String or: [ String subclasses includes: domain ])        ifFalse: [self error: 'Use #where:includes: method only on a string index' ].    (FlavorCompatibility isString: aString) ifFalse: [ ^self error: 'Invalid string parameter:', aString printString ].    result := self firstLeaf.    anOC := OrderedCollection new.    [ result isNil ] whileFalse: [        (result value indexOfString: aString) > 0            ifTrue: [ anOC addAll: result ids ].        result := self nextLeaf.].    ^anOC.!indexTree	indexTree == nil		ifTrue: [self readIndexTree].	^indexTree.!indexTree: aTreeHolderOrBranch	indexTree := aTreeHolderOrBranch.!initialize	"Initialize my instance variables."	indexTree := MSBranch newOn: path parent: self.	indexTreePersistence := DOSingleObjectService perform: self persistenceCreationMethod with: (path, self persistenceTreeFileName).	self saveIndexTree.!isMSTreeHolder	^true!leafGreaterThan: anObject    "Private - Answer an MSLeaf greater than anObject.		If none is found, answer nil."	| leaf |	leaf := self indexTree leafGreaterThan: anObject.	lastLeafValueFound :=		(leaf == nil			ifTrue: [nil]			ifFalse: [leaf value]).	^leaf.!leafGreaterThanOrEqualTo: anObject    "Private - Answer an MSLeaf greater than or equal to anObject.		If none is found, answer nil."	| leaf |	leaf := self indexTree leafGreaterThanOrEqualTo: anObject.	lastLeafValueFound :=		(leaf == nil			ifTrue: [nil]			ifFalse: [leaf value]).	^leaf.!lessThan: anObject    "Public - Answer a collection of ids that have values    greater than anObject."    | result anOC object |    anObject isNil ifTrue: [ ^Array new ]. "Nothing less than nil"    result := self firstLeaf.    anOC := OrderedCollection new.    [ result isNil ] whileFalse: [        result value >= anObject ifTrue: [ ^anOC ].        anOC addAll: result ids.        result := self nextLeaf.].    ^anOC.!lessThanOrEqualTo: anObject    "Public - Answer a collection of ids that have key values    greater than anObject."    | result anOC |    anObject isNil ifTrue: [ ^self equals: nil ].  "Nothing is less than nil"    result := self firstLeaf.    anOC := OrderedCollection new.    [ result isNil ] whileFalse: [        result value > anObject ifTrue: [ ^anOC ].        anOC addAll: result ids.        result := self nextLeaf.].    ^anOC.!maximumLeavesPerBranch	^maximumLeavesPerBranch!maximumLeavesPerBranch: anInteger	"Set the maximum number of leaves allowed in a single branch before splitting.	Push this info down to the branches."	maximumLeavesPerBranch := anInteger.!name    "Answer the name of the index I hold."    ^name!name: aSymbol    "Public - setter"    name := aSymbol.!newPath: aString	"Used when a database has been opened in a new directory."	self path: aString.	indexTreePersistence pathName: path.FlavorCompatibility testing.	FlavorCompatibility assert: (indexTree isNil).	indexTree := indexTreePersistence readForUpdate.	indexTree parent: self.	indexTree newPath: aString.	self saveIndexTree.!nextLeaf	"Answer the next leaf after the last leaf found."	lastLeafValueFound == nil		ifTrue: [^nil].	^self leafGreaterThan: lastLeafValueFound.	!owner: anMSObjectSet	owner := anMSObjectSet!path	"Answer my path name."	^path!path: aString	"Set the path instance variable."	path := (aString last = FlavorCompatibility directoryDelimiter)		ifTrue: [aString]		ifFalse: [aString , FlavorCompatibility directoryDelimiterString].	!persistenceCreationMethod	persistenceCreationMethod == nil		ifTrue: [persistenceCreationMethod := owner persistenceCreationMethod].	^persistenceCreationMethod.!persistenceTreeFileName	^'Tree.obj'.!printOn: aStream    super printOn: aStream.    aStream        nextPut: $( ;        print: self name ;        nextPut: $) .!private2AddValue: aValueid: anInteger	"Private - This method is used by privateAddValue:id:"	ExceptionCompatibility		on: #MSBranchAboutToMorph		during: [^self indexTree addLeafValue: aValue id: anInteger]		do: 			[:exception |			ExceptionCompatibility				on: #DOInvalidVersionError				during: [indexTreePersistence lock: indexTree]				do: [ :error | self reapplyChanges.  ExceptionCompatibility return: error].			ExceptionCompatibility resume: exception. "The locking was successful"			]!private2RemoveValue: aValueid: anInteger	"Private - pass this message on to my indexTree."	^self indexTree removeLeafValue: aValue id: anInteger.!privateAddValue: aValueid: anInteger	"Private - Do some MSText testing and call private2AddValue:id:"	| value |	aValue isNil		ifTrue:			[value := MSNilValue new]		ifFalse:			[value := aValue.			domain == MSText				ifTrue:					[^value asMSText						wordsDo:							[:each | self private2AddValue: each id: anInteger].].			].	self private2AddValue: value id: anInteger.	!privateRemoveValue: aValueid: anInteger	"Private - Do some MSText testing and call private2RemoveValue:id:"	| value |	aValue isNil		ifTrue: [value := MSNilValue new]		ifFalse:			[value := aValue.			domain == MSText				ifTrue:					[^value asMSText						wordsDo:							[:each | self private2RemoveValue: each id: anInteger].].			].	^self private2RemoveValue: value id: anInteger.!readIndexTree	indexTree := indexTreePersistence read.	indexTree parent: self.!reapplyChanges	"Re-read my index and reapply all the changes since the beginning of the transaction."	"Assumption: This will be a read for update because we'll be inside a transaction."	self readIndexTree.	indexTreeChanges		do: [:each | each value].!removeValue: aValue id: anInteger	"Public - pass this message on to my indexTree."		| value |"	value := aValue isNil ifTrue: [MSNilValue new] ifFalse: [aValue].  line added 1998-02-17"	self addRedoBlock: [self privateRemoveValue: aValue id: anInteger].	self privateRemoveValue: aValue id: anInteger.!replace: aBranch with: aTrunk	"Used by anMSBranch when it morphs into a trunk"	indexTree := aTrunk!rollbackTransaction	self indexTree rollbackTransaction.	indexTreePersistence rollbackTransaction.	indexTreeChanges := nil.!saveIndexTree	"Save my index tree to disk."	indexTree beforeStoring.	indexTreePersistence specialStore: indexTree.	indexTree parent: self.!setter    "Answer the setter method to use to get the value used in this index."    ^setter!setter: aSymbol    "Public - set the setter method that answers the value used by this index."    setter := aSymbol!startsWith: aString    "Public - Answer a collection of ids that have values starting with aString."    | result anOC |    (domain == String or: [ domain == MSText ])        ifFalse: [ self error: 'Use #where:startsWith: method only on a string index' ].    (FlavorCompatibility isString: aString) ifFalse: [ ^self error: 'Invalid string parameter:', aString printString ].    result := self leafGreaterThanOrEqualTo: aString.    anOC := OrderedCollection new.    [ result isNil ] whileFalse: [        (result value startsWith: aString)            ifTrue: [ anOC addAll: result ids ]            ifFalse: [ ^anOC ].        result := self nextLeaf.].    ^anOC.! !!MSTreeHolder class methodsFor: 'As yet unclassified'!Comment^'Instances of this class hold an index tree for Smalltalk objects.  Think of this index tree as an index on a column in a relational table.	Each table row represents an object instance.Each table column represents an aspect or attribute of that object.Index tree locking strategy:1) IndexTree (Trunks & Branches) are stored together in one file.      Each Leaves collection is stored in its own file.2) The tree is not usually locked when updating leaves.    Assume only the leaves need updating.3) If #DOInvalidVersionError is signaled when saving the leaves, then... (see MSBranch>>addLeaf:id:)	a) If the leaves were deleted, lock indexTree, read it, and redo every leaf add since last commit.	    (deleted leaves mean that a branch has been split into a trunk by someone else).	b) If leaves just changed, reload leaves and add.'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!newOn: aPathName owner: anMSObjectSet    "Public - Answer a new instance of myself with path    set to aString."    ^(self basicNew)		path: aPathName;		owner: anMSObjectSet;		maximumLeavesPerBranch: anMSObjectSet maximumLeavesPerBranch;		initialize;		yourself.!test	| path tmp |	path := 'C:\JUNK'.	DOService initializeTestPath: path.	tmp := (self newOn: path)		addValue: 'Hi' id: 5;		addValue: 'bye' id: 9;		addValue: 'cu' id: 10;		addValue: 'pow-wow' id: 11;		addValue: 'jon' id: 31;		addValue: 'deb' id: 32;		addValue: 'kris' id: 28;		addValue: 'paul' id: 60;		addValue: 'rosalie' id: 54;		yourself.	^tmp! !!MSNilValue methodsFor: 'As yet unclassified'!< anObject	^(self >= anObject) not!<= anObject	^true!= anObject		^self class == anObject class!> anObject    ^(self <= anObject) not!>= anObject    ^self = anObject!compareGreaterThan: anInteger	"Needed by VisualAge Smalltalk only (as far as I know)."	^false.!greaterThanInteger: anInteger	"Needed by Dolphin, but kept in MinneStore package because of cyclical prerequisites."	^false.!isMSNilValue	^true!lessFromInteger: aInteger	"Needed by VW 	GG PATCH	Is less? Oh yes I hope but is right?....."	^false! !!MSNilValue class methodsFor: 'As yet unclassified'!Comment	^'Instances of this class replace nil values when creating indexes.'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!MSMultiObjectReadProxy methodsFor: 'As yet unclassified'!asMSStorageProxy	^MSMultiObjectStorageProxy new		ids: ids;		objectSetName: objectSet name;		yourself.!getRealObject	realObject := objectSet readForIds: ids.	super getRealObject.!ids	^ids!ids: aCollection	ids := aCollection! !!MSMultiObjectReadProxy class methodsFor: 'As yet unclassified'!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."! !!DOTestObject methodsFor: 'As yet unclassified'!= anObject    self class == anObject class        ifFalse: [^false].    self name = anObject name        ifFalse: [^false].    self age = anObject age        ifFalse: [^false].    (FlavorCompatibility propertyNamed: #DOId for: self) == (FlavorCompatibility propertyNamed: #DOId for: anObject)		ifFalse: [^false].    (FlavorCompatibility propertyNamed: #DOVersion for: self) == (FlavorCompatibility propertyNamed: #DOVersion for: anObject)		ifFalse: [^false].    ^true.!age    ^age!age: anInteger    age := anInteger!name    ^name!name: aString    name := aString!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: 'name: ';		print: name;		nextPutAll: ' age: ';		print: age;		nextPutAll: ' id: ';		print: (FlavorCompatibility propertyNamed: #DOId for: self);		nextPutAll: ' version: ';		print: (FlavorCompatibility propertyNamed: #DOVersion for: self);		nextPut: $);		yourself!propertyDict    "This is needed for Smalltalk Express and other    flavors that do not natively support 'properties'."    ^propertyDict!propertyDict: aDictionary    "This is needed for Smalltalk Express and other    flavors that do not natively support 'properties'."    propertyDict := aDictionary! !!DOTestObject class methodsFor: 'As yet unclassified'!BlaisePascal    ^self new        name: 'Blaise Pascal';        age: 63;        yourself.!CharlesWilliams    ^self new        name: 'Charles Williams';        age: 55;        yourself.!CSLewis    ^self new        name: 'C.S. Lewis';        age: 63;        yourself.!DietrichBonhoeffer    ^self new        name: 'Dietrich Bonhoeffer';        age: 41;        yourself.!FrederickBuechner    ^self new        name: 'Frederick Buechner';        age: 57;        yourself.!GeorgeMacDonald    ^self new        name: 'George MacDonald';	age: nil;        yourself.!GrahamGreene    ^self new        name: 'Graham Greene';        age: 80;        yourself.!JohnSteinbeck    ^self new        name: 'John Steinbeck';        age: 66;        yourself.!JRRTolkien    ^self new        name: 'J.R.R. Tolkien';        age: 72;        yourself.!name: aString age: anInteger	^self new		name: aString;		age: anInteger.! !!MSBranch methodsFor: 'As yet unclassified'!addLeafValue: anObjectid: anInteger	"Add this leaf value/id combo to my leaves.  This is the only method leaves are to be added with."	| existingLeaf |	existingLeaf := self leafEqualTo: anObject.	(existingLeaf == nil)		ifTrue:			[self leaves add: (MSLeaf newValue: anObject id: anInteger).			(self leaves size >= maximumLeavesPerBranch)				ifTrue: [^self morphIntoATrunk]]		ifFalse:			[existingLeaf addId: anInteger].	ExceptionCompatibility	on: #DOInvalidVersionError	during: [self saveLeaves]	do:	[:exception |		(FlavorCompatibility exceptionDetails: exception) isDODeletedObject			ifTrue: [parent reapplyChanges.  "The indexTree has changed. Start over."]			ifFalse: 				[leaves := nil.				self addLeafValue: anObject id: anInteger].		ExceptionCompatibility return: exception.		].!addLeavesTo: aCollection	"Add all my leaves to a collection."	aCollection addAll: self leaves!addValuesFor: idSet to: aCollection	"Add the values of all leaves that have an id in idSet to aCollection"	self leaves do:		[:each |		(each ids detect: [:eachID | idSet includes: eachID] ifNone: [nil]) notNil			ifTrue: [aCollection add: (each value isMSNilValue ifTrue: [nil] ifFalse: [each value])].		].	^aCollection.!addValuesTo: aCollection	"Add all my leaves to a collection."	aCollection addAll: 		(self leaves collect: 			[:each | each value isMSNilValue ifTrue: [nil] ifFalse: [each value]]		).!asLeftBranch	"Answer the left half of my leaves."	| leftLeaves branch |	leftLeaves := (self leaves copyFrom: 1 to: (leaves size // 2)).	branch := self class new leaves: leftLeaves.	branch maximumValue: (leftLeaves last value).	branch leafPersistence: leafPersistence.	branch maximumLeavesPerBranch: self maximumLeavesPerBranch.	^branch!asRightBranch	"Answer the right half of my leaves."	| rightLeaves branch size |	size := self leaves size.	rightLeaves := leaves copyFrom: (size // 2) + 1 to: size.	branch := self class new leaves: rightLeaves.	branch maximumValue: maximumValue.	branch leafPersistence: leafPersistence.	branch maximumLeavesPerBranch: self maximumLeavesPerBranch.	^branch!beforeStoring	"Wipe out any reference to my tree holder and leaves."	parent isMSTreeHolder		ifTrue: [self clearParent].	leavesFileId isNil		ifTrue: [self saveLeaves].	leaves := nil.!beginTransaction	"Tell leafPersistence to begin the transaction."	leafPersistence beginTransaction.!clearParent	self parent: nil.!commitTransaction	"Tell leafPersistence to commit the transaction."	leafPersistence commitTransaction.!firstBranch	"Answer the first branch in my tree."	^self!firstLeaf	"Answer the very first (lowest value) leaf that I hold."	self leaves isEmpty		ifTrue: [^nil].	^self leaves first!gtBinarySearchFor: anObject		"value - can be either string or integer"between: integer1				"integer1 must be less than integer2"and: integer2	"Private -  Answer a leaf.  Binary search myself for a leaf with the next greater value."	| mid midValue |	integer2 < integer1 ifTrue: [ ^nil ].	(integer2 - integer1) < 2 ifTrue: [		(self object: anObject isLT: (self leaves at: integer1) value)		"This line is different from #gteBinary..."			ifTrue: [ ^(leaves at: integer1) ].		(self object: anObject isGTE: (self leaves at: integer2) value)   "This line is different from #gteBinary..."			ifTrue: [ ^nil ].  "There are none greater"		^(self leaves at: integer2) ].	mid := (integer1 + integer2) // 2.	(self object: anObject isLT: (midValue := (self leaves at: mid) value))		ifTrue: [ ^self gtBinarySearchFor: anObject between: integer1 and: mid ].	(self object: anObject isGTE: midValue)									"This line is different from #gteBinary..."		ifTrue: [ ^self gtBinarySearchFor: anObject between: mid+1 and: integer2 ].	" It matches exactly "	^(self leaves at: mid).	!gteBinarySearchFor: anObject		"value - can be either string or integer"between: integer1				"integer1 must be less than integer2"and: integer2	"Private -  Answer a leaf.  Binary search myself for a leaf with the next greater or equal value."	| mid midValue |	integer2 < integer1 ifTrue: [ ^nil ].	(integer2 - integer1) < 2 ifTrue: [		(self object: anObject isLTE: (self leaves at: integer1) value)	"This line is different from #gtBinary..."			ifTrue: [ ^(leaves at: integer1) ].		(self object: anObject isGT: (self leaves at: integer2) value)   "This line is different from #gtBinary..."			ifTrue: [ ^nil ].  "There are none greater"		^(self leaves at: integer2) ].	mid := (integer1 + integer2) // 2.	(self object:anObject isLT: (midValue := (self leaves at: mid) value))		ifTrue: [ ^self gteBinarySearchFor: anObject between: integer1 and: mid ].	(self object: anObject isGT: midValue)				"This line is different from #gtBinary..."		ifTrue: [ ^self gteBinarySearchFor: anObject between: mid+1 and: integer2 ].	"It matches exactly"	^(self leaves at: mid).	!initialize	leaves := #new.!isEmpty	"Answer true or false.  If I hold no leaves, answer true."	^self leaves isEmpty!leafEqualTo: anObject	"Answer a leaf that is = an Object."	| leaf |	leaf := self 		gteBinarySearchFor: anObject 		between: 1 		and: self leaves size.	leaf == nil 		ifTrue: [^nil].	leaf value = anObject		ifTrue: [^leaf].	^nil.!leafGreaterThan: anObject	"Answer a leaf that is > an Object."	^self 		gtBinarySearchFor: anObject 		between: 1 		and: self leaves size.!leafGreaterThanOrEqualTo: anObject	"Answer a leaf that is >= an Object."	^self 		gteBinarySearchFor: anObject 		between: 1 		and: self leaves size.!leafPersistence: aDOManager	"Set the leafPersistence instance variable."	leafPersistence := aDOManager!leaves	"Answer a sorted collection of leaves."	| deleted |	deleted := false.	leaves == #new		ifTrue: [leaves := SortedCollection new].	leaves == nil ifTrue: 		[leaves := leafPersistence readId: leavesFileId.		leaves isDODeletedObject ifTrue: [ExceptionCompatibility signal: #MSDeletedLeafException]].	^leaves!leaves: aSortedCollection	"Set the maximumValue instance variable."	leaves := aSortedCollection.!maximumLeavesPerBranch	^maximumLeavesPerBranch!maximumLeavesPerBranch: anInteger	"Set the maximum number of leaves allowed in a single branch before splitting."	maximumLeavesPerBranch := anInteger!maximumValue	"Answer the maximumValue instance variable."	^maximumValue!maximumValue: anObject	"Set the maximumValue instance variable."	maximumValue := anObject!morphIntoATrunk	"Morph myself into a trunk with my leaves split between its two branches."	| trunk |	ExceptionCompatibility signal: #MSBranchAboutToMorph.	leavesFileId ~~ nil  "If my leaves have been saved to disk before."		ifTrue: [leafPersistence delete: leaves. "next comment is wrong." "DOObjectIsDeletedError if leaves have already been been deleted."]		ifFalse: [FlavorCompatibility testing. self error: 'Oops, I guess this does happen'].	trunk := (MSTrunk newOn: self parent: parent).	trunk saveLeaves.	parent replace: self with: trunk.	parent saveIndexTree.  "The tree has changed, so store it."!newPath: aString	"Used when a database has been opened in a new directory."	leafPersistence pathName: aString!object: object1 isGT: object2	"Answer true if object1 is greater than object2.	I had to implement these methods because most things don't 'compare' with MSNilValue	while MSNilValue compares with everything."	^object1 isMSNilValue		ifTrue: [object1>object2]		ifFalse: [object2<object1].!object: object1 isGTE: object2	"Answer true if object1 is greater than or equal to object2.	I had to implement these methods because most things don't 'compare' with MSNilValue	while MSNilValue compares with everything."	^object1 isMSNilValue		ifTrue: [object1>=object2]		ifFalse: [object2<=object1].!object: object1 isLT: object2	"Answer true if object1 is less than object2.	I had to implement these methods because most things don't 'compare' with MSNilValue	while MSNilValue compares with everything."	^object1 isMSNilValue		ifTrue: [object1<object2]		ifFalse: [object2>object1].!object: object1 isLTE: object2	"Answer true if object1 is less than or equal to object2.	I had to implement these methods because most things don't 'compare' with MSNilValue	while MSNilValue compares with everything."	^object1 isMSNilValue		ifTrue: [object1<=object2]		ifFalse: [object2>=object1].!parent: aTreeHolderOrTrunk	"Set the instance variable."	parent := aTreeHolderOrTrunk!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: 'maxValue: ';		print: maximumValue;		nextPut: $).!removeLeafValue: anObjectid: anInteger	"Add this leaf value/id combo to my leaves.  This is the only method leaves are to be added with."	| existingLeaf |	existingLeaf := self leafEqualTo: anObject.	(existingLeaf == nil)		ifFalse:			[existingLeaf removeId: anInteger.			existingLeaf isEmpty				ifTrue: [self leaves remove: existingLeaf]].	ExceptionCompatibility		on: #DOInvalidVersionError		during: [self saveLeaves]		do:	[leaves := nil.			self removeLeafValue: anObject id: anInteger].	!rollbackTransaction	"Tell leafPersistence to rollback the transaction."	leafPersistence rollbackTransaction.!saveLeaves	"Save my leaves to disk."	leafPersistence store: self leaves.	leavesFileId == nil		ifTrue: [leavesFileId := leafPersistence idFor: self leaves].	! !!MSBranch class methodsFor: 'As yet unclassified'!Comment"	Branches hold Leaves.	Branches are held by a Trunk or a TreeHolder.."!constructEventsTriggered        "Private - answer the set of events that instances of the        receiver can trigger."    ^super constructEventsTriggered		add: #aboutToMorph;		yourself.!Copyright	"Copyright (c) 1997,1998  Jonathan A. Carlson."!newOn: aPathName parent: aTreeHolder	"This will be used when creating the first branch in a new tree."	self initializePath: aPathName.	^self new		parent: aTreeHolder;		maximumLeavesPerBranch: aTreeHolder maximumLeavesPerBranch;		maximumValue: MSHighValue new;		leafPersistence:			(DOMultiObjectService newMultiUser				fileNamePattern: 'INDX9999.OBJ';				pathName: aPathName;				yourself);		yourself.!test1	self testExample.		self testExample allLeaves.		self testExample leafGreaterThanOrEqualTo: 'Renee'.	!testExample	"Answer a small index tree for testing."	^(self newOn: 'C:\HI')		addLeafValue: 'Jonathan' id: 31;		addLeafValue: 'Debra' id: 32;		addLeafValue: 'Diane' id: 34;		addLeafValue: 'Dan' id: 30;		addLeafValue: 'Doug' id: 35;		addLeafValue: 'Kristen' id: 28;		addLeafValue: 'Renee' id: 29;		addLeafValue: 'Andrea' id: 23;		addLeafValue: 'Bret' id: 37;		addLeafValue: 'Craig' id: 29;		addLeafValue: 'Casper' id: 33;		addLeafValue: 'Ronald' id: 54;		addLeafValue: 'David' id: 36;		yourself.! !!DOSingleObjectPerFilePolicy methodsFor: 'As yet unclassified'!delete: aWrapper	| wrapper array |	wrapper := self readIdForUpdate: aWrapper id.	aWrapper compareVersionWith: wrapper.	array := wrapper asDeletedObjectArray.	self userPolicy store: array to: (self fullFileNameForId: aWrapper id).	^DODeletedObject fromArray: array.!fileNumberForId: anInteger	^anInteger!fullFileNameForId: anInteger	"Answer the full file name for anObject."	| fileName |	fileName := 		FlavorCompatibility			replaceAll: '9999' 			in: manager fileNamePattern 			with: (anInteger asZeroFilledString: 4).	^manager pathName, fileName.!readAll	"Answer a collection of wrappers."	| result oc |	oc := OrderedCollection new.	1 to: manager lastId do:		[ :id | 		result := self readId: id.		result isDODeletedObject ifFalse: [oc add: result].		].	^oc.!readFileNumber: anInteger	"Answer a collection."	| result wrapper |	wrapper := self readId: anInteger.	result := wrapper isNil		ifTrue: [nil]		ifFalse: [wrapper object].	^Array with: result.!readForUpdate: fileName	"Delegate to my userPolicy."	^self userPolicy readForUpdate: fileName!readId: anInteger	| result |	result := self userPolicy readFileNamed: (self fullFileNameForId: anInteger).	^DOWrapper fromArray: result.!readIdForUpdate: anInteger	| result |	result := self userPolicy readForUpdate: (self fullFileNameForId: anInteger).	^DOWrapper fromArray: result.!store: aDOWrapper	"Check object version before storing."	| id |	id := aDOWrapper id.	aDOWrapper compareVersionWith: (self readIdForUpdate: id).	self userPolicy addRollbackBlock: aDOWrapper rollbackBlock.	self userPolicy store: aDOWrapper asArray to: (self fullFileNameForId: id).! !!MSTestClasses methodsFor: 'As yet unclassified'!description	^description!description: aString	description := aString!name	^name!name: aString	name := aString!number	^number!number: anInteger	number := anInteger!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $( ;		print: name ;		space;		print: number;		nextPut: $).! !!MSTestClasses class methodsFor: 'As yet unclassified'!name: aString number: anInteger	^self new		name: aString;		number: anInteger! !!Assembly methodsFor: 'As yet unclassified'!addAssembly: anAssembly	^self assemblies add: anAssembly!addPart: aPart	^self parts add: aPart!assemblies	assemblies isNil		ifTrue: [assemblies := OrderedCollection new].	^assemblies.!assemblies: anOrderedCollection	assemblies := anOrderedCollection.!displayOn: aStream	aStream		print: name		print: ' assembly'.!parts	parts isNil		ifTrue: [parts := OrderedCollection new].	^parts.!parts: anOrderedCollection	parts := anOrderedCollection.! !!Part methodsFor: 'As yet unclassified'!displayOn: aStream	aStream print: name.! !!Collection methodsFor: 'MinnieStore'!uniqueUnionOf: aCollection	"Answer the union of unique elements of myself and aCollection."	| anOC |	FlavorCompatibility MinneStore.	anOC := self asOrderedCollection.	aCollection do: [ :each |		(self includes: each)			ifFalse: [ anOC add: each ] ].	^anOC.! !!UndefinedObject methodsForUndefined: 'As yet unclassified'!unboundMethod	"	***This is decompiled code.*** 	This may reflect a problem with the configuration of your image 	and its sources and changes files. 	Please refer to the documentation and the settings tool for help in 	setting up the proper source code files."	^Object		subclass: #MSReadProxy		instanceVariableNames: 'objectSet realObject'		classVariableNames: ''		poolDictionaries: ''		category: 'MinneStore'! !!Object methodsFor: 'MinnieStoneExtension'!isMSReadProxy	"Answer false"	FlavorCompatibility MinneStore.	^false! !!String methodsFor: 'MinnieStore'!isCollectionOtherThanString	"Answer true if receiver is an instance of class Collection	or one of its subclasses other than String, else answer false."	FlavorCompatibility MinneStore.	^false! !!Object class methodsFor: 'MinnieStoneGGExtension'!initPropertyEngine	Transcript cr; show:' Cleaning MinnieStorePropertyDB...';cr.	"This code is strange but i cannot avoid it!!!!"	Smalltalk at:#MinneStorePropertyDB   put: (WeakDictionary new: 90).! !!Object methodsFor: 'MinnieStoneExtension'!isMSNilValue	"Answer false."	FlavorCompatibility MinneStore.	^false! !!Collection methodsFor: 'MinnieStore'!doesNotInclude: anObject        "Answer true if the receiver contains an         element equal to anObject, else answer false."	FlavorCompatibility MinneStore.	^(self includes: anObject) not! !!Object methodsFor: 'MinnieStoneExtension'!propertyAt: aSymbol 	"Non sicuto che funzioni al 100%"	"Transcript show: ('Requested propertyAt: of a ', self printString) ; cr."	"By GG"	MinneStorePropertyDB at: (self) ifAbsent: [ ^nil].	(MinneStorePropertyDB at: self) at: aSymbol  ifAbsent: [ ^nil].	^((MinneStorePropertyDB at: self) at: aSymbol ).! !!Collection methodsFor: 'MinnieStore'!max	"Answer the largest element in this collection."	| max |	FlavorCompatibility MinneStore.	self isEmpty ifTrue: [ ^nil ].	max := self first.	self do: [ :each | 		each > max ifTrue: [ max := each ] ].	^max.! !!Object methodsFor: 'MinnieStoneExtension'!isMSObjectSet	"Answer false"	FlavorCompatibility MinneStore.	^false! !!Integer methodsFor: 'MinnieStore'!asZeroFilledString: stringSize	| result zeros |	FlavorCompatibility MinneStore.	result := self printString.	result size > stringSize		ifTrue: [self error: result, ' is too large'].	result size == stringSize		ifTrue: [^result].	zeros := (String new: stringSize - result size).	1 to: zeros size do: [:i | zeros at: i put: $0].	^zeros, result.! !!Collection methodsFor: 'MinnieStore'!asArrayCollect: aBlock        "Answer an Array containing all the elements of the receiver."	| answer index |	FlavorCompatibility MinneStore.  "Created for efficiency"	answer := Array new: self size.	index := 1.	self do: 		[ :element |		answer at: index put: (aBlock value: element).		index := index + 1].	^answer! !!Object methodsFor: 'MinnieStoneExtension'!isMSText	"Answer false."	FlavorCompatibility MinneStore.	^false!isCollectionOtherThanString	"Answer true if receiver is an instance of class Collection	or one of its subclasses other than String, else answer false."	FlavorCompatibility MinneStore.	^false! !!Collection methodsFor: 'MinnieStore'!isCollectionOtherThanString	"Answer true if receiver is an instance of class Collection	or one of its subclasses other than String, else answer false."	FlavorCompatibility MinneStore.	^true! !!Object methodsFor: 'MinnieStoneExtension'!isDOService	FlavorCompatibility MinneStore.	^false! !!WriteStream methodsFor: 'As yet unclassified'!print: anObject	#MinneStoreCompatibility.	anObject printOn: self.! !!Stream methodsFor: 'As yet unclassified'!skipWhile: aOneArgumentBlock	| c |	#MinneStoreCompatibility.	[self atEnd]		whileFalse:			[c := self peek.			(aOneArgumentBlock value: c)				ifTrue: [self next]				ifFalse: [^self]]! !!Collection methodsFor: 'MinnieStore'!isCollection	"Answers true. Needed by MinnieStore, added by 	GG"	^true! !!Object methodsFor: 'MinnieStoneExtension'!assert: aBlock	^aBlock value.!isMSStorageProxy	"Answer false"	FlavorCompatibility MinneStore.	^false! !!String methodsFor: 'MinnieStore'!asMSText	"Answer myself inside an MSText object."	FlavorCompatibility MinneStore.	^MSText newOn: self.! !!Stream methodsFor: 'As yet unclassified'!skipSeparatorsAndPunctuation	"Advance the receiver's position over any leading whitespace or punctuation.	Answer whether their are more elements remaining in the receiver	after the separators."		#MinneStoreCompatibility.	self skipWhile: [:c | c isLetter not and: [c isDigit not]].	^self atEnd not! !!Collection methodsFor: 'MinnieStore'!intersectionOf: aCollection	"Answer the elements that are also in aCollection.	If possible, the receiver should be the larger collection."	FlavorCompatibility MinneStore.	self == aCollection ifTrue: [ ^self ].	^self select: [ :each | aCollection includes: each ].! !!Object methodsFor: 'MinnieStoneExtension'!isMSProxy	"Answer false"	FlavorCompatibility MinneStore.	^false! !!String methodsFor: 'MinnieStore'!lastIndexOf: aCharacter	FlavorCompatibility MinneStore.	self size to: 1 by: -1 do: 		[:i | 		(self at: i) == aCharacter			ifTrue: [^i]].	^0! !!Object class methodsFor: 'MinnieStoneGGExtension'!debugPropertyEngine	Transcript show: ('MinnieStorePropertyDB size is ', (MinneStorePropertyDB size printString)); cr.	MinneStorePropertyDB inspect.! !!String methodsFor: 'MinnieStore'!startsWith: aString	"Answer true if my first characters match aString.  Ignore case."	FlavorCompatibility MinneStore.	aString size > self size ifTrue: [ ^false ].	1 to: aString size do: [ :x |		(self at: x) asLowercase == (aString at: x) asLowercase			ifFalse: [ ^false ] ].	^true.	! !!Object methodsFor: 'MinnieStoneExtension'!isDODeletedObject	FlavorCompatibility MinneStore.	^false! !!Bag methodsFor: 'MinnieStore'!asArrayByDescendingOccurrences	"Added by MinneStore.  Specific to Dolphin because the contents variable is not 	standard or accessible from outside the Bag.  If there were an accessor, I would 	have put this code into a FlavorCompatibility method."	"Fixed by GG, caused test3 to fail"	| sc |	#MinneStoreCompatibility.	sc := SortedCollection sortBlock: [ :a :b | a value > b value ].	"Original:	elements associationsDo: [ :assoc | sc add: assoc ]."	"Fix:"	contents associationsDo: [ :assoc | sc add: assoc ].	^sc asArrayCollect: [ :assoc | assoc key ].! !!Object methodsFor: 'MinnieStoneExtension'!propertyAt: aSymbol ifAbsent: aBlock	"Non sicuto che funzioni al 100%"	"Transcript show: ('Requested propertyAt:ifAbsent of a ', self printString) ; cr."	"by GG"	MinneStorePropertyDB at: self ifAbsent: [ ^aBlock value].	(MinneStorePropertyDB at: self) at: aSymbol  ifAbsent: [ ^aBlock value].	^((MinneStorePropertyDB at: self) at: aSymbol ).! !!Object class methodsFor: 'MinnieStoneGGExtension'!postLoadActionFor: aParcel	"A Parcel's post-load action must be a class method taking one	 argument, the Parcel being loaded.  Fill-out this template, and accept.	 Note that you can give the method whatever selector you want.	 You don't have to use postLoadActionFrom:."	"This code will improve usability of MinnieStore!!!!"	|comment|	Smalltalk declare: #MinneStorePropertyDB from: Undeclared.	comment := aParcel comment.	(ComposedTextView			createOn: (TextCollector with: comment)			label: 'MinnieStore Installation Workspace'			icon: (Icon constantNamed: #workspace))		openIn: (30@250 extent: 500@300)! !!Object methodsFor: 'MinnieStoneExtension'!propertyAt: aSymbol put: aObject 	"Transcript show: ('Requested propertyAt:put: of a ', self printString) ; cr."	"by GG"	MinneStorePropertyDB at: self ifAbsent: [MinneStorePropertyDB at: self put: (WeakDictionary new: 4)].	(MinneStorePropertyDB at: self)		at: aSymbol put: aObject! !"Imported Classes:"!self error: 'Attempting to file-in parcel imports.  Choose terminate or close'!nil subclass: #Object	instanceVariableNames: ''	classVariableNames: 'DependentsFields '	poolDictionaries: ''	category: 'Kernel-Objects'!Object class	instanceVariableNames: ''!Object subclass: #UndefinedObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!Number subclass: #Integer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magnitude-Numbers'!Object subclass: #Stream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!InternalStream subclass: #WriteStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!Object subclass: #Collection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Abstract'!CharacterArray subclass: #String	instanceVariableNames: ''	classVariableNames: 'DefaultClassForPlatform PrimitiveArgumentClass '	poolDictionaries: ''	category: 'Collections-Text'!Collection subclass: #Bag	instanceVariableNames: 'contents '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!Exception subclass: #Error	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Exception Handling'!