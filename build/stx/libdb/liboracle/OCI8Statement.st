"{ Package: 'stx:libdb/liboracle' }"

"{ NameSpace: SQL }"

Statement subclass:#OCI8Statement
	instanceVariableNames:'executeMode processedRows state textBuffer'
	classVariableNames:''
	poolDictionaries:''
	category:'DataBase-Oracle-Statements'
!

!OCI8Statement class methodsFor:'documentation'!

copyright
"
 COPYRIGHT (c) 2003 by eXept Software AG
	      All Rights Reserved

 This software is furnished under a license and may be used
 only in accordance with the terms of that license and with the
 inclusion of the above copyright notice.   This software may not
 be provided or otherwise made available to, or used by, any
 other person.  No title to or ownership of the software is
 hereby transferred.
"
!

documentation
"
    abstract super class for oci 8 statements. There are three different kinds of statements. Query,
    data definition and data manipulation statements.

    [author:]
	Pierre Schwarz

    [see also:]
	OCI8DDStatement
	OCI8DMStatement
	OCI8QueryStatement

    [instance variables:]

	abortState <Boolean>
	    can be set to true, if the statement should be aborted, e.g. to
	    cancel long running statements.

	arrayBind <Boolean>
	    is true if the statement does an array insert (multiple values for one bind variable),
	    false if not.

	bindDescriptors
	    holds a collection of descriptors which describes the bind variabels in the receivers text
	    (see OCI8BindDescriptor).

	binded <Boolean>
	    is true if the statement is binded else false

	bindNames <OrderedCollection>
	    a collection into which dictionaries (name -> an OCI8Converter) are added.
	    Those dictionaries describe the information needed to generate bind variables.

	bindVariables <OrderedCollection>
	    collection of bind variables for the receiver. These are
	    automatical generated by the describtions out of the instance variable
	    bindNames.

	executeMode <Symbol>
	    describes how this statement is executed; if not specified the mode is OCI_DEFAULT

	handle <OCI8Handle>
	    holds the external address (handle) and type (a symbol)
	    for the oci handle

	processedRows <Integer>
	    returns the number of rows affected by the statement

	session <OCI8Session>
	    holds the session which created the statement. Used to access some
	    parameters of the session.

	state <Sumbol>
	    returns the state of a statement. Possible values are:
		#prepared   first state of an statement. After generating it
			    the state of it will be prepared
		#executing  state during the execution of a statement
		#executed   state after the execution of a statement
		#fetching   state during the fetch operation of a statement
		#fetched    state after the fetch operation of a statement

	text <String>
	    the text of the statement

	textBuffer

    [class variables:]
"
! !

!OCI8Statement class methodsFor:'instance creation'!

newForEnvironment:env text:aStatementText
    "
     returns an instance of the correct subclass of OCI8Statement for the statement text.
     Three diverent types of statements exist:
     1. dd (data definition) statements
     2. dm (data manipulation) statements
     3. query statements

     To generate such an instance a new statement handle is allocated and the statement
     is prepared. Then the statement type can be queried by an oci call (OCIAttrGet).
     The symbol returned by stmtType:statementHandle:errorOCIHandle: determines the
     subclass of which an instance is created by statementFor:.
     At least set the parameters of the statement and register it for finalization.

     <return: OCI8QueryStatement OCI8SelectStatement | OCI8InsertStatement >
    "

    |statementHandle statementType aStatement aStatementTextBuffer|

    aStatementTextBuffer := OCI8Handle bufferForSize:aStatementText size + 1.
    aStatementTextBuffer stringAt:1 put:aStatementText.
    [
	statementHandle := env handle newHandleWithType:#OCI8StatementHandle.
	statementHandle prepare:aStatementTextBuffer
		       language:#'OCI_NTV_SYNTAX'
			   mode:#'OCI_DEFAULT'
		    errorHandle:nil.
    ] ifCurtailed:[
	aStatementTextBuffer free.
    ].
    statementType := statementHandle getAttribute:#'OCI_ATTR_STMT_TYPE'
				     errorHandle:nil.
    statementType := OCI8Handle symbolForNumericStatementType:statementType.

    aStatement := self statementFor:statementType.
    aStatement initializeHandle:statementHandle textBuffer:aStatementTextBuffer.
"/    aStatement environment:env.
    ^ aStatement.
!

newForSession:aSession text:aStatementTextString
    "return a statement for a given session.
     The statement lives for the lifetime of the sessions environment"

    ^ self newForEnvironment:(aSession environment) text:aStatementTextString
!

newText:aStatementTextString
    "return a statement for the default environment"

    ^ self newForEnvironment:(OCI8Environment default) text:aStatementTextString

    "
      self newText:'insert into numbertest values (:num) return number into :numReturn'
      self newText:'insert into numbertest bla fasel quall'
    "
! !

!OCI8Statement class methodsFor:'examples'!

examples_dateTest1
"
insert a date
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement dateStream resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table datetest'.
    createTableStatement := session newStatementFor:'create table datetest (d date)'.
    insertStatement := session newStatementFor:'insert into datetest values (TO_DATE(:d,''YYYY-MM-DD HH24:MI:SS''))'.
    selectStatement := session newStatementFor:'select * from datetest'.
    insertStatement stringBindVariable:#d.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    dateStream := WriteStream on:String new.
    Timestamp now printOn:dateStream format:'%(year)-%(mon)-%(day) %h:%m:%s'.
    session executeStatement:insertStatement from:(Array with:dateStream contents).
    resultStream := WriteStream on:Array new.
    session executeStatement:selectStatement into:resultStream.
    (resultStream contents first first) inspect.

    session disconnect.
								[exEnd]
"
!

examples_numberTest1
"
Example 1:
insert and select positive fixed points;
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement
     deleteStatement number resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table numbertest'.
    createTableStatement := session newStatementFor:'create table numbertest (num number(12,5))'.
    insertStatement := session newStatementFor:'insert into numbertest values (:num)'.
    selectStatement := session newStatementFor:'select num from numbertest where rownum = 1'.
    deleteStatement := session newStatementFor:'delete from numbertest where rownum = 1'.
    insertStatement integerBindVariable:#num.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    number := (9999531/10) asFixedPoint.
    [   |result|

	session executeStatement:insertStatement from:(Array with:number).
	resultStream := WriteStream on:Array new.
	session executeStatement:selectStatement into:resultStream.
	result := resultStream contents first first.
	Transcript showCR:'insert number: ',number printString,' selected number: ',result printString.
	session executeStatement:deleteStatement.
	number := number + (0.2 asFixedPoint).
    ]doWhile:[number <= ((9999531/10)+100)].

    session disconnect.
								[exEnd]

Example 2:
insert and select negative fixed points;
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement
     deleteStatement number resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table numbertest'.
    createTableStatement := session newStatementFor:'create table numbertest (num number(12,5))'.
    insertStatement := session newStatementFor:'insert into numbertest values (:num)'.
    selectStatement := session newStatementFor:'select num from numbertest where rownum = 1'.
    deleteStatement := session newStatementFor:'delete from numbertest where rownum = 1'.
    insertStatement integerBindVariable:#num.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    number := (-99997/10) asFixedPoint.
    [   |result|

	session executeStatement:insertStatement from:(Array with:number).
	resultStream := WriteStream on:Array new.
	session executeStatement:selectStatement into:resultStream.
	result := resultStream contents first first.
	Transcript showCR:'insert number: ',number printString,' selected number: ',result printString.
	session executeStatement:deleteStatement.
	number := number + (0.2 asFixedPoint).
    ]doWhile:[number <= ((-99997/10)+100)].

    session disconnect.
								[exEnd]

"
!

examples_numberTest2
"
Example 2:
insert and select positive floats
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement
     deleteStatement number resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table numbertest'.
    createTableStatement := session newStatementFor:'create table numbertest (num float)'.
    insertStatement := session newStatementFor:'insert into numbertest values (:num)'.
    selectStatement := session newStatementFor:'select num from numbertest where rownum = 1'.
    deleteStatement := session newStatementFor:'delete from numbertest where rownum = 1'.
    insertStatement integerBindVariable:#num.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    number := 5.9876.

    [   |result|

	session executeStatement:insertStatement from:(Array with:number).
	resultStream := WriteStream on:Array new.
	session executeStatement:selectStatement into:resultStream.
	result := resultStream contents first first.
	Transcript showCR:'insert number: ',number printString,' selected number: ',result printString.
	session executeStatement:deleteStatement.
	number := number + 0.02.
    ]doWhile:[number <= (5.9876+10.0)].

    session disconnect.
								[exEnd]


Example 2:
insert and select positive floats;
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement
     deleteStatement number resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table numbertest'.
    createTableStatement := session newStatementFor:'create table numbertest (num float)'.
    insertStatement := session newStatementFor:'insert into numbertest values (:num)'.
    selectStatement := session newStatementFor:'select num from numbertest where rownum = 1'.
    deleteStatement := session newStatementFor:'delete from numbertest where rownum = 1'.
    insertStatement integerBindVariable:#num.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    number := 999.0000.

    [   |result|

	session executeStatement:insertStatement from:(Array with:number).
	resultStream := WriteStream on:Array new.
	session executeStatement:selectStatement into:resultStream.
	result := resultStream contents first first.
	Transcript showCR:'insert number: ',number printString,' selected number: ',result printString.
	session executeStatement:deleteStatement.
	number := number + 0.001.
    ]doWhile:[number <= (999.0000+1.0)].

    session disconnect.
								[exEnd]
"
!

examples_numberTest3
"
Example 1:
insert and select positve integers
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement
     deleteStatement number resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table numbertest'.
    createTableStatement := session newStatementFor:'create table numbertest (num number)'.
    insertStatement := session newStatementFor:'insert into numbertest values (:num)'.
    selectStatement := session newStatementFor:'select num from numbertest where rownum = 1'.
    deleteStatement := session newStatementFor:'delete from numbertest where rownum = 1'.
    insertStatement integerBindVariable:#num.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    number := 99999999999999.

    [   |result|

	session executeStatement:insertStatement from:(Array with:number).
	resultStream := WriteStream on:Array new.
	session executeStatement:selectStatement into:resultStream.
	result := resultStream contents first first.
	Transcript showCR:'insert number: ',number printString,' selected number: ',result printString.
	session executeStatement:deleteStatement.
	number := number + 1.
    ]doWhile:[number <= (99999999999999+1000)].

    session disconnect.
								[exEnd]


Example 2:
insert and select negative integers
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement
     deleteStatement number resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table numbertest'.
    createTableStatement := session newStatementFor:'create table numbertest (num number)'.
    insertStatement := session newStatementFor:'insert into numbertest values (:num)'.
    selectStatement := session newStatementFor:'select num from numbertest where rownum = 1'.
    deleteStatement := session newStatementFor:'delete from numbertest where rownum = 1'.
    insertStatement integerBindVariable:#num.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    number := -99999999999999.

    [   |result|

	session executeStatement:insertStatement from:(Array with:number).
	resultStream := WriteStream on:Array new.
	session executeStatement:selectStatement into:resultStream.
	result := resultStream contents first first.
	Transcript showCR:'insert number: ',number printString,' selected number: ',result printString.
	session executeStatement:deleteStatement.
	number := number + 1.
    ]doWhile:[number <= (-99999999999999+1000)].

    session disconnect.
								[exEnd]
"

!

examples_stringTest1
"
Example 1:
insert and select positve integers
								[exBegin]
    |session dropTableStatement createTableStatement insertStatement selectStatement
     deleteStatement longString resultStream|

    session := OCI8Session default.

    dropTableStatement := session newStatementFor:'drop table stringtest'.
    createTableStatement := session newStatementFor:'create table stringtest (string long)'.
    insertStatement := session newStatementFor:'insert into stringtest values (:string)'.
    selectStatement := session newStatementFor:'select string from stringtest where rownum = 1'.
    deleteStatement := session newStatementFor:'delete from stringtest where rownum = 1'.
    insertStatement stringBindVariable:#string.

    session connectWithUsername:'scott' password:'tiger' dbname:'test'.

    OCIErrorSignal handle:[:ex |
    ] do:[
	session executeStatement:dropTableStatement.
    ].
    session executeStatement:createTableStatement.

    longString := (1 to: 20000) inject:'' into:[:accu :el| accu , el printString].

    session executeStatement:insertStatement from:(Array with:longString).
    resultStream := WriteStream on:Array new.
    session executeStatement:selectStatement into:resultStream.
    (resultStream contents first first) inspect.

    session disconnect.
								[exEnd]
"
! !

!OCI8Statement class methodsFor:'private'!

statementFor:aStatementTypeSymbol
"
returns an statement instance for a spezific symbol. There are three different
statement classes: data manipulation, data definition and query statements.
One of the three classes is instanciated for the type symbol.

<return: OCI8QueryStatement | OCI8DMLStatement | OCI8DDLStatement>
"

    aStatementTypeSymbol == #'OCI_STMT_SELECT' ifTrue:[
	"query statement"
	^ OCI8QueryStatement new
    ].
    (aStatementTypeSymbol == #'OCI_STMT_INSERT' or:[
     aStatementTypeSymbol == #'OCI_STMT_UPDATE' or:[
     aStatementTypeSymbol == #'OCI_STMT_DELETE' or:[
     aStatementTypeSymbol == #'OCI_STMT_ALTER']]]
     ) ifTrue:[
	"DM (data manipulation) statement"
	^ OCI8DMStatement new
    ].
    (aStatementTypeSymbol == #'OCI_STMT_CREATE' or:[
     aStatementTypeSymbol == #'OCI_STMT_DROP' or:[
     aStatementTypeSymbol == #'OCI_STMT_OTHER' "e.g. trucate table ..."]]) ifTrue:[
	"DD (data definition) statement"
	^ OCI8DDStatement new
    ].

    ^ SQLError raiseErrorString:' - unspecified oracle statement type symbol'
! !

!OCI8Statement methodsFor:'accessing'!

errorHandle
"
returns the error handle from the session. The handle is used
to get specific informations when an error occured.

<return: OCI8Handle>
"
"/    ^self session errorHandle


    ^ nil    "/this causes an error handle to be allocated
!

executeMode
    "returns the mode in which the statement is executed. When not specified
     the mode is OCI_DEFAULT.

    <return: Symbol>"

    executeMode isNil ifTrue:[
	executeMode := #'OCI_DEFAULT'
    ].
    ^ executeMode
!

handle
    "
    returns the handle of the receiver.

    <return: OCI8Handle>
    "
    ^ handle
!

handle:anOCI8Handle
    "set the handle of the receiver"

    handle := anOCI8Handle.
!

state
    "
    returns the state of the receiver. Possible values are:

	#prepared   first state of an statement. After generating it
		    the state of it will be prepared
	#executing  state during the execution of a statement
	#executed   state after the execution of a statement
	#fetching   state during the fetch operation of a statement
	#fetched    state after the fetch operation of a statement

    <return: Symbol>
    "
    ^ state
!

text
    "returns the statements text
     <return: aString>"

    textBuffer isNil ifTrue:[
	^ ''.
    ].

    ^ textBuffer stringAt:1 size:(textBuffer size - 1)
!

textBuffer
"
returns the buffer for the statements text. Is used to provide
a fix text buffer for the oci lib.

<return: ExternalBytes>
"

    ^ textBuffer
!

textBuffer:anExternalBytes
"
sets the buffer for the statements text. Is used to provide
a fix text buffer for the oci lib.

<return: self>
"
    textBuffer := anExternalBytes.
! !

!OCI8Statement methodsFor:'computation'!

processedRows
    "compute the rows affected since the last execute operation

     <return: Integer>"

     ^ processedRows := handle getAttribute:#'OCI_ATTR_ROW_COUNT' errorHandle:self errorHandle.
! !

!OCI8Statement methodsFor:'initialization'!

initializeHandle:statementHandle textBuffer:aStatementTextBuffer
    "this is called after an instance has been created.
     Initialize my basic state"

    handle := statementHandle.
    textBuffer := aStatementTextBuffer.
    self registerForFinalization.
    self setPrepared.
! !

!OCI8Statement methodsFor:'private accessing'!

state:aSymbol
"
returns the state of the receiver. Possible values are:

    #prepared   first state of an statement. After generating it
		the state of it will be prepared
    #executing  state during the execution of a statement
    #executed   state after the execution of a statement
    #fetching   state during the fetch operation of a statement
    #fetched    state after the fetch operation of a statement

<return: self>
"

    state := aSymbol.
! !

!OCI8Statement methodsFor:'releasing'!

finalize
    "this is invoked when an instance of myself has been garbage collected.
     Release the handle of the receiver. This will auto free any bind
     and/or define pointers. Release the text buffer.

     <return: self>"

    textBuffer notNil ifTrue:[
	textBuffer free.
	textBuffer := nil.
    ].
    handle notNil ifTrue:[
	handle release.
	handle := nil.
    ]
!

release
    "release the statement"

    self unregisterForFinalization.
    self finalize.
! !

!OCI8Statement methodsFor:'set states'!

setAborted
"
sets the statements abort state to true. The statement will be aborted if
not finished execution.

<return: self>
"
    self abortState:true
!

setExecuted
"
sets the statements state executed.

<return: self>
"
    self state:#executed
!

setExecuting
"
sets the statements state executing.

<return: self>
"
    self state:#executing
!

setFetched
"
sets the statements state fetched.

<return: self>
"
    self state:#fetched
!

setFetching
"
sets the statements state fetching.

<return: self>
"
    self state:#fetching
!

setPrepared
"
sets the statements state prepared.

<return: self>
"
    self state:#prepared
! !

!OCI8Statement methodsFor:'testing'!

isDDLStatement
    "return true if the statement is a data definition statement"

    ^ false
!

isDMLStatement
    "return true if the statement is a data manipulation statement"

    ^ false
!

isExecuted
   "return true if the statement has been executed"

    ^ state == #executed
!

isExecuting
   "return true if the statement is currently being executed"

    ^ state == #executing
!

isFetched
    "returns true if the statement fetch operation is finished"

    ^ state == #fetched
!

isQueryStatement
    "return true if the statement is a query statement"

    ^ false
! !

!OCI8Statement class methodsFor:'documentation'!

version
    ^ '$Header: /cvs/stx/stx/libdb/liboracle/OCI8Statement.st,v 1.8 2016-10-13 00:15:07 cg Exp $'
! !
